<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>高德地图空间分析</title>
    <link rel="stylesheet" href="/static/css/map-common.css?v={{ static_version }}">
    <link rel="stylesheet" href="/static/css/filter-panel.css?v={{ static_version }}">
    <link rel="stylesheet" href="/static/css/analysis-page.css?v={{ static_version }}">
</head>

<body>
    <!-- 立即显示的全局加载状态 -->
    <div id="loading-overlay" class="page-loading-global">
        <div class="spinner"></div>
    </div>

    <!-- Vue App 挂载点 -->
    <div id="app" style="display: flex; width: 100%; height: 100%;" v-cloak>

        <!-- Left Sidebar: Wizard Dashboard -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div v-if="sidebarView === 'wizard'" class="step-header-nav" style="margin:0; width:100%;">
                    <button v-if="step === 1" class="btn-text-back" @click="backToHome">← 返回主页</button>
                </div>

                <div v-if="sidebarView === 'history'" class="step-header-nav history-header-nav">
                    <div class="history-header-slot left">
                        <button class="btn-text-back"
                            @click="isSelectionMode ? toggleSelectionMode(false) : backToHome()" style="margin:0;">
                            {% raw %}{{ isSelectionMode ? '取消' : '← 返回主页' }}{% endraw %}
                        </button>
                    </div>
                    <h3 class="history-header-title">历史记录</h3>
                    <div class="history-header-slot right" style="display:flex; align-items:center; justify-content:flex-end; gap:8px;">
                        <button v-if="!isSelectionMode" class="btn-text-back history-icon-btn"
                            :class="{ 'is-loading': historyLoading }"
                            @click="refreshHistoryList" :disabled="historyLoading" style="margin:0;"
                            title="刷新历史记录" aria-label="刷新历史记录">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M20 5v5h-5"></path>
                                <path d="M4 19v-5h5"></path>
                                <path d="M6.2 8.2A8 8 0 0 1 18 10"></path>
                                <path d="M17.8 15.8A8 8 0 0 1 6 14"></path>
                            </svg>
                        </button>
                        <button class="btn-text-back" @click="toggleSelectionMode(!isSelectionMode)" style="margin:0;">
                            {% raw %}{{ isSelectionMode ? '完成' : '管理' }}{% endraw %}
                        </button>
                    </div>
                </div>
            </div>

            <div class="sidebar-content">

                <!-- Start Screen -->
                <div v-show="sidebarView === 'start'" class="home-menu">
                    <div class="home-card" @click="confirmNavigation(() => resetAnalysis())">
                        <div class="home-icon">
                            <img src="/static/images/search.svg" alt="探索">
                        </div>
                        <div class="home-text">
                            <h3>实时探索</h3>
                            <p>Real-time Explore</p>
                            <p style="margin-top:4px; color:#999;">基于高德实时数据分析</p>
                        </div>
                    </div>

                    <div class="home-card"
                        @click="confirmNavigation(() => openHistoryView())">
                        <div class="home-icon">
                            <img src="/static/images/history.svg" alt="档案">
                        </div>
                        <div class="home-text">
                            <h3>本地档案</h3>
                            <p>Local Archives</p>
                            <p style="margin-top:4px; color:#999;">查看往期分析记录</p>
                        </div>
                    </div>
                </div>

                <!-- History View -->
                <div v-show="sidebarView === 'history'" class="history-list" style="padding-bottom: 80px;">
                    <div v-if="historyLoading && historyList.length === 0">
                        <div v-for="n in historySkeletonCount" :key="'history-skeleton-' + n" class="history-card history-skeleton-card">
                            <div style="flex:1;">
                                <div class="skeleton-line skeleton-line-title"></div>
                                <div class="skeleton-line skeleton-line-meta"></div>
                            </div>
                        </div>
                    </div>

                    <div v-for="item in historyList" :key="item.id" class="history-card"
                        @click="handleHistoryItemClick(item)"
                        :class="{'selection-mode': isSelectionMode, 'selected': selectedHistoryIds.includes(item.id)}">

                        <!-- Checkbox for Selection Mode -->
                        <div v-if="isSelectionMode" class="checkbox-wrapper">
                            <div class="custom-checkbox" :class="{checked: selectedHistoryIds.includes(item.id)}">
                                <svg v-if="selectedHistoryIds.includes(item.id)" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>

                        <div style="flex:1;">
                            <div class="card-header">
                                <span class="card-title">{% raw %}{{ formatHistoryTitle(item.description) }}{% endraw
                                    %}</span>
                            </div>
                            <div class="card-meta">
                                <div class="meta-row">
                                    <span class="meta-tag mode-tag">
                                        <span v-if="item.params && item.params.mode === 'driving'">
                                            <img src="/static/images/driving.svg"> 驾车
                                        </span>
                                        <span v-else-if="item.params && item.params.mode === 'bicycling'">
                                            <img src="/static/images/cycling.svg"> 骑行
                                        </span>
                                        <span v-else>
                                            <img src="/static/images/walking.svg"> 步行
                                        </span>
                                    </span>
                                    <span v-if="item.params && item.params.time_min" class="meta-tag time-tag">
                                        <img src="/static/images/time.svg"> {% raw %}{{ item.params.time_min }}{% endraw
                                        %}分
                                    </span>
                                </div>
                                <span class="meta-date">
                                    {% raw %}{{ item._createdDateText || item.created_at }}{% endraw %}
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Batch Delete Footer -->
                    <div v-if="isSelectionMode"
                        style="position:fixed; bottom:0; left:0; width:var(--sidebar-width); background:#fff; padding:15px; border-top:1px solid #eee; box-shadow:0 -2px 10px rgba(0,0,0,0.05); z-index:100; box-sizing:border-box; display:flex; gap:10px;">
                        <button class="btn-black" :disabled="selectedHistoryIds.length === 0"
                            @click="deleteSelectedHistory" style="background: #ff4d4f; border:none; width:100%;">
                            删除选中 ({% raw %}{{ selectedHistoryIds.length }}{% endraw %})
                        </button>
                    </div>

                    <div v-if="!historyLoading && historyList.length === 0"
                        style="text-align:center; padding:40px 20px; color:#999; display:flex; flex-direction:column; align-items:center;">
                        <img src="/static/images/empty.svg"
                            style="width:48px; height:48px; opacity:0.3; margin-bottom:10px;">
                        <span>暂无历史记录</span>
                    </div>
                </div>

                <!-- Wizard View Wrapper -->
                <div v-show="sidebarView === 'wizard'" style="display:contents;">

                    <!-- Step 1: Location & Analysis -->
                    <div v-show="step === 1" class="wizard-step">
                        <div class="step-title">
                            <h3>1. 地点与范围</h3>
                        </div>

                        <div class="form-group search-group">
                            <input type="text" id="keyword" class="minimal-input" placeholder="搜索地点..."
                                @keyup.enter="triggerSearch">
                            <button class="btn-icon" @click="triggerSearch">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                </svg>
                            </button>
                        </div>

                        <div class="form-group">
                            <div v-if="selectedPoint" class="status-badge success">
                                已选: {% raw %}{{ selectedPoint.lng.toFixed(4) }}, {{ selectedPoint.lat.toFixed(4) }}{%
                                endraw
                                %}
                            </div>
                            <div v-else class="status-badge warning">请在地图上点击或搜索选择起点</div>
                        </div>

                        <div class="form-group">
                            <label>出行方式</label>
                            <div class="mode-select">
                                <div class="mode-select">
                                    <div class="mode-option" :class="{active: transportMode==='walking'}"
                                        @click="transportMode='walking'">步行 <img src="/static/images/walking.svg"></div>
                                    <div class="mode-option" :class="{active: transportMode==='bicycling'}"
                                        @click="transportMode='bicycling'">骑行 <img src="/static/images/cycling.svg">
                                    </div>
                                    <div class="mode-option" :class="{active: transportMode==='driving'}"
                                        @click="transportMode='driving'">驾车 <img src="/static/images/driving.svg"></div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>时间范围: {% raw %}{{ timeHorizon }}{% endraw %} 分钟</label>
                            <input type="range" v-model.number="timeHorizon" class="minimal-range" min="5" max="60"
                                step="5">
                        </div>
                        <div class="form-group" style="display:flex; align-items:center; gap:8px;">
                            <label style="margin:0;">底图源</label>
                            <select v-model="basemapSource" @change="onBasemapSourceChange"
                                class="minimal-input" style="padding:4px 8px; max-width:180px;">
                                <option value="tianditu">天地图（国内科研）</option>
                                <option value="osm">OpenStreetMap（科研）</option>
                                <option value="amap">高德（业务）</option>
                            </select>
                        </div>


                        <button class="btn-black" :disabled="!selectedPoint || isCalculating" @click="startAnalysis">
                            {% raw %}{{ isCalculating ? '计算中...' : '下一步: 生成等时圈' }}{% endraw %}
                        </button>
                        <div v-if="errorMessage" class="error-msg">{% raw %}{{ errorMessage }}{% endraw %}</div>
                        <div v-if="basemapSource === 'tianditu' && tdtDiag && tdtDiag.ok === false"
                            style="margin-top:10px; padding:10px; border:1px solid #f1b0b7; border-radius:8px; background:#fff7f7;">
                            <div style="font-size:12px; font-weight:600; color:#9f1239; margin-bottom:6px;">天地图诊断信息</div>
                            <div style="font-size:11px; color:#6b7280; line-height:1.5; margin-bottom:6px;">
                                {% raw %}阶段={{ tdtDiag.phase || '-' }}；状态={{ tdtDiag.status === null || tdtDiag.status === undefined ? '-' : tdtDiag.status }}；内容类型={{ tdtDiag.contentType || '-' }}{% endraw %}
                            </div>
                            <pre
                                style="margin:0; max-height:120px; overflow:auto; white-space:pre-wrap; word-break:break-all; font-size:11px; line-height:1.45; color:#4b5563; background:#fff; border:1px solid #e5e7eb; border-radius:6px; padding:8px;">{% raw %}{{ buildTdtDiagText() }}{% endraw %}</pre>
                            <div style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <button type="button" class="btn-outline" style="margin-top:0; padding:6px 12px; width:auto;"
                                    @click="copyTdtDiag">
                                    复制诊断
                                </button>
                                <span style="font-size:11px; color:#6b7280;">{% raw %}{{ tdtDiagCopyStatus }}{% endraw %}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: POI Categories -->
                    <div v-show="step === 2" class="wizard-step">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(1)">← 返回</button>
                            <h3>2. 选择业态</h3>
                        </div>
                        <p class="step-desc">选择需要在等时圈内抓取的设施类型</p>

                        <div class="category-grid">
                            <div v-for="cat in poiCategories" :key="cat.id" class="cat-card" :class="{checked: cat.checked}">
                                <div class="cat-color" :style="{background: cat.color}"></div>
                                <div class="cat-texts">
                                    <div class="cat-header-row">
                                        <label class="cat-check" @click.stop>
                                            <input type="checkbox" :checked="cat.checked"
                                                @change="togglePoiCategory(cat, $event.target.checked)">
                                            <span class="cat-name">{% raw %}{{ cat.name }}{% endraw %}</span>
                                        </label>
                                        <button v-if="getPoiSubItems(cat.id).length" type="button" class="cat-expand-btn"
                                            @click.stop="togglePoiCategoryExpand(cat.id)">
                                            {% raw %}{{ expandedPoiCategoryId === cat.id ? '收起' : '展开' }}{% endraw %}
                                        </button>
                                    </div>
                                    <div class="cat-subtypes" v-if="getPoiSubItems(cat.id).length">
                                        已选 {% raw %}{{ getPoiSubSelectedCount(cat.id) }}{% endraw %}/{% raw %}{{ getPoiSubItems(cat.id).length }}{% endraw %} 个小类
                                    </div>
                                    <div class="cat-subitem-list" v-show="expandedPoiCategoryId === cat.id"
                                        v-if="getPoiSubItems(cat.id).length">
                                        <label v-for="item in getPoiSubItems(cat.id)" :key="`step2-sub-${cat.id}-${item.id}`"
                                            class="cat-subitem" @click.stop>
                                            <input type="checkbox" :checked="isPoiSubItemChecked(item.id)"
                                                @change="onPoiSubItemToggle(cat, item, $event.target.checked)">
                                            <span>{% raw %}{{ item.label }}{% endraw %}</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <button class="btn-black" :disabled="isFetchingPois" @click="fetchPois">
                            {% raw %}{{ isFetchingPois ? '数据抓取中 ' + fetchProgress + '%' : '下一步: 抓取数据' }}{% endraw %}
                        </button>

                        <div v-if="isFetchingPois"
                            style="margin-top:10px; background:#f0f0f0; height:6px; border-radius:3px; overflow:hidden;">
                            <div
                                :style="{width: fetchProgress + '%', background:'#000', height:'100%', transition:'width 0.3s ease'}">
                            </div>
                        </div>
                        <div v-if="isFetchingPois && fetchSubtypeProgress.categoryName" class="fetch-subtype-progress">
                            <div class="line">
                                <span class="label">当前大类：</span>
                                <span>{% raw %}{{ fetchSubtypeProgress.categoryName }}{% endraw %}</span>
                            </div>
                            <div class="line">
                                <span class="label">已命中小类：</span>
                                <template v-if="fetchSubtypeProgress.typeNamesPreview.length">
                                    <span>{% raw %}{{ fetchSubtypeProgress.typeNamesPreview.join('、') }}{% endraw %}</span>
                                    <span v-if="fetchSubtypeProgress.hiddenTypeCount > 0">
                                        {% raw %} 等{{ fetchSubtypeProgress.typeNamesFullCount }}个小类{% endraw %}
                                    </span>
                                </template>
                                <template v-else>
                                    <span>暂无</span>
                                </template>
                            </div>
                        </div>

                        <div v-if="poiStatus" class="status-text">{% raw %}{{ poiStatus }}{% endraw %}</div>
                    </div>

                    <!-- Step 3: Results & Filter -->
                    <div v-show="step === 3" class="wizard-step wizard-step-step3">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(2)">← 返回</button>
                            <h3>3. 结果分析</h3>
                        </div>

                        <div class="step3-layout">
                            <div class="nav-rail">
                                <div v-for="(item, index) in step3NavItems" :key="item.id" class="nav-item" :class="{
                                        active: activeStep3Panel === item.id,
                                        dragging: dragIndex === index,
                                        'insert-before': isDraggingNav && dragOverIndex === index && dragInsertPosition === 'before',
                                        'insert-after': isDraggingNav && dragOverIndex === index && dragInsertPosition === 'after'
                                    }" :title="item.title" draggable="true" @click="selectStep3Panel(item.id)"
                                    @dragstart="onStep3DragStart(index, $event)"
                                    @dragover="onStep3DragOver(index, $event)" @drop="onStep3Drop(index)"
                                    @dragend="onStep3DragEnd">
                                    {% raw %}{{ item.label }}{% endraw %}
                                </div>
                            </div>

                            <div class="panel-area panel-area-fill">
                                <div class="panel poi-panel" v-show="activeStep3Panel === 'poi'">
                                    <div class="poi-panel-header">
                                        <h4>POI 分类</h4>
                                        <div class="poi-panel-actions">
                                            <span id="poiTotalCount" class="count-badge">总数 0</span>
                                            <button id="toggleAllPoi" type="button"
                                                class="btn-outline btn-compact">全部隐藏</button>
                                            <button id="toggleExpandAll" class="btn-outline btn-compact">全部展开</button>
                                        </div>
                                    </div>
                                    <div id="filtersContainer" class="legacy-filters-wrapper"></div>
                                    <div id="poiChart" class="poi-chart"></div>
                                </div>

                                <div class="panel" v-show="activeStep3Panel === 'h3'">
                                    <div class="h3-subtabs h3-stage-tabs">
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'params' }"
                                            @click="onH3MainStageChange('params')">参数</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'analysis' }"
                                            @click="onH3MainStageChange('analysis')">分析</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'diagnosis' }"
                                            @click="onH3MainStageChange('diagnosis')">诊断</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'evaluate' }"
                                            @click="onH3MainStageChange('evaluate')">评估</button>
                                    </div>
                                    <div v-if="h3MainStage === 'params'" class="h3-params-card">
                                        <div class="h3-params-grid">
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">网格级别</span>
                                                <select v-model.number="h3GridResolution" @change="onH3ResolutionChange" class="h3-params-select">
                                                    <option :value="8">8</option>
                                                    <option :value="9">9</option>
                                                    <option :value="10">10</option>
                                                    <option :value="11">11</option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">邻域圈层</span>
                                                <select v-model.number="h3NeighborRing" class="h3-params-select">
                                                    <option :value="1">ring=1</option>
                                                    <option :value="2">ring=2</option>
                                                    <option :value="3">ring=3</option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field h3-params-field-wide">
                                                <span class="h3-params-label">包含模式</span>
                                                <select v-model="h3GridIncludeMode" @change="onH3GridSettingsChange" class="h3-params-select">
                                                    <option value="intersects">相交优先（边缘保留）</option>
                                                    <option value="inside">完全包含（严格）</option>
                                                </select>
                                            </label>
                                            <div class="h3-params-field h3-params-field-wide">
                                                <span class="h3-params-label">最小重叠比例</span>
                                                <div class="h3-params-range-row">
                                                    <input type="range" min="0" max="0.9" step="0.05"
                                                        v-model.number="h3GridMinOverlapRatio" @change="onH3GridSettingsChange"
                                                        class="minimal-range h3-params-range">
                                                    <span class="range-value">{% raw %}{{ h3GridMinOverlapRatio.toFixed(2) }}{% endraw %}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="h3-params-chips">
                                            <span class="count-badge">网格数 {% raw %}{{ h3GridCount }}{% endraw %}</span>
                                        </div>
                                        <div class="h3-params-actions">
                                            <button class="h3-btn h3-btn-ghost"
                                                :disabled="h3GridCount === 0" @click="clearH3Grid">
                                                清空网络
                                            </button>
                                            <button class="h3-btn h3-btn-primary h3-params-compute-btn"
                                                :disabled="isComputingH3Analysis || isGeneratingH3ArcgisSnapshot || !lastIsochroneGeoJSON"
                                                @click="computeH3Analysis">
                                                {% raw %}{{ isComputingH3Analysis ? '分析中...' : '计算分析' }}{% endraw %}
                                            </button>
                                        </div>
                                    </div>
                                    <div class="h3-subtabs"
                                        v-if="h3MainStage !== 'params' && h3AnalysisGridFeatures.length > 0 && getH3CurrentStageTabs().length > 1"
                                        style="margin-top:6px; grid-template-columns: repeat(2, minmax(0, 1fr));">
                                        <button type="button" class="h3-subtab-pill"
                                            v-for="tab in getH3CurrentStageTabs()"
                                            :key="`h3-subtab-${tab}`"
                                            :class="{ active: h3SubTab === tab }"
                                            @click="onH3SubTabChange(tab)">
                                            {% raw %}{{ h3SubTabLabels[tab] || tab }}{% endraw %}
                                        </button>
                                    </div>
                                    <div class="filter-section"
                                        v-if="h3AnalysisGridFeatures.length > 0 && h3MainStage === 'analysis' && h3SubTab === 'metric_map'"
                                        style="margin-top:8px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            地图指标
                                            <select v-model="h3MetricView" @change="onH3MetricViewChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option value="density">密度</option>
                                                <option value="entropy">局部熵</option>
                                                <option value="neighbor_delta">邻域差值（本格-邻域）</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="filter-section"
                                        v-if="h3AnalysisGridFeatures.length > 0 && h3MainStage === 'analysis' && h3SubTab === 'structure_map'"
                                        style="margin-top:8px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            结构图层
                                            <select v-model="h3StructureFillMode" @change="onH3StructureFillModeChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option value="gi_z">Gi*（Z-score 连续）</option>
                                                <option value="lisa_i">LISA（LMiIndex 连续）</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="filter-section h3-control-row h3-control-row-tight"
                                        v-if="h3AnalysisGridFeatures.length > 0 && (h3MainStage === 'diagnosis' || h3MainStage === 'evaluate')"
                                        style="margin-top:8px;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            TopN
                                            <input type="number" min="3" max="30" step="1"
                                                v-model.number="h3DecisionTopN" @change="onH3DecisionSettingsChange"
                                                style="width:68px; padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                        </label>
                                        <label v-if="h3SubTab === 'lq' || h3SubTab === 'gap'"
                                            style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            目标业态
                                            <select v-model="h3TargetCategory" @change="onH3DecisionSettingsChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option v-for="item in h3CategoryMeta" :key="`target-${item.key}`" :value="item.key">
                                                    {% raw %}{{ item.label }}{% endraw %}
                                                </option>
                                            </select>
                                        </label>
                                        <label class="h3-check-chip h3-check-chip-compact">
                                            <input type="checkbox" v-model="h3OnlySignificant" @change="onH3DecisionSettingsChange">
                                            仅结构网格
                                        </label>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary"
                                        style="margin-top:10px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                        <div class="count-badge">POI总数 {% raw %}{{ h3AnalysisSummary.poi_count }}{% endraw %}</div>
                                        <div class="count-badge">平均密度 {% raw %}{{ h3AnalysisSummary.avg_density_poi_per_km2.toFixed(2) }}{% endraw %}</div>
                                        <div class="count-badge">平均熵 {% raw %}{{ h3AnalysisSummary.avg_local_entropy.toFixed(3) }}{% endraw %}</div>
                                        <div class="count-badge">网格数 {% raw %}{{ h3AnalysisSummary.grid_count ?? h3GridCount }}{% endraw %}</div>
                                        <div class="count-badge">Gi*有效格 {% raw %}{{ (h3AnalysisSummary.gi_z_stats && h3AnalysisSummary.gi_z_stats.count) ?? 0 }}{% endraw %}</div>
                                        <div class="count-badge">LISA有效格 {% raw %}{{ (h3AnalysisSummary.lisa_i_stats && h3AnalysisSummary.lisa_i_stats.count) ?? 0 }}{% endraw %}</div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary" class="h3-analysis-hint">
                                        看密度、混合度和邻域差值，优先找“高密且邻域为正”的连续片区。
                                    </div>
                                    <div v-if="h3MainStage !== 'params' && h3Legend && h3Legend.items && h3Legend.items.length"
                                        style="margin-top:10px; border:1px solid #eef1f4; border-radius:8px; padding:8px 10px; background:#fafbfc;">
                                        <div style="font-size:12px; color:#374151; font-weight:600; margin-bottom:6px;">
                                            {% raw %}{{ h3Legend.title }}{% endraw %}
                                            <span style="color:#6b7280; font-weight:400;">
                                                {% raw %}{{ h3Legend.unit ? `（${h3Legend.unit}）` : '' }}{% endraw %}
                                            </span>
                                        </div>
                                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px 10px;">
                                            <div v-for="(item, idx) in h3Legend.items" :key="`legend-${idx}`"
                                                style="display:flex; align-items:center; gap:6px; font-size:11px; color:#4b5563;">
                                                <span :style="{display:'inline-block', width:'12px', height:'12px', borderRadius:'2px', background:item.color, border:'1px solid #d1d5db'}"></span>
                                                <span>{% raw %}{{ item.label }}{% endraw %}</span>
                                            </div>
                                        </div>
                                        <div v-if="h3Legend.noDataLabel"
                                            style="margin-top:6px; font-size:11px; color:#6b7280; display:flex; align-items:center; gap:6px;">
                                            <span :style="{display:'inline-block', width:'12px', height:'12px', borderRadius:'2px', background:h3Legend.noDataColor || '#d1d5db', border:'1px solid #d1d5db'}"></span>
                                            <span>{% raw %}{{ h3Legend.noDataLabel }}{% endraw %}</span>
                                        </div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary" style="margin-top:10px;">
                                        <div id="h3CategoryChart" style="height:180px;"></div>
                                        <div id="h3DensityChart" style="height:180px; margin-top:8px;"></div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'structure_map' && h3DerivedStats.structureSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            结构图口径：仅使用 ArcGIS 连续字段。Gi* 使用 GiZScore；LISA 使用 LMiIndex；网格边框统一蓝色。
                                        </div>
                                        <div v-if="h3AnalysisSummary"
                                            style="margin-top:10px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                            <div class="count-badge">莫兰指数 {% raw %}{{ h3AnalysisSummary.global_moran_i_density ?? 'N/A' }}{% endraw %}</div>
                                            <div class="count-badge">莫兰z值 {% raw %}{{ h3AnalysisSummary.global_moran_z_score ?? 'N/A' }}{% endraw %}</div>
                                            <div v-if="h3StructureFillMode === 'gi_z'" class="count-badge">
                                                Gi*有效格 {% raw %}{{ (h3AnalysisSummary.gi_z_stats && h3AnalysisSummary.gi_z_stats.count) ?? 0 }}{% endraw %}
                                            </div>
                                            <div v-else class="count-badge">
                                                LISA有效格 {% raw %}{{ (h3AnalysisSummary.lisa_i_stats && h3AnalysisSummary.lisa_i_stats.count) ?? 0 }}{% endraw %}
                                            </div>
                                            <div class="count-badge">引擎 {% raw %}{{ (h3AnalysisSummary.analysis_engine || 'pysal').toUpperCase() }}{% endraw %}</div>
                                        </div>
                                        <div v-if="h3DerivedStats.structureSummary.lisaRenderMeta && h3DerivedStats.structureSummary.lisaRenderMeta.degraded"
                                            class="h3-analysis-hint" style="margin-top:8px;">
                                            {% raw %}{{ h3DerivedStats.structureSummary.lisaRenderMeta.message || 'LMiIndex方差不足' }}{% endraw %}
                                        </div>
                                        <div v-if="h3AnalysisSummary && h3AnalysisSummary.arcgis_status"
                                            class="h3-analysis-hint" style="margin-top:8px;">
                                            {% raw %}{{ h3AnalysisSummary.arcgis_status }}{% endraw %}
                                        </div>
                                        <div v-if="h3AnalysisSummary" style="margin-top:8px; display:flex; justify-content:flex-end;">
                                            <button
                                                type="button"
                                                class="btn-outline btn-compact"
                                                :disabled="isComputingH3Analysis || isGeneratingH3ArcgisSnapshot"
                                                @click="generateH3ArcgisSnapshot">
                                                {% raw %}{{ isGeneratingH3ArcgisSnapshot ? '生成快照中...' : '生成结构快照' }}{% endraw %}
                                            </button>
                                        </div>
                                        <div v-if="h3AnalysisSummary && !getArcgisSnapshotUrl()"
                                            class="h3-analysis-hint" style="margin-top:8px;">
                                            当前未生成结构快照，可点击“生成结构快照”按需生成。
                                        </div>
                                        <div v-if="h3AnalysisSummary && getArcgisSnapshotUrl()"
                                            style="margin-top:10px; border:1px solid #eef1f4; border-radius:10px; padding:8px; background:#fafbfc;">
                                            <div style="font-size:12px; color:#374151; font-weight:600; margin-bottom:6px;">
                                                {% raw %}{{ getArcgisSnapshotTitle() }}{% endraw %}
                                            </div>
                                            <img :src="getArcgisSnapshotSrc()"
                                                @load="h3ArcgisSnapshotLoadError = false"
                                                @error="h3ArcgisSnapshotLoadError = true"
                                                alt="ArcGIS结构图"
                                                style="width:100%; border-radius:8px; border:1px solid #dbe2ea;" />
                                            <div v-if="h3ArcgisSnapshotLoadError" class="h3-analysis-hint" style="margin-top:8px;">
                                                ArcGIS结构快照加载失败，请重算一次或切换结构图层后重试。
                                            </div>
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">Gi* 均值</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.giZStats.mean === null ? '-' : h3DerivedStats.structureSummary.giZStats.mean.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">Gi* 中位数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.giZStats.p50 === null ? '-' : h3DerivedStats.structureSummary.giZStats.p50.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">LISA 正值占比</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.lisaPositivePct === null ? '-' : `${(h3DerivedStats.structureSummary.lisaPositivePct * 100).toFixed(1)}%` }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">LISA 负值占比</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.lisaNegativePct === null ? '-' : `${(h3DerivedStats.structureSummary.lisaNegativePct * 100).toFixed(1)}%` }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div id="h3StructureChart" style="height:180px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>Gi*z</th><th>LISA I</th><th>结构信号</th><th>密度</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.structureSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`structure-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.gi_star_z_score === null ? '-' : row.gi_star_z_score.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.lisa_i === null ? '-' : row.lisa_i.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Number.isFinite(row.structure_signal) ? row.structure_signal.toFixed(2) : '-' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density === null ? '-' : row.density.toFixed(2) }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'diagnosis' && h3SubTab === 'typing' && h3DerivedStats.typingSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            看四象限结构：高密高混合偏成熟，高密低混合偏单核，低密高混合偏潜力，低密低混合偏薄弱；同时参考可信度。
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">机会网格数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.typingSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高密度</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.typingSummary.maxDensity.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议动作</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.typingSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <table class="h3-mini-table">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>POI</th><th>密度</th><th>熵</th><th>可信度</th><th>分型</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.typingSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`typing-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.poi_count }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.entropy_norm === null ? '-' : row.entropy_norm.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.type_label }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'diagnosis' && h3SubTab === 'lq' && h3DerivedStats.lqSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            看目标业态相对本分析区是否更强：大于1偏强，小于1偏弱；已做小样本平滑。
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">优势网格数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.lqSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高优势值</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.lqSummary.maxLq.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议业态</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.lqSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div id="h3LqChart" style="height:180px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>POI</th><th>密度</th><th>熵</th><th>可信度</th><th>结构参考</th><th>优势值</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.lqSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`lq-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.poi_count }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.entropy_norm === null ? '-' : row.entropy_norm.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Number.isFinite(row.structure_signal) ? row.structure_signal.toFixed(2) : '-' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.lq_target === null ? '-' : row.lq_target.toFixed(2) }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'evaluate' && h3SubTab === 'gap' && h3DerivedStats.gapSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            先看“需求分位”和“供给分位”，再看两者差值；需求高且供给低的网格优先补位。
                                        </div>
                                        <div v-if="h3DerivedStats.gapSummary.mappingWarning" class="panel-placeholder"
                                            style="margin-top:8px; border-color:#fde68a; background:#fffbeb; color:#92400e;">
                                            {% raw %}{{ h3DerivedStats.gapSummary.mappingWarning }}{% endraw %}
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">高缺口网格</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.gapSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高缺口分</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.gapSummary.maxGap.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议优先区</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.gapSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div class="panel-placeholder" style="margin-top:8px;">
                                            {% raw %}{{ h3DerivedStats.gapSummary.insight || '缺口分 = 需求百分位 - 目标业态供给百分位（越高越可能供给偏弱）' }}{% endraw %}
                                        </div>
                                        <div id="h3GapChart" style="height:180px; margin-top:8px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>需求分位</th><th>供给分位</th><th>缺口分</th><th>可信度</th><th>结论</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.gapSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`gap-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ Math.round((row.demand_pct || 0) * 100) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Math.round((row.supply_pct || 0) * 100) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.gap_score === null ? '-' : row.gap_score.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.gap_zone_label || '-' }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3GridStatus" class="status-text"
                                        style="margin-top:10px; display:flex; align-items:center; gap:8px; justify-content:flex-start;">
                                        <span>{% raw %}{{ h3GridStatus }}{% endraw %}</span>
                                        <button v-if="selectedH3Id" type="button"
                                            style="border:1px solid #d9dee7; background:#fff; color:#4b5563; border-radius:999px; padding:2px 8px; font-size:11px; cursor:pointer;"
                                            @click="clearGridLock">
                                            取消锁定
                                        </button>
                                    </div>
                                </div>

                                <div class="panel" v-show="activeStep3Panel === 'syntax'">
                                    <h4>空间句法路网分析</h4>
                                    <div class="h3-subtabs" style="margin-top:8px;">
                                        <button type="button"
                                            class="h3-subtab-pill"
                                            v-for="tab in roadSyntaxTabs"
                                            :key="`road-syntax-tab-${tab.value}`"
                                            :class="{ active: roadSyntaxMainTab === tab.value }"
                                            :disabled="tab.value !== 'params' && !canActivateRoadSyntaxTab(tab.value)"
                                            @click="setRoadSyntaxMainTab(tab.value)">
                                            {% raw %}{{ tab.label }}{% endraw %}
                                        </button>
                                    </div>

                                    <div v-if="roadSyntaxMainTab === 'params'" class="h3-params-card" style="margin-top:10px;">
                                        <div class="h3-params-grid">
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">交通方式</span>
                                                <select v-model="roadSyntaxMode" class="h3-params-select">
                                                    <option value="walking">步行</option>
                                                    <option value="bicycling">骑行</option>
                                                    <option value="driving">驾车</option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">指标预设</span>
                                                <select v-model="roadSyntaxLastMetricTab" class="h3-params-select">
                                                    <option v-for="tab in roadSyntaxMetricTabs()" :key="`road-syntax-pref-${tab.value}`" :value="tab.value">
                                                        {% raw %}{{ tab.label }}{% endraw %}
                                                    </option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">官方色带</span>
                                                <select v-model="roadSyntaxDepthmapColorScale" class="h3-params-select">
                                                    <option v-for="opt in roadSyntaxDepthmapColorScaleOptions()"
                                                        :key="`road-syntax-color-scale-${opt.value}`"
                                                        :value="opt.value">
                                                        {% raw %}{{ opt.label }}{% endraw %}
                                                    </option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">Blue 阈值</span>
                                                <input
                                                    v-model.number="roadSyntaxDisplayBlue"
                                                    type="number"
                                                    min="0"
                                                    max="1"
                                                    step="0.01"
                                                    class="h3-params-select"
                                                    @change="onRoadSyntaxDisplayRangeChange">
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">Red 阈值</span>
                                                <input
                                                    v-model.number="roadSyntaxDisplayRed"
                                                    type="number"
                                                    min="0"
                                                    max="1"
                                                    step="0.01"
                                                    class="h3-params-select"
                                                    @change="onRoadSyntaxDisplayRangeChange">
                                            </label>
                                        </div>
                                        <div class="h3-params-chips">
                                            <span class="count-badge">渲染档位 {% raw %}{{ roadSyntaxPerformanceProfile }}{% endraw %}</span>
                                            <span class="count-badge">边段上限 {% raw %}{{ roadSyntaxActiveEdgeCap == null ? '无限制' : roadSyntaxActiveEdgeCap }}{% endraw %}</span>
                                        </div>
                                        <div class="h3-params-actions">
                                            <button class="h3-btn h3-btn-primary h3-params-compute-btn"
                                                :disabled="isComputingRoadSyntax || !lastIsochroneGeoJSON"
                                                @click="computeRoadSyntax">
                                                {% raw %}{{ isComputingRoadSyntax ? '计算中...' : '计算路网指标' }}{% endraw %}
                                            </button>
                                        </div>
                                    </div>

                                    <div v-else style="margin-top:10px;">
                                        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                                            <label v-if="roadSyntaxMetric !== 'intelligibility'" style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                                色带
                                                <select v-model="roadSyntaxDepthmapColorScale" @change="refreshRoadSyntaxOverlay"
                                                    style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                    <option v-for="opt in roadSyntaxDepthmapColorScaleOptions()"
                                                        :key="`road-syntax-color-scale-inline-${opt.value}`"
                                                        :value="opt.value">
                                                        {% raw %}{{ opt.label }}{% endraw %}
                                                    </option>
                                                </select>
                                            </label>
                                            <label v-if="roadSyntaxMetric !== 'intelligibility'" style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                                Blue
                                                <input
                                                    v-model.number="roadSyntaxDisplayBlue"
                                                    type="number"
                                                    min="0"
                                                    max="1"
                                                    step="0.01"
                                                    @change="onRoadSyntaxDisplayRangeChange"
                                                    style="width:64px; padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                            </label>
                                            <label v-if="roadSyntaxMetric !== 'intelligibility'" style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                                Red
                                                <input
                                                    v-model.number="roadSyntaxDisplayRed"
                                                    type="number"
                                                    min="0"
                                                    max="1"
                                                    step="0.01"
                                                    @change="onRoadSyntaxDisplayRangeChange"
                                                    style="width:64px; padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                            </label>
                                            <label v-if="roadSyntaxMetricUsesRadius(roadSyntaxMetric)" style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                                半径
                                                <select v-model="roadSyntaxRadiusLabel" @change="refreshRoadSyntaxOverlay"
                                                    style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                    <option v-for="opt in roadSyntaxRadiusOptions()" :key="`road-syntax-radius-${opt.value}`" :value="opt.value">
                                                        {% raw %}{{ opt.label }}{% endraw %}
                                                    </option>
                                                </select>
                                            </label>
                                            <label v-if="roadSyntaxSupportsSkeleton(roadSyntaxMetric)" class="h3-check-chip h3-check-chip-compact">
                                                <input type="checkbox"
                                                    v-model="roadSyntaxSkeletonOnly"
                                                    :disabled="!canToggleRoadSyntaxSkeleton()"
                                                    @change="refreshRoadSyntaxOverlay">
                                                骨架优先
                                            </label>
                                            <span class="count-badge">当前指标 {% raw %}{{ roadSyntaxLabelByMetric(roadSyntaxMetric) }}{% endraw %}</span>
                                            <span class="count-badge">值 {% raw %}{{ formatRoadSyntaxMetricValue(roadSyntaxMetric) }}{% endraw %}</span>
                                            <span v-if="roadSyntaxMetric === 'intelligibility'" class="count-badge">
                                                R² {% raw %}{{ roadSyntaxRegressionView().r2 }}{% endraw %}
                                            </span>
                                        </div>

                                        <div v-if="roadSyntaxLegendModel && roadSyntaxLegendModel.items && roadSyntaxLegendModel.items.length"
                                            style="margin-top:10px; border:1px solid #eef1f4; border-radius:8px; padding:8px 10px; background:#fafbfc;">
                                            <div style="font-size:12px; color:#374151; font-weight:600; margin-bottom:6px;">
                                                {% raw %}{{ roadSyntaxLegendModel.title }}{% endraw %}
                                            </div>
                                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px 10px;">
                                                <div v-for="(item, idx) in roadSyntaxLegendModel.items"
                                                    :key="`road-syntax-legend-${idx}`"
                                                    style="display:flex; align-items:center; gap:6px; font-size:11px; color:#4b5563;">
                                                    <span :style="{display:'inline-block', width:'12px', height:'12px', borderRadius:'2px', background:item.color, border:'1px solid #d1d5db'}"></span>
                                                    <span>{% raw %}{{ item.label }}{% endraw %}</span>
                                                </div>
                                            </div>
                                        </div>

                                        <div v-if="roadSyntaxMainTab === 'intelligibility'" id="roadSyntaxScatterChart"
                                            style="height:220px; margin-top:10px;"></div>
                                    </div>

                                    <div v-if="roadSyntaxSwitchStatsText" class="status-text" style="margin-top:10px;">
                                        {% raw %}{{ roadSyntaxSwitchStatsText }}{% endraw %}
                                    </div>
                                    <div v-if="roadSyntaxStatus"
                                        class="status-text"
                                        style="margin-top:10px; display:flex; align-items:center; gap:8px; justify-content:flex-start;">
                                        <span>{% raw %}{{ roadSyntaxStatus }}{% endraw %}</span>
                                        <button type="button"
                                            style="border:1px solid #d9dee7; background:#fff; color:#4b5563; border-radius:999px; padding:2px 8px; font-size:11px; cursor:pointer;"
                                            @click="copyRoadSyntaxStatus">
                                            复制状态
                                        </button>
                                        <span style="font-size:11px; color:#6b7280;">{% raw %}{{ roadSyntaxStatusCopyHint }}{% endraw %}</span>
                                    </div>
                                </div>

                                <div class="panel" v-show="activeStep3Panel === 'aoi'">
                                    <h4>AOI 面数据分析</h4>
                                    <div class="panel-placeholder" style="margin-top:10px;">AOI 面数据分析（待开发）</div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div> <!-- End Wizard View Wrapper -->

            </div> <!-- End of sidebar-content -->

            <!-- Fixed History Footer -->
            <!-- Sidebar Footer (Only in Wizard Mode) -->
            <div v-if="sidebarView === 'wizard'" class="sidebar-footer"
                style="padding: 20px; border-top: 1px solid #f0f0f0; background: #fff; display: flex; flex-direction: column; gap: 10px;">
                <button class="btn-outline"
                    style="margin-top:0; border:1px solid #eee; display:flex; justify-content:center; align-items:center;"
                    @click="openHistoryView()">
                    <img src="/static/images/history.svg" class="icon-svg-small" style="margin-right:8px;"> 查看历史记录 ({%
                    raw %}{{
                    historyList.length }}{% endraw %})
                </button>
            </div>
        </aside>

        <!-- Middle: Map -->
        <main class="main-content">
            <div v-if="sidebarView === 'wizard' && step === 3" class="h3-map-toolbar">
                <button type="button" class="h3-map-tool-btn h3-map-save-btn" @click="saveAndRestart" title="保存并开启新分析">
                    <svg class="h3-map-tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M4 5.5A1.5 1.5 0 0 1 5.5 4h10.2l4.3 4.3V18.5A1.5 1.5 0 0 1 18.5 20h-13A1.5 1.5 0 0 1 4 18.5z"></path>
                        <path d="M8 4.5v5h7v-5"></path>
                        <path d="M8 20v-5h8v5"></path>
                    </svg>
                    <span class="h3-map-tool-text">保存并新建</span>
                </button>

                <button type="button" class="h3-map-tool-btn h3-map-simplify-btn"
                    :class="{ active: h3BasemapMuted }"
                    @click="toggleH3BasemapMuted"
                    title="底图简化">
                    <svg class="h3-map-tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M4 7h16"></path>
                        <path d="M4 12h16"></path>
                        <path d="M4 17h16"></path>
                    </svg>
                    <span class="h3-map-tool-text">{% raw %}{{ h3BasemapMuted ? '简化：开' : '简化：关' }}{% endraw %}</span>
                </button>

                <div class="h3-export-wrap">
                    <button type="button" class="h3-map-tool-btn h3-map-export-btn"
                        :class="{ active: h3ExportMenuOpen }"
                        :disabled="activeStep3Panel !== 'h3'"
                        @click="toggleH3ExportMenu"
                        title="导出">
                        <svg class="h3-map-tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M12 4v10"></path>
                            <path d="M8.5 10.5 12 14l3.5-3.5"></path>
                            <path d="M5 18h14"></path>
                        </svg>
                        <span class="h3-map-tool-text">导出</span>
                        <svg class="h3-map-tool-caret" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="m6 9 6 6 6-6"></path>
                        </svg>
                    </button>
                    <div v-if="activeStep3Panel === 'h3' && h3ExportMenuOpen" class="h3-export-menu">
                        <label class="h3-export-check">
                            <input type="checkbox" v-model="h3ExportIncludePoi">
                            包含POI点
                        </label>
                        <div class="h3-export-field">
                            <span class="h3-export-field-label">导出范围</span>
                            <select class="h3-export-select" v-model="h3ExportScope">
                                <option value="grid_only">仅网格</option>
                                <option value="analysis_result" :disabled="!hasH3AnalysisForExport()">分析结果</option>
                            </select>
                        </div>
                        <div v-if="h3ExportScope === 'analysis_result' && !hasH3AnalysisForExport()" class="h3-export-tip">
                            请先完成计算分析，再导出分析结果。
                        </div>
                        <button type="button" class="h3-export-item"
                            :disabled="isExportingH3 || !hasH3GridForExport()"
                            @click="exportH3Analysis('gpkg')">
                            快速导出（.gpkg）
                        </button>
                        <button type="button" class="h3-export-item"
                            :disabled="isExportingH3 || !hasH3GridForExport()"
                            @click="exportH3Analysis('arcgis_package')">
                            高级导出（LPK+MPK）
                        </button>
                    </div>
                </div>

                <div class="h3-task-wrap">
                    <button type="button" class="h3-map-tool-btn h3-map-task-btn"
                        :class="{ active: h3ExportTasksOpen }"
                        :disabled="activeStep3Panel !== 'h3'"
                        @click="toggleH3ExportTasks"
                        title="任务">
                        <svg class="h3-map-tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                            <rect x="4" y="5" width="16" height="14" rx="2"></rect>
                            <path d="M8 10h8"></path>
                            <path d="M8 14h6"></path>
                        </svg>
                        <span class="h3-map-tool-text">任务</span>
                        <span v-if="getH3PendingTaskCount() > 0" class="h3-task-count">{% raw %}{{ getH3PendingTaskCount() }}{% endraw %}</span>
                    </button>
                </div>
            </div>

            <div v-if="sidebarView === 'wizard' && step === 3 && activeStep3Panel === 'h3' && h3ExportTasksOpen" class="h3-export-task-panel">
                <div class="h3-export-task-panel-header">
                    <span>导出任务</span>
                    <button type="button" class="h3-export-task-close" @click="closeH3ExportTasks">关闭</button>
                </div>
                <div v-if="!h3ExportTasks.length" class="h3-export-task-empty">暂无任务</div>
                <template v-else>
                    <div v-for="task in h3ExportTasks" :key="task.id" class="h3-export-task-item">
                        <div class="h3-export-task-row">
                            <div class="h3-export-task-name">{% raw %}{{ task.title }}{% endraw %}</div>
                            <span class="h3-export-task-state"
                                :class="{
                                    'is-running': task.status === 'running',
                                    'is-success': task.status === 'success',
                                    'is-failed': task.status === 'failed'
                                }">
                                {% raw %}{{ task.status_label }}{% endraw %}
                            </span>
                        </div>
                        <div class="h3-export-task-meta">
                            {% raw %}{{ task.scope_label }} · {{ task.created_at_text }}{% endraw %}
                        </div>
                        <div v-if="task.filename" class="h3-export-task-meta">
                            文件：{% raw %}{{ task.filename }}{% endraw %}
                        </div>
                        <div v-if="task.error" class="h3-export-task-error">{% raw %}{{ task.error }}{% endraw %}</div>
                    </div>
                    <div class="h3-export-task-actions">
                        <button type="button" class="h3-export-task-clear" @click="clearH3CompletedTasks">清理已完成</button>
                    </div>
                </template>
            </div>

            <div v-if="sidebarView === 'wizard' && step === 3 && h3Toast.message"
                class="h3-export-toast"
                :class="{
                    'is-success': h3Toast.type === 'success',
                    'is-error': h3Toast.type === 'error',
                    'is-warning': h3Toast.type === 'warning'
                }">
                {% raw %}{{ h3Toast.message }}{% endraw %}
            </div>

            <button
                v-if="sidebarView === 'wizard'"
                type="button"
                class="map-recenter-btn"
                title="回到中心"
                aria-label="回到中心"
                :disabled="!mapCore || !mapCore.map"
                @click="goMapBackToCenter">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <circle cx="12" cy="12" r="3.2"></circle>
                    <path d="M12 2.8v3.4"></path>
                    <path d="M12 17.8v3.4"></path>
                    <path d="M2.8 12h3.4"></path>
                    <path d="M17.8 12h3.4"></path>
                </svg>
            </button>

            <div id="tianditu-container" aria-hidden="true"></div>
            <div id="container"></div>
            <div v-if="basemapSource === 'osm'" style="position:absolute; right:8px; bottom:6px; z-index:2; background:rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius:6px; padding:2px 6px; font-size:10px; color:#4b5563;">
                © OpenStreetMap contributors
            </div>
            <div v-else-if="basemapSource === 'tianditu'" style="position:absolute; right:8px; bottom:6px; z-index:2; background:rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius:6px; padding:2px 6px; font-size:10px; color:#4b5563;">
                © 天地图
            </div>
        </main>
    </div>

    <!-- 依赖库 -->
    <!-- 引入 Vue 3 (CDN) -->
    <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="/static/js/map-utils.js?v={{ static_version }}"></script>
    <script src="/static/js/map-core.js?v={{ static_version }}"></script>
    <script src="/static/js/map-markers.js?v={{ static_version }}"></script>
    <script src="/static/js/map-filters.js?v={{ static_version }}"></script>
    <script src="/static/js/analysis/map/map-write-queue.js?v={{ static_version }}"></script>
    <script src="/static/js/analysis/map/overlay-committer.js?v={{ static_version }}"></script>
    <script src="/static/js/analysis/features/road-syntax/state.js?v={{ static_version }}"></script>
    <script src="/static/js/analysis/features/road-syntax/controller-core.js?v={{ static_version }}"></script>
    <script src="/static/js/analysis/features/road-syntax/webgl.js?v={{ static_version }}"></script>
    <script src="/static/js/road_syntax_ui.js?v={{ static_version }}"></script>
    <!-- 引入 analysis.js 也可以，但我们大部分逻辑移入 Vue methods 更好，这里依然引入以兼容 MapCore 依赖 -->

    <script>

        const { createApp } = Vue;
        const INJECTED_TYPE_MAP_CONFIG = {{ map_type_config_json | safe }} || { groups: [] };
        const ROAD_SYNTAX_CONST = Object.freeze({
            SWITCH_TARGET_MS: 120,
            PREBUILD_DEADLINE_MS: 120000,
            CONNECTIVITY_NODE_MIN_ZOOM: 15,
            SWITCH_SAMPLE_LIMIT: 40,
            BUILD_BUDGET_MS: Object.freeze({
                interacting: 0.8,
                init: 6.0,
                steady: 4.0,
                lineFallbackSmall: 12.0,
                lineFallbackLarge: 8.0,
                node: 6.5,
            }),
        });
        const roadSyntaxUiMethods = (window.createRoadSyntaxUiMethods && typeof window.createRoadSyntaxUiMethods === 'function')
            ? window.createRoadSyntaxUiMethods(ROAD_SYNTAX_CONST)
            : {};
        const roadSyntaxOverlayCommitMethods = (window.createRoadSyntaxOverlayCommitMethods && typeof window.createRoadSyntaxOverlayCommitMethods === 'function')
            ? window.createRoadSyntaxOverlayCommitMethods(ROAD_SYNTAX_CONST)
            : {};
        const roadSyntaxControllerCoreMethods = (window.createRoadSyntaxControllerCoreMethods && typeof window.createRoadSyntaxControllerCoreMethods === 'function')
            ? window.createRoadSyntaxControllerCoreMethods(ROAD_SYNTAX_CONST)
            : {};
        const roadSyntaxWebglMethods = (window.createRoadSyntaxWebGLMethods && typeof window.createRoadSyntaxWebGLMethods === 'function')
            ? window.createRoadSyntaxWebGLMethods(ROAD_SYNTAX_CONST)
            : {};
        const buildRoadSyntaxInitialState = (window.createRoadSyntaxInitialState && typeof window.createRoadSyntaxInitialState === 'function')
            ? () => window.createRoadSyntaxInitialState(ROAD_SYNTAX_CONST)
            : () => ({});
        const ROAD_SYNTAX_MODULE_REQUIREMENTS = Object.freeze({
            queue: !!(window.createMapWriteQueue && typeof window.createMapWriteQueue === 'function'),
            overlayCommit: !!(window.createRoadSyntaxOverlayCommitMethods && typeof window.createRoadSyntaxOverlayCommitMethods === 'function'),
            state: !!(window.createRoadSyntaxInitialState && typeof window.createRoadSyntaxInitialState === 'function'),
            controller: !!(window.createRoadSyntaxControllerCoreMethods && typeof window.createRoadSyntaxControllerCoreMethods === 'function'),
            ui: !!(window.createRoadSyntaxUiMethods && typeof window.createRoadSyntaxUiMethods === 'function'),
        });
        const ROAD_SYNTAX_MODULE_MISSING = Object.keys(ROAD_SYNTAX_MODULE_REQUIREMENTS).filter((key) => !ROAD_SYNTAX_MODULE_REQUIREMENTS[key]);
        const ROAD_SYNTAX_MODULES_READY = ROAD_SYNTAX_MODULE_MISSING.length === 0;
        if (!ROAD_SYNTAX_MODULES_READY) {
            console.error('[road-syntax] module wiring incomplete', {
                missing: ROAD_SYNTAX_MODULE_MISSING.slice(),
                static_version: "{{ static_version }}",
            });
        }

        createApp({
            data() {
                return {
                    loadingConfig: true,
                    config: null,

                    // State
                    step: 1, // Wizard Step
                    sidebarView: 'start', // 'start', 'wizard', 'history'
                    selectedPoint: null, // {lng, lat}
                    transportMode: 'walking',
                    timeHorizon: 15,
                    captureTarget: 'poi', // poi | aoi
                    isCalculating: false,
                    errorMessage: '',
                    basemapSource: 'amap',
                    tdtDiag: null,
                    tdtDiagCopyStatus: '',

                    // POI Data
                    poiKeywords: '', // Not used if using categories, but kept for custom
                    typeMapConfig: INJECTED_TYPE_MAP_CONFIG,
                    typeMapGroups: [],
                    typeCodeToCategoryId: {},
                    typePrefixToCategoryId: {},
                    typeCodeToTypeId: {},
                    typePrefixToTypeId: {},
                    typeIdToGroupId: {},
                    typeIdToLabel: {},
                    categoryById: {},
                    poiCategories: [],
                    poiSubSelectionState: {},
                    expandedPoiCategoryId: null,
                    step3NavItems: [
                        { id: 'poi', label: 'POI', title: 'POI 点数据分析' },
                        { id: 'h3', label: '网格', title: '网格分析' },
                        { id: 'syntax', label: '路网', title: '空间句法路网分析' },
                        { id: 'aoi', label: 'AOI', title: 'AOI 面数据分析' }
                    ],
                    activeStep3Panel: 'poi',
                    dragIndex: null,
                    dragOverIndex: null,
                    dragInsertPosition: null,
                    isDraggingNav: false,
                    isFetchingPois: false,
                    isFetchingAois: false,
                    fetchProgress: 0,
                    poiStatus: '',
                    aoiStatus: '',
                    roadSyntaxModulesReady: ROAD_SYNTAX_MODULES_READY,
                    roadSyntaxModuleMissing: ROAD_SYNTAX_MODULE_MISSING.slice(),
                    ...buildRoadSyntaxInitialState(),
                    fetchSubtypeHitMap: {},
                    fetchSubtypeProgress: {
                        categoryId: '',
                        categoryName: '',
                        typeNamesPreview: [],
                        typeNamesFullCount: 0,
                        hiddenTypeCount: 0,
                    },
                    lastIsochroneGeoJSON: null,
                    poiMarkers: [],
                    aoiMarkers: [],
                    allPoisDetails: [], // Store full fetched data for client-side filtering
                    allAoisDetails: [],
                    aoiH3Resolution: 9,
                    aoiRegeoRadius: 1000,
                    aoiMaxPoints: 300,
                    aoiSamplePoints: 0,
                    aoiTotalCalls: 0,
                    poiChart: null,
                    poiChartResizeHandler: null,

                    // Instances
                    placeSearch: null,
                    placeSearchErrorListener: null,
                    placeSearchLoadingPromise: null,
                    placeSearchBuildToken: 0,
                    amapRuntimeErrorListener: null,
                    amapRuntimeRejectionListener: null,

                    // History
                    historyListRaw: [],
                    historyList: [],
                    historyLoading: false,
                    historyLoadedCount: 0,
                    historySkeletonCount: 5,
                    historyHasLoadedOnce: false,
                    historyRenderSessionId: 0,
                    historyRenderRafId: null,
                    historyFetchAbortController: null,
                    isSelectionMode: false,
                    selectedHistoryIds: [],

                    // Control
                    abortController: null,

                    // H3 Grid
                    isGeneratingGrid: false,
                    h3GridStatus: '',
                    h3GridCount: 0,
                    h3GridResolution: 10,
                    h3GridIncludeMode: 'intersects',
                    h3NeighborRing: 1,
                    h3GridMinOverlapRatio: 0.15,
                    h3ParamsSubTab: 'grid',
                    h3ArcgisPythonPath: 'C:\\Python27\\ArcGIS10.7\\python.exe',
                    h3ArcgisImageVersion: 0,
                    h3ArcgisSnapshotLoadError: false,
                    isGeneratingH3ArcgisSnapshot: false,
                    pointSimplifyEnabled: false,
                    h3BasemapMuted: false,
                    pointLayersSuspendedForSyntax: false,
                    poiSystemSuspendedForSyntax: false,
                    poiAutoFitViewEnabled: false,
                    poiMapWriteGeneration: 0,
                    poiManagerSerial: 0,
                    poiActiveManagerId: 0,
                    h3GridFeatures: [],
                    selectedH3Id: null,
                    isComputingH3Analysis: false,
                    h3AnalysisSummary: null,
                    h3AnalysisCharts: null,
                    h3AnalysisGridFeatures: [],
                    h3MainStage: 'params',
                    h3MainStageLabels: {
                        params: '参数',
                        analysis: '分析',
                        diagnosis: '诊断',
                        evaluate: '评估',
                    },
                    h3MainStageTabs: {
                        params: [],
                        analysis: ['metric_map', 'structure_map'],
                        diagnosis: ['typing', 'lq'],
                        evaluate: ['gap'],
                    },
                    h3SubTabLabels: {
                        metric_map: '密度场',
                        structure_map: '结构图',
                        typing: '功能混合度',
                        lq: '区位商优势（LQ）',
                        gap: '缺口优先区',
                    },
                    h3MetricView: 'density',
                    h3StructureFillMode: 'gi_z',
                    h3Legend: null,
                    h3StructureRenderStats: null,
                    h3EntropyMinPoi: 3,
                    h3SubTab: 'metric_map',
                    h3TargetCategory: '',
                    h3DecisionTopN: 10,
                    h3OnlySignificant: false,
                    h3LqSmoothingAlpha: 0.5,
                    h3CategoryMeta: [],
                    h3GapWeights: { transport: 0.4, life: 0.25, education: 0.2, medical: 0.15 },
                    h3DerivedStats: {
                        structureSummary: null,
                        typingSummary: null,
                        lqSummary: null,
                        gapSummary: null,
                        topCells: {},
                    },
                    h3CategoryChart: null,
                    h3DensityChart: null,
                    h3LqChart: null,
                    h3GapChart: null,
                    h3StructureChart: null,
                    h3ChartsResizeHandler: null,
                    h3ExportMenuOpen: false,
                    h3ExportTasksOpen: false,
                    h3ExportIncludePoi: true,
                    h3ExportScope: 'grid_only',
                    h3PoiFilterCategoryIds: [],
                    isExportingH3: false,
                    h3ExportTasks: [],
                    h3ExportTaskSeq: 0,
                    h3Toast: { message: '', type: 'info' },
                    h3ToastTimer: null,

                }
            },
            async mounted() {
                try {
                    // 1. Initialize config from server-injected variables directly to save an RTT
                    this.config = {
                        amap_js_api_key: "{{ amap_js_api_key }}",
                        amap_js_security_code: "{{ amap_js_security_code }}",
                        tianditu_key: "{{ tianditu_key }}"
                    };
                    this.initializePoiCategoriesFromTypeMap();
                    if (this.basemapSource === 'tianditu') {
                        const tileReady = await this.validateTiandituSource();
                        if (!tileReady) {
                            this.tdtDiagCopyStatus = '';
                        }
                    }

                    // 2. AMap load with timeout to avoid long blocking
                    const amapTimeoutMs = 8000;
                    await Promise.race([
                        this.loadAMapScript(this.config.amap_js_api_key, this.config.amap_js_security_code),
                        new Promise((_, reject) => setTimeout(() => reject(new Error("AMap 加载超时，请检查网络或 Key")), amapTimeoutMs))
                    ]);

                    // 3. Initialize Map after script is ready
                    this.initMap();
                } catch (e) {
                    console.error("Initialization Failed:", e);
                    this.errorMessage = "系统初始化失败: " + e.message;
                } finally {
                    // Preload history in background so opening history panel reads from cache.
                    this.preloadHistoryListInBackground();
                    if (!this.roadSyntaxModulesReady) {
                        this.roadSyntaxSetStatus(`路网模块未完整加载：${(this.roadSyntaxModuleMissing || []).join(', ')}`);
                    }
                    this.attachAmapRuntimeErrorProbe();
                    document.addEventListener('click', this.handleGlobalClick, true);
                    this.loadingConfig = false;
                    const overlay = document.getElementById('loading-overlay');
                    if (overlay) overlay.style.display = 'none';
                }
            },
            beforeUnmount() {
                document.removeEventListener('click', this.handleGlobalClick, true);
                this.detachAmapRuntimeErrorProbe();
                this.destroyPlaceSearch();
                this.clearPoiOverlayLayers({
                    reason: 'before_unmount',
                    clearManager: true,
                    clearSimpleMarkers: true,
                    clearCenterMarker: true,
                    resetFilterPanel: true,
                    immediate: true
                });
                this.roadSyntaxDetachMapListeners();
                this.invalidateRoadSyntaxCache('unmount', { resetData: true });
                if (this.h3ToastTimer) {
                    clearTimeout(this.h3ToastTimer);
                    this.h3ToastTimer = null;
                }
                this.cancelHistoryLoading();
                this.disposePoiChart();
                this.disposeH3Charts();
            },
            watch: {
                step(newStep, oldStep) {
                    if (oldStep === 1 && newStep !== 1) {
                        this.destroyPlaceSearch();
                    }
                },
                sidebarView(newView, oldView) {
                    if (oldView === 'history' && newView !== 'history') {
                        this.cancelHistoryLoading();
                    }
                },
                activeStep3Panel(newPanel, oldPanel) {
                    if (newPanel === oldPanel) return;
                    if (newPanel === 'syntax') {
                        this.suspendPoiSystemForSyntax();
                    } else if (oldPanel === 'syntax') {
                        this.resumePoiSystemAfterSyntax();
                    }
                    if (oldPanel === 'h3' && newPanel !== 'h3') {
                        this.clearH3GridDisplayOnLeave();
                    }
                    if (newPanel === 'h3') {
                        this.restoreH3GridDisplayOnEnter();
                    }
                },
                transportMode(newMode, oldMode) {
                    if (!oldMode || newMode === oldMode) return;
                    if (this.roadSyntaxMode === oldMode || !this.roadSyntaxSummary) {
                        this.roadSyntaxMode = newMode || 'walking';
                    }
                    const hasCache = this.roadSyntaxHasCache();
                    if (this.roadSyntaxSummary || hasCache) {
                        this.resetRoadSyntaxState();
                        this.roadSyntaxStatus = '交通方式已切换，请重新计算路网指标';
                    }
                },
                roadSyntaxMode(newMode, oldMode) {
                    if (!oldMode || newMode === oldMode) return;
                    const hasCache = this.roadSyntaxHasCache();
                    if (this.roadSyntaxSummary || hasCache) {
                        this.resetRoadSyntaxState();
                        this.roadSyntaxStatus = '路网交通模式已变更，请重新计算路网指标';
                    }
                },
            },
            methods: {
                ...roadSyntaxOverlayCommitMethods,
                ...roadSyntaxControllerCoreMethods,
                ...roadSyntaxWebglMethods,
                ...roadSyntaxUiMethods,
                attachAmapRuntimeErrorProbe() {
                    if (this.amapRuntimeErrorListener || this.amapRuntimeRejectionListener) return;
                    const buildPayload = (base = {}) => {
                        const manager = this.markerManager;
                        const clustererCount = manager && manager.typeClusterers && typeof manager.typeClusterers === 'object'
                            ? Object.keys(manager.typeClusterers).length
                            : 0;
                        const markerCount = manager && Array.isArray(manager.markers) ? manager.markers.length : 0;
                        return Object.assign({
                            step: Number(this.step || 0),
                            panel: String(this.activeStep3Panel || ''),
                            poi_suspended_for_syntax: !!this.poiSystemSuspendedForSyntax,
                            marker_manager_alive: !!manager,
                            marker_count: markerCount,
                            clusterer_count: clustererCount,
                            road_active_layer: String(this.roadSyntaxActiveLayerKey || ''),
                            road_switch_in_progress: !!this.roadSyntaxSwitchInProgress,
                            road_pool_ready: !!this.roadSyntaxPoolReady,
                            road_map_write_queue_pending: Number(this.roadSyntaxMapWriteQueuePending || 0),
                        }, base || {});
                    };
                    const matchRuntimeMessage = (message = '', filename = '') => {
                        const msg = String(message || '');
                        const file = String(filename || '');
                        return (
                            file.indexOf('maps?v=') >= 0
                            || msg.indexOf('split') >= 0
                            || msg.indexOf('Ud') >= 0
                            || msg.indexOf('Pixel(NaN') >= 0
                        );
                    };
                    this.amapRuntimeErrorListener = (event) => {
                        const message = event && event.message ? String(event.message) : '';
                        const filename = event && event.filename ? String(event.filename) : '';
                        if (!matchRuntimeMessage(message, filename)) return;
                        console.error('[diag] amap runtime error', buildPayload({
                            message,
                            filename,
                            lineno: Number((event && event.lineno) || 0),
                            colno: Number((event && event.colno) || 0),
                        }));
                    };
                    this.amapRuntimeRejectionListener = (event) => {
                        const reason = event ? (event.reason || '') : '';
                        const text = reason && reason.message ? String(reason.message) : String(reason || '');
                        if (!matchRuntimeMessage(text, '')) return;
                        console.error('[diag] amap runtime rejection', buildPayload({
                            reason: text,
                        }));
                    };
                    window.addEventListener('error', this.amapRuntimeErrorListener);
                    window.addEventListener('unhandledrejection', this.amapRuntimeRejectionListener);
                },
                detachAmapRuntimeErrorProbe() {
                    if (this.amapRuntimeErrorListener) {
                        window.removeEventListener('error', this.amapRuntimeErrorListener);
                    }
                    if (this.amapRuntimeRejectionListener) {
                        window.removeEventListener('unhandledrejection', this.amapRuntimeRejectionListener);
                    }
                    this.amapRuntimeErrorListener = null;
                    this.amapRuntimeRejectionListener = null;
                },
                cancelHistoryLoading() {
                    if (this.historyFetchAbortController) {
                        try {
                            this.historyFetchAbortController.abort();
                        } catch (e) {
                            console.warn('history abort failed', e);
                        }
                        this.historyFetchAbortController = null;
                    }
                    if (this.historyRenderRafId !== null) {
                        window.cancelAnimationFrame(this.historyRenderRafId);
                        this.historyRenderRafId = null;
                    }
                    this.historyRenderSessionId += 1;
                },
                normalizeHistoryRecord(item) {
                    const record = Object.assign({}, item || {});
                    const rawDate = record.created_at;
                    let dateText = String(rawDate || '');
                    if (rawDate) {
                        const d = new Date(rawDate);
                        if (!Number.isNaN(d.getTime())) {
                            dateText = d.toLocaleDateString();
                        }
                    }
                    record._createdDateText = dateText;
                    return record;
                },
                progressiveRenderHistory(sessionId) {
                    if (sessionId !== this.historyRenderSessionId) return;
                    if (!Array.isArray(this.historyListRaw)) {
                        this.historyLoading = false;
                        this.historyRenderRafId = null;
                        return;
                    }
                    if (this.historyLoadedCount >= this.historyListRaw.length) {
                        this.historyLoading = false;
                        this.historyRenderRafId = null;
                        return;
                    }

                    const nextItem = this.historyListRaw[this.historyLoadedCount];
                    this.historyList.push(nextItem);
                    this.historyLoadedCount += 1;

                    this.historyRenderRafId = window.requestAnimationFrame(() => {
                        this.progressiveRenderHistory(sessionId);
                    });
                },
                preloadHistoryListInBackground() {
                    if (this.historyHasLoadedOnce || this.historyLoading) {
                        return;
                    }
                    this.loadHistoryList({ force: true, keepExisting: false, background: true }).catch((err) => {
                        console.warn('History background preload failed', err);
                    });
                },
                openHistoryView() {
                    this.sidebarView = 'history';
                    this.loadHistoryList({ force: false, keepExisting: true, background: false }).catch((err) => {
                        console.warn('History load failed', err);
                    });
                },
                refreshHistoryList() {
                    this.loadHistoryList({ force: true, keepExisting: true }).catch((err) => {
                        console.warn('History refresh failed', err);
                    });
                },
                normalizeTypeCode(value) {
                    const digits = String(value || '').replace(/\D/g, '');
                    return digits.length >= 6 ? digits.slice(0, 6) : digits;
                },
                _normalizeCategoryTitle(value) {
                    return String(value || '').replace(/\s+/g, '').trim();
                },
                _buildDefaultH3CategoryMeta() {
                    const fromTypeMap = (this.typeMapGroups || []).map((group) => ({
                        key: String(group.id || ''),
                        label: String(group.title || group.id || ''),
                    })).filter(item => item.key && item.label);
                    if (fromTypeMap.length) return fromTypeMap;
                    return [
                        { key: 'group-7', label: '餐饮' },
                        { key: 'group-6', label: '购物' },
                        { key: 'group-4', label: '商务住宅' },
                        { key: 'group-3', label: '交通' },
                        { key: 'group-2', label: '旅游' },
                        { key: 'group-13', label: '科教文化' },
                        { key: 'group-10', label: '医疗' },
                    ];
                },
                _resolveDefaultH3TargetCategory() {
                    const categories = Array.isArray(this.h3CategoryMeta) ? this.h3CategoryMeta : [];
                    if (!categories.length) return '';
                    const dining = categories.find(item => this._normalizeCategoryTitle(item.label) === '餐饮');
                    if (dining && dining.key) return dining.key;
                    return String((categories[0] && categories[0].key) || '');
                },
                _ensureH3CategoryState() {
                    if (!Array.isArray(this.h3CategoryMeta) || !this.h3CategoryMeta.length) {
                        this.h3CategoryMeta = this._buildDefaultH3CategoryMeta();
                    }
                    const hasCurrentTarget = (this.h3CategoryMeta || []).some(item => String(item.key) === String(this.h3TargetCategory));
                    if (!hasCurrentTarget) {
                        this.h3TargetCategory = this._resolveDefaultH3TargetCategory();
                    }
                },
                _resolveGapDemandCategoryMap() {
                    const aliases = {
                        transport: '交通',
                        life: '商务住宅',
                        education: '科教文化',
                        medical: '医疗',
                    };
                    const labelToKey = {};
                    (this.h3CategoryMeta || []).forEach((item) => {
                        const normalized = this._normalizeCategoryTitle(item.label);
                        if (!normalized || !item.key || labelToKey[normalized]) return;
                        labelToKey[normalized] = String(item.key);
                    });
                    const mapping = {};
                    const missingTitles = [];
                    Object.entries(aliases).forEach(([weightKey, title]) => {
                        const normalized = this._normalizeCategoryTitle(title);
                        const key = labelToKey[normalized];
                        if (key) {
                            mapping[weightKey] = key;
                        } else {
                            missingTitles.push(title);
                        }
                    });
                    return { mapping, missingTitles };
                },
                initializePoiCategoriesFromTypeMap() {
                    const raw = (this.typeMapConfig && Array.isArray(this.typeMapConfig.groups))
                        ? this.typeMapConfig
                        : { groups: [] };
                    this.typeCodeToCategoryId = {};
                    this.typePrefixToCategoryId = {};
                    this.typeCodeToTypeId = {};
                    this.typePrefixToTypeId = {};
                    this.typeIdToGroupId = {};
                    this.typeIdToLabel = {};
                    const groups = (raw.groups || []).map((group, gi) => {
                        const itemList = Array.isArray(group.items) ? group.items : [];
                        const mergedCodes = [];
                        const seenCodes = new Set();
                        let cardColor = '#888';
                        itemList.forEach((item) => {
                            if (!item || !item.id) return;
                            if (item.color && cardColor === '#888') {
                                cardColor = item.color;
                            }
                            String(item.types || '').split('|').forEach((rawCode) => {
                                const code = this.normalizeTypeCode(rawCode);
                                if (!code || seenCodes.has(code)) return;
                                seenCodes.add(code);
                                mergedCodes.push(code);
                                this.typeCodeToCategoryId[code] = String(group.id || '');
                                this.typeCodeToTypeId[code] = String(item.id || '');
                                if (code.length >= 2 && !this.typePrefixToCategoryId[code.slice(0, 2)]) {
                                    this.typePrefixToCategoryId[code.slice(0, 2)] = String(group.id || '');
                                }
                                if (code.length >= 2 && !this.typePrefixToTypeId[code.slice(0, 2)]) {
                                    this.typePrefixToTypeId[code.slice(0, 2)] = String(item.id || '');
                                }
                            });
                            this.typeIdToGroupId[String(item.id || '')] = String(group.id || '');
                            this.typeIdToLabel[String(item.id || '')] = String(item.label || item.id || '');
                        });

                        return {
                            id: String(group.id || `group-${gi}`),
                            name: String(group.title || group.id || `分类${gi + 1}`),
                            checked: true,
                            color: cardColor,
                            types: mergedCodes.join('|'),
                        };
                    }).filter(g => g.id && g.types);

                    this.typeMapGroups = (raw.groups || []).map((group) => ({
                        ...group,
                        id: String(group.id || ''),
                        title: String(group.title || group.id || ''),
                        items: Array.isArray(group.items) ? group.items.map((item) => ({
                            ...item,
                            id: String(item.id || ''),
                            label: String(item.label || item.id || ''),
                        })) : []
                    })).filter(g => g.id);
                    this.h3CategoryMeta = this._buildDefaultH3CategoryMeta();
                    this.h3TargetCategory = this._resolveDefaultH3TargetCategory();

                    this.poiCategories = groups;
                    if (!this.poiCategories.length) {
                        this.poiCategories = [
                            { id: 'dining', name: '餐饮', checked: true, color: '#f44336', types: '050000' },
                            { id: 'shopping', name: '购物', checked: true, color: '#2196f3', types: '060000' },
                            { id: 'life', name: '生活', checked: true, color: '#ff9800', types: '070000' },
                            { id: 'transport', name: '交通', checked: true, color: '#4caf50', types: '150000' },
                            { id: 'scenic', name: '风景', checked: true, color: '#9c27b0', types: '110000' },
                            { id: 'education', name: '科教', checked: true, color: '#00bcd4', types: '140000' },
                            { id: 'medical', name: '医疗', checked: true, color: '#e91e63', types: '090000' },
                        ];
                        this.poiCategories.forEach((cat) => {
                            this.typeCodeToCategoryId[String(cat.types)] = cat.id;
                            this.typePrefixToCategoryId[String(cat.types).slice(0, 2)] = cat.id;
                            this.typeCodeToTypeId[String(cat.types)] = cat.id;
                            this.typePrefixToTypeId[String(cat.types).slice(0, 2)] = cat.id;
                            this.typeIdToGroupId[cat.id] = cat.id;
                            this.typeIdToLabel[cat.id] = cat.name;
                        });
                    }
                    this.categoryById = {};
                    this.poiCategories.forEach((cat) => {
                        this.categoryById[cat.id] = cat;
                    });
                    this.syncH3PoiFilterSelection(true);
                    this.poiSubSelectionState = {};
                    this.typeMapGroups.forEach((group) => {
                        (group.items || []).forEach((item) => {
                            this.poiSubSelectionState[item.id] = true;
                        });
                    });
                    this.poiCategories.forEach((cat) => this.syncPoiCategorySelection(cat));
                    this.expandedPoiCategoryId = null;
                    this.resetFetchSubtypeProgress();
                },
                resetFetchSubtypeProgress() {
                    this.fetchSubtypeHitMap = {};
                    this.fetchSubtypeProgress = {
                        categoryId: '',
                        categoryName: '',
                        typeNamesPreview: [],
                        typeNamesFullCount: 0,
                        hiddenTypeCount: 0,
                    };
                },
                getPoiTypeLabel(typeId) {
                    const key = String(typeId || '');
                    if (!key) return '';
                    return this.typeIdToLabel[key] || key;
                },
                updateFetchSubtypeProgressDisplay(cat) {
                    const categoryId = String((cat && cat.id) || '');
                    if (!categoryId) return;
                    const typeIds = Object.keys(this.fetchSubtypeHitMap[categoryId] || {});
                    const typeNames = typeIds.map((typeId) => this.getPoiTypeLabel(typeId)).filter(Boolean);
                    const previewLimit = 6;
                    this.fetchSubtypeProgress = {
                        categoryId: categoryId,
                        categoryName: String((cat && cat.name) || categoryId),
                        typeNamesPreview: typeNames.slice(0, previewLimit),
                        typeNamesFullCount: typeNames.length,
                        hiddenTypeCount: Math.max(0, typeNames.length - previewLimit),
                    };
                },
                accumulateFetchSubtypeHits(cat, poiList) {
                    const categoryId = String((cat && cat.id) || '');
                    if (!categoryId) return;
                    if (!this.fetchSubtypeHitMap[categoryId]) {
                        this.fetchSubtypeHitMap[categoryId] = {};
                    }
                    const bucket = this.fetchSubtypeHitMap[categoryId];
                    (poiList || []).forEach((poi) => {
                        const typeId = this.resolvePoiTypeId(poi && poi.type);
                        if (!typeId) return;
                        bucket[String(typeId)] = true;
                    });
                    this.updateFetchSubtypeProgressDisplay(cat);
                },
                getPoiSubItems(categoryId) {
                    const group = (this.typeMapGroups || []).find(g => String(g.id) === String(categoryId));
                    return group && Array.isArray(group.items) ? group.items : [];
                },
                isPoiSubItemChecked(itemId) {
                    return !!this.poiSubSelectionState[itemId];
                },
                getPoiSubSelectedCount(categoryId) {
                    const items = this.getPoiSubItems(categoryId);
                    if (!items.length) return 0;
                    return items.filter(item => !!this.poiSubSelectionState[item.id]).length;
                },
                togglePoiCategoryExpand(categoryId) {
                    this.expandedPoiCategoryId = this.expandedPoiCategoryId === categoryId ? null : categoryId;
                },
                syncPoiCategorySelection(cat) {
                    const items = this.getPoiSubItems(cat.id);
                    if (!items.length) return;
                    const selectedItems = items.filter(item => !!this.poiSubSelectionState[item.id]);
                    cat.checked = selectedItems.length > 0;
                    const seen = new Set();
                    const merged = [];
                    selectedItems.forEach((item) => {
                        String(item.types || '').split('|').forEach((rawCode) => {
                            const code = this.normalizeTypeCode(rawCode);
                            if (!code || seen.has(code)) return;
                            seen.add(code);
                            merged.push(code);
                        });
                    });
                    cat.types = merged.join('|');
                },
                togglePoiCategory(cat, checked) {
                    const items = this.getPoiSubItems(cat.id);
                    if (!items.length) {
                        cat.checked = !!checked;
                        return;
                    }
                    items.forEach((item) => {
                        this.poiSubSelectionState[item.id] = !!checked;
                    });
                    this.syncPoiCategorySelection(cat);
                },
                onPoiSubItemToggle(cat, item, checked) {
                    this.poiSubSelectionState[item.id] = !!checked;
                    this.syncPoiCategorySelection(cat);
                },
                buildSelectedCategoryBuckets() {
                    const buckets = [];
                    (this.poiCategories || []).forEach((cat) => {
                        this.syncPoiCategorySelection(cat);
                        if (!cat.checked || !cat.types) return;
                        buckets.push({
                            id: cat.id,
                            name: cat.name,
                            types: String(cat.types || ''),
                        });
                    });
                    return buckets;
                },
                syncH3PoiFilterSelection(forceAll = false) {
                    const ids = (this.poiCategories || [])
                        .map((cat) => String((cat && cat.id) || ''))
                        .filter(Boolean);
                    if (!ids.length) {
                        this.h3PoiFilterCategoryIds = [];
                        return;
                    }
                    if (forceAll || !Array.isArray(this.h3PoiFilterCategoryIds) || this.h3PoiFilterCategoryIds.length === 0) {
                        this.h3PoiFilterCategoryIds = ids.slice();
                        return;
                    }
                    const currentSet = new Set(
                        this.h3PoiFilterCategoryIds
                            .map((id) => String(id || ''))
                            .filter(Boolean)
                    );
                    const kept = ids.filter((id) => currentSet.has(id));
                    this.h3PoiFilterCategoryIds = kept.length ? kept : ids.slice();
                },
                selectAllH3PoiFilters() {
                    this.syncH3PoiFilterSelection(true);
                },
                clearH3PoiFilters() {
                    this.h3PoiFilterCategoryIds = [];
                },
                _getH3PoiFilterSet() {
                    return new Set(
                        (this.h3PoiFilterCategoryIds || [])
                            .map((id) => String(id || ''))
                            .filter(Boolean)
                    );
                },
                _buildH3AnalysisPois() {
                    const source = Array.isArray(this.allPoisDetails) ? this.allPoisDetails : [];
                    if (!source.length) return [];
                    const selectedCategoryIds = this._getH3PoiFilterSet();
                    if (!selectedCategoryIds.size) return [];
                    return source.filter((poi) => {
                        const categoryId = String(this.resolvePoiCategoryId(poi && poi.type) || '');
                        return categoryId && selectedCategoryIds.has(categoryId);
                    });
                },
                getH3FilteredPoiCount() {
                    return this._buildH3AnalysisPois().length;
                },
                resolvePoiCategoryId(typeText) {
                    const raw = String(typeText || '');
                    if (raw && this.typeIdToGroupId[raw]) {
                        return this.typeIdToGroupId[raw];
                    }
                    const code = this.normalizeTypeCode(typeText);
                    if (code && this.typeCodeToCategoryId[code]) {
                        return this.typeCodeToCategoryId[code];
                    }
                    if (code.length >= 2 && this.typePrefixToCategoryId[code.slice(0, 2)]) {
                        return this.typePrefixToCategoryId[code.slice(0, 2)];
                    }
                    return '';
                },
                resolvePoiTypeId(typeText) {
                    const raw = String(typeText || '');
                    if (raw && this.typeIdToGroupId[raw]) {
                        return raw;
                    }
                    const code = this.normalizeTypeCode(typeText);
                    if (code && this.typeCodeToTypeId[code]) {
                        return this.typeCodeToTypeId[code];
                    }
                    if (code.length >= 2 && this.typePrefixToTypeId[code.slice(0, 2)]) {
                        return this.typePrefixToTypeId[code.slice(0, 2)];
                    }
                    return '';
                },
                resolvePoiCategory(typeText) {
                    const id = this.resolvePoiCategoryId(typeText);
                    return id ? this.categoryById[id] : null;
                },
                saveAnalysisHistoryAsync(polygon, selectedCats, pois) {
                    if (!this.selectedPoint || !Array.isArray(pois) || pois.length === 0) return;
                    const typesLabel = (selectedCats || []).map(c => c.name).join(',');
                    const compactPois = pois.map((p) => ({
                        id: p && p.id ? String(p.id) : '',
                        name: p && p.name ? String(p.name) : '未命名',
                        location: Array.isArray(p && p.location) ? [p.location[0], p.location[1]] : null,
                        address: p && p.address ? String(p.address) : '',
                        type: p && p.type ? String(p.type) : '',
                        adname: p && p.adname ? String(p.adname) : '',
                        lines: Array.isArray(p && p.lines) ? p.lines : []
                    })).filter((p) => Array.isArray(p.location) && p.location.length === 2);
                    const payload = {
                        center: [this.selectedPoint.lng, this.selectedPoint.lat],
                        polygon: polygon,
                        pois: compactPois,
                        keywords: typesLabel,
                        location_name: this.selectedPoint.lng.toFixed(4) + "," + this.selectedPoint.lat.toFixed(4),
                        mode: this.transportMode,
                        time_min: parseInt(this.timeHorizon),
                    };
                    setTimeout(() => {
                        fetch('/api/v1/analysis/history/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        })
                            .then(async (res) => {
                                if (!res.ok) {
                                    let detail = '';
                                    try {
                                        detail = (await res.text()) || '';
                                    } catch (_) { }
                                    throw new Error(`HTTP ${res.status}${detail ? `: ${detail.slice(0, 200)}` : ''}`);
                                }
                                return res.json().catch(() => ({}));
                            })
                            .then(() => { })
                            .catch((err) => {
                                console.warn('Failed to save history', err);
                                this.poiStatus = `抓取完成，但历史保存失败：${err && err.message ? err.message : String(err)}`;
                            });
                    }, 0);
                },
                bumpPoiMapWriteGeneration(_reason = '') {
                    const next = Number(this.poiMapWriteGeneration || 0) + 1;
                    this.poiMapWriteGeneration = next;
                    return next;
                },
                enqueuePoiMapWrite(fn, options = {}) {
                    if (typeof fn !== 'function') {
                        return {
                            accepted: false,
                            queued: false,
                            replaced: false,
                            id: 0,
                            size: 0,
                            promise: Promise.resolve({ ok: false, skipped: true, reason: 'invalid_fn' })
                        };
                    }
                    const opts = (options && typeof options === 'object') ? Object.assign({}, options) : {};
                    const scopeRaw = (typeof opts.scope === 'string' && opts.scope.trim()) ? opts.scope.trim() : 'poi';
                    const scope = /^[a-z0-9_-]+$/i.test(scopeRaw) ? scopeRaw : 'poi';
                    const rawKey = (typeof opts.key === 'string' && opts.key) ? String(opts.key) : 'write';
                    opts.key = rawKey.includes(':') ? rawKey : `${scope}:${rawKey}`;
                    if (typeof opts.replaceExisting === 'undefined') {
                        opts.replaceExisting = true;
                    }
                    const usePoiGenerationGuard = scope === 'poi';
                    const writeGeneration = usePoiGenerationGuard
                        ? Number(this.poiMapWriteGeneration || 0)
                        : -1;
                    const userGuard = typeof opts.guard === 'function' ? opts.guard : null;
                    opts.guard = (meta = {}) => {
                        if (usePoiGenerationGuard && Number(this.poiMapWriteGeneration || 0) !== writeGeneration) {
                            return false;
                        }
                        if (!userGuard) return true;
                        try {
                            return !!userGuard(meta);
                        } catch (_) {
                            return false;
                        }
                    };
                    opts.meta = Object.assign({}, (opts.meta && typeof opts.meta === 'object') ? opts.meta : {});
                    if (usePoiGenerationGuard) {
                        opts.meta.poi_generation = writeGeneration;
                    }
                    if (typeof this.roadSyntaxEnqueueMapWrite === 'function') {
                        return this.roadSyntaxEnqueueMapWrite(fn, opts);
                    }
                    try {
                        if (usePoiGenerationGuard && typeof opts.guard === 'function' && !opts.guard(opts.meta || {})) {
                            return {
                                accepted: true,
                                queued: false,
                                replaced: false,
                                id: 0,
                                size: 0,
                                promise: Promise.resolve({
                                    ok: false,
                                    skipped: true,
                                    reason: 'poi_generation_stale'
                                })
                            };
                        }
                        const value = fn((opts && opts.meta) || {});
                        const payload = (value && typeof value === 'object' && Object.prototype.hasOwnProperty.call(value, 'ok'))
                            ? Object.assign({}, value)
                            : { ok: value !== false, value };
                        return {
                            accepted: true,
                            queued: false,
                            replaced: false,
                            id: 0,
                            size: 0,
                            promise: Promise.resolve(payload)
                        };
                    } catch (err) {
                        return {
                            accepted: true,
                            queued: false,
                            replaced: false,
                            id: 0,
                            size: 0,
                            promise: Promise.resolve({
                                ok: false,
                                reason: 'fallback_execute_error',
                                error: err && err.message ? err.message : String(err)
                            })
                        };
                    }
                },
                enqueueAoiMapWrite(fn, options = {}) {
                    const opts = (options && typeof options === 'object') ? Object.assign({}, options) : {};
                    opts.scope = 'aoi';
                    return this.enqueuePoiMapWrite(fn, opts);
                },
                safeMapSet(overlay, targetMap = null) {
                    if (!overlay || typeof overlay.setMap !== 'function') return false;
                    try {
                        overlay.setMap(targetMap || null);
                        return true;
                    } catch (_) {
                        try { overlay.setMap(null); } catch (__){ }
                        return false;
                    }
                },
                clearPoiOverlayLayers(options = {}) {
                    const opts = (options && typeof options === 'object') ? options : {};
                    const reason = (typeof opts.reason === 'string' && opts.reason) ? opts.reason : 'clear';
                    const generation = this.bumpPoiMapWriteGeneration(`clear:${reason}`);
                    const clearManager = opts.clearManager !== false;
                    const clearSimpleMarkers = opts.clearSimpleMarkers !== false;
                    const clearCenterMarker = !!opts.clearCenterMarker;
                    const resetFilterPanel = opts.resetFilterPanel !== false;
                    const immediate = Object.prototype.hasOwnProperty.call(opts, 'immediate') ? !!opts.immediate : true;
                    const manager = clearManager ? this.markerManager : null;
                    const managerMarkers = (manager && Array.isArray(manager.markers)) ? manager.markers.slice() : [];
                    const simpleMarkers = clearSimpleMarkers && Array.isArray(this.poiMarkers) ? this.poiMarkers.slice() : [];
                    const centerMarker = clearCenterMarker ? this.marker : null;

                    if (clearManager) {
                        if (manager && typeof manager.dispose === 'function') {
                            try { manager.dispose(); } catch (_) { }
                        }
                        this.markerManager = null;
                        this.poiActiveManagerId = 0;
                        this.filterPanel = null;
                        if (resetFilterPanel) {
                            const filtersContainer = document.getElementById('filtersContainer');
                            if (filtersContainer) filtersContainer.innerHTML = '';
                        }
                    }
                    if (clearSimpleMarkers) {
                        this.poiMarkers = [];
                    }
                    if (clearCenterMarker) {
                        this.marker = null;
                    }

                    const clearTask = () => {
                        if (manager) {
                            if (typeof manager._destroyClusterersNow === 'function') {
                                manager._destroyClusterersNow();
                            } else if (typeof manager.destroyClusterers === 'function') {
                                manager.destroyClusterers({ immediate: true });
                            }
                        }
                        managerMarkers.forEach((marker) => {
                            if (!marker) return;
                            this.safeMapSet(marker, null);
                            if (typeof marker.setLabel === 'function') {
                                try { marker.setLabel(null); } catch (_) { }
                            }
                        });
                        simpleMarkers.forEach((marker) => {
                            if (!marker) return;
                            this.safeMapSet(marker, null);
                            if (typeof marker.setLabel === 'function') {
                                try { marker.setLabel(null); } catch (_) { }
                            }
                        });
                        if (centerMarker) {
                            this.safeMapSet(centerMarker, null);
                        }
                        if (manager) {
                            manager.markers = [];
                            manager.markersByType = {};
                            manager.markersByPid = {};
                            manager.typeClusterers = {};
                            manager.lastFilteredPoints = [];
                            manager.lastVisibleMarkerPids = new Set();
                        }
                        return {
                            ok: true,
                            poi_generation: generation,
                            manager_cleared: !!manager,
                            manager_markers_cleared: managerMarkers.length,
                            simple_markers_cleared: simpleMarkers.length,
                            center_marker_cleared: !!centerMarker
                        };
                    };

                    if (immediate) {
                        try {
                            return Promise.resolve(clearTask());
                        } catch (err) {
                            return Promise.resolve({
                                ok: false,
                                reason: 'clear_layers_immediate_failed',
                                error: err && err.message ? err.message : String(err)
                            });
                        }
                    }

                    const handle = this.enqueuePoiMapWrite(clearTask, {
                        key: `clear_layers:${reason}`,
                        replaceExisting: false,
                        meta: {
                            reason: `poi_clear_layers:${reason}`,
                            manager_markers: managerMarkers.length,
                            simple_markers: simpleMarkers.length,
                            clear_center_marker: !!centerMarker
                        }
                    });
                    return Promise.resolve(handle && handle.promise).catch(() => ({
                        ok: false,
                        reason: 'clear_layers_failed'
                    }));
                },
                clearAnalysisLayers() {
                    if (this.abortController) {
                        this.abortController.abort();
                        this.abortController = null;
                    }
                    this.isFetchingPois = false;
                    this.isFetchingAois = false;
                    this.fetchProgress = 0;
                    this.poiStatus = '';
                    this.aoiStatus = '';
                    this.roadSyntaxStatus = '';
                    this.resetFetchSubtypeProgress();
                    this.allPoisDetails = [];
                    this.allAoisDetails = [];
                    this.aoiSamplePoints = 0;
                    this.aoiTotalCalls = 0;
                    this.lastIsochroneGeoJSON = null;
                    this.h3GridStatus = '';
                    this.h3GridCount = 0;
                    this.h3GridFeatures = [];
                    this.isGeneratingGrid = false;
                    this.resetH3AnalysisState();

                    this.clearPoiOverlayLayers({
                        reason: 'clear_analysis_layers',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        resetFilterPanel: true
                    });
                    this.clearAoiMarkers();
                    this.resetRoadSyntaxState();

                    if (this.mapCore) {
                        if (this.mapCore.clearGridPolygons) {
                            this.mapCore.clearGridPolygons();
                        }
                        this.mapCore.clearCustomPolygons();
                        this.mapCore.setRadius(0);
                    }
                    this.disposePoiChart();
                },
                resetH3AnalysisState() {
                    this.isComputingH3Analysis = false;
                    this.h3AnalysisSummary = null;
                    this.h3AnalysisCharts = null;
                    this.h3AnalysisGridFeatures = [];
                    this.selectedH3Id = null;
                    this.h3MainStage = 'params';
                    this.h3MetricView = 'density';
                    this.h3StructureFillMode = 'gi_z';
                    this.h3ParamsSubTab = 'grid';
                    this.h3SubTab = 'metric_map';
                    this._ensureH3CategoryState();
                    this.h3TargetCategory = this._resolveDefaultH3TargetCategory();
                    this.h3DecisionTopN = 10;
                    this.h3OnlySignificant = false;
                    this.h3Legend = null;
                    this.h3DerivedStats = {
                        structureSummary: null,
                        typingSummary: null,
                        lqSummary: null,
                        gapSummary: null,
                        topCells: {},
                    };
                    this.disposeH3Charts();
                },
                getIsochronePolygonRing() {
                    if (!this.lastIsochroneGeoJSON || !this.lastIsochroneGeoJSON.geometry) return null;
                    const geometry = this.lastIsochroneGeoJSON.geometry;
                    if (geometry.type === 'Polygon') {
                        return geometry.coordinates[0] || null;
                    }
                    if (geometry.type === 'MultiPolygon') {
                        return geometry.coordinates[0] ? geometry.coordinates[0][0] : null;
                    }
                    return null;
                },
                clearH3Grid() {
                    this.h3GridFeatures = [];
                    this.h3GridCount = 0;
                    this.h3GridStatus = '';
                    this.h3ExportMenuOpen = false;
                    this.h3ExportTasksOpen = false;
                    this.h3ExportScope = 'grid_only';
                    this.resetH3AnalysisState();
                    if (this.mapCore && this.mapCore.clearGridPolygons) {
                        this.mapCore.clearGridPolygons();
                    }
                },
                clearH3GridDisplayOnLeave() {
                    if (!this.mapCore || typeof this.mapCore.clearGridPolygons !== 'function') return;
                    this.mapCore.clearGridPolygons();
                },
                restoreH3GridDisplayOnEnter() {
                    if (!this.mapCore) return;
                    const shouldRenderAnalysis = this.h3MainStage !== 'params'
                        && Array.isArray(this.h3AnalysisGridFeatures)
                        && this.h3AnalysisGridFeatures.length > 0;
                    if (shouldRenderAnalysis) {
                        this.renderH3BySubTab();
                        return;
                    }
                    const plainGridFeatures = Array.isArray(this.h3GridFeatures) && this.h3GridFeatures.length
                        ? this.h3GridFeatures
                        : (Array.isArray(this.h3AnalysisGridFeatures) ? this.h3AnalysisGridFeatures : []);
                    if (plainGridFeatures.length && typeof this.mapCore.setGridFeatures === 'function') {
                        this.mapCore.setGridFeatures(plainGridFeatures, {
                            strokeColor: '#2c6ecb',
                            strokeWeight: 1.1,
                            fillOpacity: 0,
                            webglBatch: true,
                        });
                    }
                },
                async onH3ResolutionChange() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing) {
                        this.clearH3Grid();
                        this.h3GridStatus = '请先完成范围分析后再生成网格';
                        return;
                    }
                    if (this.isComputingH3Analysis) {
                        this.h3GridStatus = '正在计算网格分析，请稍后再调整网格级别';
                        return;
                    }
                    this.h3GridStatus = `网格级别已切换为 res=${this.h3GridResolution}，正在自动刷新网格...`;
                    await this.generateH3Grid();
                },
                onH3GridSettingsChange() {
                    this.clearH3Grid();
                    if (this.h3GridIncludeMode === 'inside') {
                        this.h3GridStatus = `已切换到“完全包含（严格）”，请点击“计算分析”`;
                    } else {
                        this.h3GridStatus = `已切换到“相交优先（边缘保留）”，最小重叠比例=${this.h3GridMinOverlapRatio.toFixed(2)}，请点击“计算分析”`;
                    }
                },
                toggleH3BasemapMuted() {
                    const next = !this.pointSimplifyEnabled;
                    this.pointSimplifyEnabled = next;
                    this.h3BasemapMuted = next;
                    this.onH3BasemapStyleChange();
                },
                onH3BasemapStyleChange() {
                    const hide = !!(this.pointSimplifyEnabled || this.h3BasemapMuted);
                    this.pointSimplifyEnabled = hide;
                    this.h3BasemapMuted = hide;
                    console.info('[point-simplify]', {
                        point_simplify: hide,
                        step: this.step,
                        panel: this.activeStep3Panel || ''
                    });
                    this.applySimplifyBasemapStyle();
                    this.applySimplifyPointVisibility();
                },
                applySimplifyBasemapStyle() {
                    if (!this.mapCore || typeof this.mapCore.setBasemapMuted !== 'function') return;
                    const muted = !!this.h3BasemapMuted;
                    this.mapCore.setBasemapMuted(muted);
                    console.info('[basemap-simplify]', {
                        basemap_muted: muted,
                        source: this.basemapSource || ''
                    });
                },
                shouldShowPoiOnCurrentPanel() {
                    const panel = String(this.activeStep3Panel || '');
                    return panel === 'poi' && !this.poiSystemSuspendedForSyntax;
                },
                applyPoiFilterPanel(reason = '') {
                    const panel = this.filterPanel;
                    if (!panel || typeof panel.applyFilters !== 'function') {
                        return Promise.resolve({ ok: false, skipped: true, reason: `filter_panel_unavailable:${String(reason || '')}` });
                    }
                    try {
                        const maybePromise = panel.applyFilters();
                        if (maybePromise && typeof maybePromise.then === 'function') {
                            return maybePromise;
                        }
                        return Promise.resolve({ ok: true, reason: `filter_panel_sync:${String(reason || '')}` });
                    } catch (err) {
                        return Promise.resolve({
                            ok: false,
                            reason: `filter_panel_exception:${String(reason || '')}`,
                            error: err && err.message ? err.message : String(err)
                        });
                    }
                },
                applySimplifyPointVisibility() {
                    const shouldShowPoi = this.shouldShowPoiOnCurrentPanel();
                    const hidePoi = !shouldShowPoi;

                    if (this.markerManager && typeof this.markerManager.setHideAllPoints === 'function') {
                        this.pointLayersSuspendedForSyntax = !shouldShowPoi;
                        if (hidePoi && typeof this.markerManager.destroyClusterers === 'function') {
                            this.markerManager.destroyClusterers({ immediate: true });
                        }
                        if (typeof this.markerManager.setShowMarkers === 'function') {
                            this.markerManager.setShowMarkers(shouldShowPoi);
                        }
                        this.markerManager.setHideAllPoints(hidePoi);
                        this.applyPoiFilterPanel('simplify_visibility');
                    }

                    if (this.marker) {
                        if (hidePoi) {
                            this.safeMapSet(this.marker, null);
                        } else if (this.selectedPoint && this.mapCore && this.mapCore.map) {
                            this.safeMapSet(this.marker, this.mapCore.map);
                        }
                    }

                    if (Array.isArray(this.poiMarkers) && this.poiMarkers.length > 0) {
                        const legacyMarkers = this.poiMarkers.slice();
                        this.poiMarkers = [];
                        this.enqueuePoiMapWrite(() => {
                            legacyMarkers.forEach((m) => this.safeMapSet(m, null));
                            return { ok: true, hidden: legacyMarkers.length };
                        }, {
                            key: 'clear_legacy_simple_markers',
                            replaceExisting: true,
                            meta: {
                                reason: 'clear_legacy_simple_markers',
                                marker_count: legacyMarkers.length
                            }
                        });
                    }

                    if (!this.markerManager && shouldShowPoi && Array.isArray(this.allPoisDetails) && this.allPoisDetails.length > 0) {
                        this.updateLegacySystem(this.allPoisDetails);
                    }
                },
                async onBasemapSourceChange() {
                    const allowedSources = ['amap', 'osm', 'tianditu'];
                    let source = allowedSources.includes(this.basemapSource) ? this.basemapSource : 'amap';
                    if (source === 'tianditu') {
                        const tileReady = await this.validateTiandituSource();
                        if (!tileReady) {
                            this.tdtDiagCopyStatus = '';
                        }
                    } else {
                        this.tdtDiag = null;
                        this.tdtDiagCopyStatus = '';
                        if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                            this.errorMessage = '';
                        }
                    }
                    this.basemapSource = source;
                    if (this.mapCore && this.mapCore.setBasemapSource) {
                        const applyResult = this.mapCore.setBasemapSource(source);
                        if (source === 'tianditu' && applyResult && applyResult.ok === false) {
                            this.tdtDiag = {
                                ok: false,
                                phase: 'map-init',
                                status: null,
                                contentType: '',
                                bodySnippet: applyResult.message || '',
                                reason: applyResult.code || 'wmts-layer-init-failed',
                            };
                            this.errorMessage = '天地图 WMTS 图层初始化失败，请检查：Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                        } else if (source === 'tianditu' && applyResult && applyResult.ok === true) {
                            if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                                this.errorMessage = '';
                            }
                        }
                    }
                    this.applySimplifyBasemapStyle();
                    this.applySimplifyPointVisibility();
                },
                async generateH3Grid() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing || this.isGeneratingGrid || this.isComputingH3Analysis) return;

                    this.isGeneratingGrid = true;
                    this.resetH3AnalysisState();
                    this.h3GridStatus = '正在生成网络...';
                    try {
                        const polygon = rawRing.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        }).filter(pt => Array.isArray(pt) && pt.length >= 2);

                        const res = await fetch('/api/v1/analysis/h3-grid', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                polygon: polygon,
                                resolution: this.h3GridResolution,
                                coord_type: 'gcj02',
                                include_mode: this.h3GridIncludeMode,
                                min_overlap_ratio: this.h3GridIncludeMode === 'intersects'
                                    ? this.h3GridMinOverlapRatio
                                    : 0
                            })
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                detail = await res.text();
                            } catch (_) { }
                            throw new Error(detail || '网络生成失败');
                        }

                        const data = await res.json();
                        this.h3GridFeatures = data.features || [];
                        this.h3GridCount = Number.isFinite(data.count) ? data.count : this.h3GridFeatures.length;

                        if (this.mapCore && this.mapCore.setGridFeatures) {
                            this.mapCore.setGridFeatures(this.h3GridFeatures, {
                                strokeColor: '#2c6ecb',
                                strokeWeight: 1.1,
                                fillOpacity: 0,
                                webglBatch: true,
                            });
                        }
                        this.h3GridStatus = this.h3GridCount > 0
                            ? `已生成 ${this.h3GridCount} 个 H3 网格`
                            : '已生成网络，但当前范围无可用网格';
                    } catch (e) {
                        console.error(e);
                        this.h3GridStatus = '网络生成失败: ' + e.message;
                    } finally {
                        this.isGeneratingGrid = false;
                    }
                },
                _toNumber(value, fallback = 0) {
                    const n = Number(value);
                    return Number.isFinite(n) ? n : fallback;
                },
                shortH3Id(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id) return '-';
                    if (id.length <= 12) return id;
                    return `${id.slice(0, 5)}...${id.slice(-4)}`;
                },
                focusGridByH3Id(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id || !this.mapCore || !this.mapCore.focusGridCellById) return;
                    this.selectedH3Id = id;
                    const found = this.mapCore.focusGridCellById(id, {
                        fitView: true,
                        zoomMin: 16,
                        animate: true,
                        preserveFill: true,
                        animateFill: false,
                        strokeColor: '#22d3ee',
                        pulseColor: '#ecfeff'
                    });
                    if (!found) {
                        this.h3GridStatus = `未找到对应网格：${id}`;
                        return;
                    }
                    const row = this._findH3RowById(id);
                    if (row) {
                        this.h3GridStatus = this._buildH3StructureStatusText(row);
                    } else {
                        this.h3GridStatus = `已定位网格：${id}`;
                    }
                },
                onH3GridFeatureClick(payload) {
                    const id = payload && payload.h3_id ? String(payload.h3_id) : '';
                    if (!id) return;
                    this.focusGridByH3Id(id);
                },
                _findH3RowById(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id) return null;
                    const rows = (this.h3DerivedStats && this.h3DerivedStats.structureSummary && this.h3DerivedStats.structureSummary.rows) || [];
                    const found = rows.find((row) => String(row.h3_id || '') === id);
                    if (found) return found;
                    const feature = (this.h3AnalysisGridFeatures || []).find((f) => String((f.properties || {}).h3_id || '') === id);
                    if (!feature) return null;
                    const props = feature.properties || {};
                    const giZ = Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null;
                    const lisaI = Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null;
                    const fallbackSignal = Math.max(
                        Number.isFinite(giZ) ? Math.abs(giZ) : 0,
                        Number.isFinite(lisaI) ? Math.abs(lisaI) : 0
                    );
                    return {
                        h3_id: id,
                        gi_star_z_score: giZ,
                        lisa_i: lisaI,
                        structure_signal: Number.isFinite(Number(props.structure_signal)) ? Number(props.structure_signal) : fallbackSignal,
                        density: this._toNumber(props.density_poi_per_km2, 0),
                    };
                },
                _buildH3StructureStatusText(row) {
                    const giText = row && Number.isFinite(this._toNumber(row.gi_star_z_score, NaN))
                        ? this._toNumber(row.gi_star_z_score, 0).toFixed(2)
                        : '-';
                    const lisaText = row && Number.isFinite(this._toNumber(row.lisa_i, NaN))
                        ? this._toNumber(row.lisa_i, 0).toFixed(2)
                        : '-';
                    const signalText = row && Number.isFinite(this._toNumber(row.structure_signal, NaN))
                        ? this._toNumber(row.structure_signal, 0).toFixed(2)
                        : '-';
                    const densityText = row && Number.isFinite(this._toNumber(row.density, NaN))
                        ? this._toNumber(row.density, 0).toFixed(2)
                        : '-';
                    return `Gi*z=${giText} | LISA I=${lisaText} | 结构信号=${signalText} | 密度=${densityText}`;
                },
                getArcgisSnapshotUrl() {
                    const summary = this.h3AnalysisSummary || {};
                    const giUrl = this._normalizeArcgisSnapshotUrl(summary.arcgis_image_url_gi);
                    const lisaUrl = this._normalizeArcgisSnapshotUrl(summary.arcgis_image_url_lisa);
                    const legacyUrl = this._normalizeArcgisSnapshotUrl(summary.arcgis_image_url);
                    if (this.h3SubTab === 'structure_map') {
                        if (this.h3StructureFillMode === 'lisa_i') {
                            // Keep snapshot layer-consistent: never fallback to Gi* image in LISA mode.
                            return lisaUrl || null;
                        }
                        // Keep snapshot layer-consistent: never fallback to LISA image in Gi* mode.
                        return giUrl || null;
                    }
                    return legacyUrl || giUrl || lisaUrl || null;
                },
                getArcgisSnapshotSrc() {
                    const url = this.getArcgisSnapshotUrl();
                    if (!url) return '';
                    if (String(url).startsWith('data:')) return url;
                    const joiner = String(url).includes('?') ? '&' : '?';
                    return `${url}${joiner}v=${this.h3ArcgisImageVersion}`;
                },
                _normalizeArcgisSnapshotUrl(rawUrl) {
                    const raw = String(rawUrl || '').trim();
                    if (!raw || raw.toLowerCase() === 'null' || raw.toLowerCase() === 'none') return null;
                    if (raw.startsWith('data:') || raw.startsWith('http://') || raw.startsWith('https://') || raw.startsWith('/')) {
                        return raw;
                    }
                    const slashNorm = raw.replace(/\\\\/g, '/').replace(/\\/g, '/');
                    const marker = '/static/generated/arcgis/';
                    const idx = slashNorm.indexOf(marker);
                    if (idx >= 0) {
                        return slashNorm.slice(idx);
                    }
                    const marker2 = 'static/generated/arcgis/';
                    const idx2 = slashNorm.indexOf(marker2);
                    if (idx2 >= 0) {
                        return '/' + slashNorm.slice(idx2);
                    }
                    return null;
                },
                getArcgisSnapshotTitle() {
                    if (this.h3SubTab === 'structure_map') {
                        if (this.h3StructureFillMode === 'lisa_i') {
                            return 'ArcGIS 结构快照（LISA / LMiIndex）';
                        }
                        return 'ArcGIS 结构快照（Gi* / Z-score）';
                    }
                    return 'ArcGIS 结构快照';
                },
                clearGridLock() {
                    if (this.mapCore && this.mapCore.clearGridFocus) {
                        this.mapCore.clearGridFocus({ restoreView: true });
                    }
                    this.selectedH3Id = null;
                    this.h3GridStatus = '';
                },
                tryRefocusSelectedGrid() {
                    if (!this.selectedH3Id || !this.mapCore || !this.mapCore.focusGridCellById) return;
                    this.mapCore.focusGridCellById(this.selectedH3Id, {
                        panTo: false,
                        animate: false,
                        preserveFill: true,
                        animateFill: false
                    });
                },
                _quantile(sortedValues, q) {
                    if (!Array.isArray(sortedValues) || sortedValues.length === 0) return 0;
                    if (sortedValues.length === 1) return sortedValues[0];
                    const qq = Math.max(0, Math.min(1, q));
                    const pos = qq * (sortedValues.length - 1);
                    const lower = Math.floor(pos);
                    const upper = Math.min(sortedValues.length - 1, lower + 1);
                    const ratio = pos - lower;
                    return sortedValues[lower] + (sortedValues[upper] - sortedValues[lower]) * ratio;
                },
                _calcContinuousStats(values) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!valid.length) {
                        return {
                            count: 0,
                            mean: null,
                            std: null,
                            min: null,
                            max: null,
                            p10: null,
                            p50: null,
                            p90: null,
                        };
                    }
                    const count = valid.length;
                    const mean = valid.reduce((sum, v) => sum + v, 0) / count;
                    const variance = valid.reduce((sum, v) => sum + (v - mean) * (v - mean), 0) / count;
                    return {
                        count: count,
                        mean: mean,
                        std: Math.sqrt(Math.max(0, variance)),
                        min: valid[0],
                        max: valid[valid.length - 1],
                        p10: this._quantile(valid, 0.1),
                        p50: this._quantile(valid, 0.5),
                        p90: this._quantile(valid, 0.9),
                    };
                },
                _normalizeContinuousStats(stats, fallback) {
                    const source = (stats && typeof stats === 'object') ? stats : (fallback || {});
                    const toMetric = (value) => Number.isFinite(this._toNumber(value, NaN))
                        ? this._toNumber(value, 0)
                        : null;
                    return {
                        count: Math.max(0, Math.round(this._toNumber(source.count, 0))),
                        mean: toMetric(source.mean),
                        std: toMetric(source.std),
                        min: toMetric(source.min),
                        max: toMetric(source.max),
                        p10: toMetric(source.p10),
                        p50: toMetric(source.p50),
                        p90: toMetric(source.p90),
                    };
                },
                _normalizeGiRenderMeta(meta) {
                    const source = (meta && typeof meta === 'object') ? meta : {};
                    const min = Number.isFinite(this._toNumber(source.min, NaN)) ? this._toNumber(source.min, -3) : -3;
                    const max = Number.isFinite(this._toNumber(source.max, NaN)) ? this._toNumber(source.max, 3) : 3;
                    const center = Number.isFinite(this._toNumber(source.center, NaN)) ? this._toNumber(source.center, 0) : 0;
                    return {
                        mode: 'fixed_z',
                        min: Math.min(min, max),
                        max: Math.max(min, max),
                        center: Math.max(Math.min(center, Math.max(min, max)), Math.min(min, max)),
                    };
                },
                _normalizeLisaRenderMeta(meta, lisaIStats) {
                    const stats = lisaIStats || {};
                    const mean = Number.isFinite(this._toNumber(stats.mean, NaN)) ? this._toNumber(stats.mean, 0) : 0;
                    const std = Number.isFinite(this._toNumber(stats.std, NaN)) ? this._toNumber(stats.std, 0) : 0;
                    const p10 = Number.isFinite(this._toNumber(stats.p10, NaN)) ? this._toNumber(stats.p10, NaN) : null;
                    const p90 = Number.isFinite(this._toNumber(stats.p90, NaN)) ? this._toNumber(stats.p90, NaN) : null;
                    const minV = Number.isFinite(this._toNumber(stats.min, NaN)) ? this._toNumber(stats.min, NaN) : null;
                    const maxV = Number.isFinite(this._toNumber(stats.max, NaN)) ? this._toNumber(stats.max, NaN) : null;
                    const source = (meta && typeof meta === 'object') ? meta : {};
                    const clipMinRaw = Number.isFinite(this._toNumber(source.clip_min, NaN))
                        ? this._toNumber(source.clip_min, NaN)
                        : Math.max(
                            Number.isFinite(this._toNumber(mean - 2 * std, NaN)) ? this._toNumber(mean - 2 * std, NaN) : -Infinity,
                            Number.isFinite(this._toNumber(p10, NaN)) ? this._toNumber(p10, NaN) : -Infinity,
                            Number.isFinite(this._toNumber(minV, NaN)) ? this._toNumber(minV, NaN) : -Infinity
                        );
                    const clipMaxRaw = Number.isFinite(this._toNumber(source.clip_max, NaN))
                        ? this._toNumber(source.clip_max, NaN)
                        : Math.min(
                            Number.isFinite(this._toNumber(mean + 2 * std, NaN)) ? this._toNumber(mean + 2 * std, NaN) : Infinity,
                            Number.isFinite(this._toNumber(p90, NaN)) ? this._toNumber(p90, NaN) : Infinity,
                            Number.isFinite(this._toNumber(maxV, NaN)) ? this._toNumber(maxV, NaN) : Infinity
                        );
                    const clipMin = Number.isFinite(clipMinRaw) ? clipMinRaw : mean;
                    const clipMax = Number.isFinite(clipMaxRaw) ? clipMaxRaw : mean;
                    const fallbackDegraded = !(Number.isFinite(std) && std > 0 && Number.isFinite(clipMin) && Number.isFinite(clipMax) && clipMax > clipMin);
                    return {
                        mode: 'stddev',
                        mean: Number.isFinite(this._toNumber(source.mean, NaN)) ? this._toNumber(source.mean, mean) : mean,
                        std: Number.isFinite(this._toNumber(source.std, NaN)) ? this._toNumber(source.std, std) : std,
                        min: Number.isFinite(this._toNumber(source.min, NaN)) ? this._toNumber(source.min, NaN) : stats.min,
                        max: Number.isFinite(this._toNumber(source.max, NaN)) ? this._toNumber(source.max, NaN) : stats.max,
                        clip_min: Math.min(clipMin, clipMax),
                        clip_max: Math.max(clipMin, clipMax),
                        degraded: source.degraded === true || fallbackDegraded,
                        message: source.message || (fallbackDegraded ? 'LMiIndex方差不足' : null),
                    };
                },
                _buildQuantileBreaks(values, binCount = 5) {
                    const sorted = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!sorted.length || sorted[0] === sorted[sorted.length - 1]) {
                        return [];
                    }
                    const breaks = [];
                    for (let i = 1; i < binCount; i += 1) {
                        breaks.push(this._quantile(sorted, i / binCount));
                    }
                    for (let i = 1; i < breaks.length; i += 1) {
                        if (breaks[i] < breaks[i - 1]) {
                            breaks[i] = breaks[i - 1];
                        }
                    }
                    const deduped = [];
                    const eps = 1e-9;
                    for (const value of breaks) {
                        if (!deduped.length || Math.abs(value - deduped[deduped.length - 1]) > eps) {
                            deduped.push(value);
                        }
                    }
                    return deduped;
                },
                _buildDivergingBreaks(values) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!valid.length) return [];
                    const negatives = valid.filter(v => v < 0);
                    const positives = valid.filter(v => v > 0);
                    if (!negatives.length || !positives.length) {
                        return this._buildQuantileBreaks(valid, 5);
                    }
                    const breaks = [
                        this._quantile(negatives, 1 / 3),
                        this._quantile(negatives, 2 / 3),
                        this._quantile(positives, 1 / 3),
                        this._quantile(positives, 2 / 3),
                    ];
                    for (let i = 1; i < breaks.length; i += 1) {
                        if (breaks[i] < breaks[i - 1]) {
                            breaks[i] = breaks[i - 1];
                        }
                    }
                    const deduped = [];
                    const eps = 1e-9;
                    for (const value of breaks) {
                        if (!deduped.length || Math.abs(value - deduped[deduped.length - 1]) > eps) {
                            deduped.push(value);
                        }
                    }
                    return deduped;
                },
                _getMetricSpec(metricKey) {
                    if (metricKey === 'entropy') {
                        return {
                            key: 'entropy',
                            label: '局部熵（归一化）',
                            unit: '0~1',
                            diverging: false,
                            palette: ['#f4fbe8', '#d6efbe', '#a5d88a', '#6bb65d', '#2f7e39'],
                            noDataColor: '#d1d5db',
                            noDataOpacity: 0.10,
                            fillOpacity: 0.24,
                            noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                        };
                    }
                    if (metricKey === 'neighbor_delta') {
                        return {
                            key: 'neighbor_delta',
                            label: '邻域差值（本格-邻域）',
                            unit: 'POI/km²',
                            diverging: true,
                            palette: ['#2b6cb0', '#90cdf4', '#f7f7f7', '#f6ad55', '#c53030'],
                            noDataColor: '#d1d5db',
                            noDataOpacity: 0.10,
                            fillOpacity: 0.24,
                            noDataLabel: '',
                        };
                    }
                    return {
                        key: 'density',
                        label: '密度',
                        unit: 'POI/km²',
                        diverging: false,
                        palette: ['#e8f1ff', '#b7d2ff', '#7eaef9', '#3f82e0', '#1f4f9a'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: '',
                    };
                },
                _getH3MetricValue(props, metricKey) {
                    if (!props) return { value: null, noData: true };
                    const density = this._toNumber(props.density_poi_per_km2, 0);
                    if (metricKey === 'entropy') {
                        const poiCount = this._toNumber(props.poi_count, 0);
                        if (poiCount < this.h3EntropyMinPoi) {
                            return { value: null, noData: true };
                        }
                        const rawEntropy = this._toNumber(props.local_entropy, 0);
                        const normalized = rawEntropy / Math.log(7);
                        const bounded = Math.max(0, Math.min(1, normalized));
                        return { value: bounded, noData: false };
                    }
                    if (metricKey === 'neighbor_delta') {
                        const neighbor = this._toNumber(props.neighbor_mean_density, 0);
                        return { value: density - neighbor, noData: false };
                    }
                    return { value: density, noData: false };
                },
                _colorByBreaks(value, breaks, palette) {
                    if (!Number.isFinite(value)) return '#d1d5db';
                    if (!Array.isArray(breaks) || !breaks.length) {
                        return palette[Math.max(0, Math.floor((palette.length - 1) / 2))] || '#dbe9ff';
                    }
                    let idx = breaks.findIndex(bound => value <= bound);
                    if (idx < 0) idx = palette.length - 1;
                    return palette[Math.max(0, Math.min(idx, palette.length - 1))] || '#dbe9ff';
                },
                _formatLegendValue(value, metricKey) {
                    if (!Number.isFinite(value)) return '-';
                    if (metricKey === 'entropy') return value.toFixed(2);
                    const abs = Math.abs(value);
                    if (abs >= 100) return value.toFixed(0);
                    if (abs >= 10) return value.toFixed(1);
                    return value.toFixed(2);
                },
                _buildLegend(metricSpec, breaks, validValues) {
                    const palette = metricSpec.palette || [];
                    const legend = {
                        title: metricSpec.label,
                        unit: metricSpec.unit,
                        items: [],
                        noDataLabel: metricSpec.noDataLabel || '',
                        noDataColor: metricSpec.noDataColor || '#d1d5db',
                    };
                    if (!palette.length) return legend;
                    if (!Array.isArray(validValues) || !validValues.length) {
                        legend.items = [{ color: palette[0], label: '无有效数据' }];
                        return legend;
                    }
                    if (!breaks.length) {
                        const minV = Math.min(...validValues);
                        const maxV = Math.max(...validValues);
                        legend.items = [{
                            color: palette[palette.length - 1],
                            label: `${this._formatLegendValue(minV, metricSpec.key)} ~ ${this._formatLegendValue(maxV, metricSpec.key)}`
                        }];
                        return legend;
                    }
                    const classCount = Math.min(palette.length, breaks.length + 1);
                    for (let i = 0; i < classCount; i += 1) {
                        let label = '';
                        if (i === 0) {
                            label = `≤ ${this._formatLegendValue(breaks[0], metricSpec.key)}`;
                        } else if (i === classCount - 1) {
                            label = `> ${this._formatLegendValue(breaks[breaks.length - 1], metricSpec.key)}`;
                        } else {
                            label = `${this._formatLegendValue(breaks[i - 1], metricSpec.key)} ~ ${this._formatLegendValue(breaks[i], metricSpec.key)}`;
                        }
                        legend.items.push({ color: palette[i], label: label });
                    }
                    return legend;
                },
                _percentileFromSorted(sortedValues, value) {
                    if (!Array.isArray(sortedValues) || !sortedValues.length || !Number.isFinite(value)) return 0;
                    const n = sortedValues.length;
                    if (n === 1) return 0.5;
                    let lower = 0;
                    while (lower < n && sortedValues[lower] < value) lower += 1;
                    let upper = lower;
                    while (upper < n && sortedValues[upper] <= value) upper += 1;
                    const midRank = (lower + upper - 1) / 2;
                    return Math.max(0, Math.min(1, midRank / (n - 1)));
                },
                _getConfidenceInfo(poiCount) {
                    const count = this._toNumber(poiCount, 0);
                    if (count >= 10) return { score: 2, label: '高' };
                    if (count >= 5) return { score: 1, label: '中' };
                    return { score: 0, label: '低' };
                },
                _getH3CategoryLabel(key) {
                    const hit = (this.h3CategoryMeta || []).find(item => item.key === key);
                    return hit ? hit.label : key;
                },
                classifyGridType(featureProps, thresholds = {}) {
                    const density = this._toNumber(featureProps.density, 0);
                    const entropyNorm = Number.isFinite(featureProps.entropy_norm) ? featureProps.entropy_norm : null;
                    const neighborDelta = this._toNumber(featureProps.neighbor_delta, 0);
                    if (entropyNorm === null) {
                        return {
                            type_key: 'no_data',
                            type_label: '样本不足',
                            is_opportunity: false,
                        };
                    }
                    const highDensity = density >= this._toNumber(thresholds.densityP70, 0);
                    const highEntropy = entropyNorm >= this._toNumber(thresholds.entropyP70, 0);
                    let typeKey = 'low_density_low_mix';
                    let typeLabel = '低密-低混合';
                    if (highDensity && highEntropy) {
                        typeKey = 'high_density_high_mix';
                        typeLabel = '高密-高混合';
                    } else if (highDensity && !highEntropy) {
                        typeKey = 'high_density_low_mix';
                        typeLabel = '高密-低混合';
                    } else if (!highDensity && highEntropy) {
                        typeKey = 'low_density_high_mix';
                        typeLabel = '低密-高混合';
                    }
                    const isOpportunity = typeKey === 'high_density_high_mix' && neighborDelta > 0;
                    return {
                        type_key: typeKey,
                        type_label: typeLabel,
                        is_opportunity: isOpportunity,
                    };
                },
                computeCellLQ(featureProps, globalCategoryCounts, globalTotal) {
                    const poiCount = this._toNumber(featureProps.poi_count, 0);
                    if (poiCount < this.h3EntropyMinPoi) return null;
                    const categoryCounts = featureProps.category_counts || {};
                    const categorySize = Math.max(1, (this.h3CategoryMeta || []).length);
                    const alpha = Math.max(0, this._toNumber(this.h3LqSmoothingAlpha, 0.5));
                    const result = {};
                    (this.h3CategoryMeta || []).forEach(item => {
                        const key = item.key;
                        const gCount = this._toNumber(globalCategoryCounts[key], 0);
                        const cCount = this._toNumber(categoryCounts[key], 0);
                        const gShare = (gCount + alpha) / (Math.max(0, globalTotal) + alpha * categorySize);
                        const cShare = (cCount + alpha) / (Math.max(0, poiCount) + alpha * categorySize);
                        result[key] = gShare > 0 ? (cShare / gShare) : null;
                    });
                    return result;
                },
                computeGapScore(featureProps, targetCategory, gapDemandMapping = null) {
                    const density = this._toNumber(featureProps.density, 0);
                    const poiCount = this._toNumber(featureProps.poi_count, 0);
                    const categoryCounts = featureProps.category_counts || {};
                    const densityByCategory = {};
                    (this.h3CategoryMeta || []).forEach(item => {
                        const count = this._toNumber(categoryCounts[item.key], 0);
                        densityByCategory[item.key] = poiCount > 0 ? density * (count / poiCount) : 0;
                    });
                    const weights = this.h3GapWeights || {};
                    const mapping = gapDemandMapping || {};
                    const demandProxy =
                        this._toNumber(weights.transport, 0) * this._toNumber(densityByCategory[mapping.transport], 0) +
                        this._toNumber(weights.life, 0) * this._toNumber(densityByCategory[mapping.life], 0) +
                        this._toNumber(weights.education, 0) * this._toNumber(densityByCategory[mapping.education], 0) +
                        this._toNumber(weights.medical, 0) * this._toNumber(densityByCategory[mapping.medical], 0);
                    const supplyTargetDensity = this._toNumber(densityByCategory[targetCategory], 0);
                    return {
                        demand_proxy: demandProxy,
                        supply_target_density: supplyTargetDensity,
                    };
                },
                classifyGapZone(demandPct, supplyPct, gapScore) {
                    const demand = this._toNumber(demandPct, 0);
                    const supply = this._toNumber(supplyPct, 0);
                    const gap = this._toNumber(gapScore, 0);
                    if (demand >= 0.6 && supply < 0.4) return '补位机会区';
                    if (demand >= 0.6 && supply >= 0.6) return '高需求高供给（竞争区）';
                    if (demand < 0.4 && supply >= 0.6) return '低需求高供给（偏饱和）';
                    if (demand < 0.4 && supply < 0.4) return '低需求低供给（观察区）';
                    if (gap >= 0.15) return '偏机会区';
                    if (gap <= -0.15) return '偏饱和区';
                    return '相对平衡区';
                },
                computeH3DerivedStats() {
                    this._ensureH3CategoryState();
                    const features = this.h3AnalysisGridFeatures || [];
                    const topN = Math.max(3, Math.min(30, Math.round(this._toNumber(this.h3DecisionTopN, 10))));
                    this.h3DecisionTopN = topN;
                    if (!features.length) {
                        this.h3DerivedStats = {
                            structureSummary: null,
                            typingSummary: null,
                            lqSummary: null,
                            gapSummary: null,
                            topCells: {},
                        };
                        return;
                    }

                    const rowsBase = features.map((feature) => {
                        const props = feature.properties || {};
                        const entropyRaw = this._getH3MetricValue(props, 'entropy');
                        const density = this._toNumber(props.density_poi_per_km2, 0);
                        const neighborDensity = this._toNumber(props.neighbor_mean_density, 0);
                        return {
                            h3_id: props.h3_id || '',
                            poi_count: this._toNumber(props.poi_count, 0),
                            density: density,
                            entropy_norm: entropyRaw.noData ? null : entropyRaw.value,
                            neighbor_delta: density - neighborDensity,
                            category_counts: Object.assign({}, props.category_counts || {}),
                            confidence: this._getConfidenceInfo(props.poi_count),
                            lisa_i: Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null,
                            gi_star_z_score: Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null,
                        };
                    });
                    const rowsEnriched = rowsBase;

                    const densitySorted = rowsEnriched.map(r => r.density).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                    const entropySorted = rowsEnriched.map(r => r.entropy_norm).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                    const densityP70 = densitySorted.length ? this._quantile(densitySorted, 0.7) : 0;
                    const entropyP70 = entropySorted.length ? this._quantile(entropySorted, 0.7) : 0;

                    const typingRowsAll = rowsEnriched.map((row) => {
                        const typed = this.classifyGridType(row, { densityP70, entropyP70 });
                        return Object.assign({}, row, typed);
                    }).sort((a, b) => {
                        if ((b.is_opportunity ? 1 : 0) !== (a.is_opportunity ? 1 : 0)) {
                            return (b.is_opportunity ? 1 : 0) - (a.is_opportunity ? 1 : 0);
                        }
                        if (b.density !== a.density) return b.density - a.density;
                        const confidenceDiff = this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                        if (confidenceDiff !== 0) return confidenceDiff;
                        return this._toNumber(b.entropy_norm, -1) - this._toNumber(a.entropy_norm, -1);
                    });

                    const baseGiStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_z_stats,
                        this._calcContinuousStats(rowsEnriched.map(r => r.gi_star_z_score))
                    );
                    const baseLisaStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_i_stats,
                        this._calcContinuousStats(rowsEnriched.map(r => r.lisa_i))
                    );
                    const lisaMean = this._toNumber(baseLisaStats.mean, 0);
                    const lisaStd = this._toNumber(baseLisaStats.std, 0);
                    const structureRowsBase = rowsEnriched.map((row) => {
                        const giSignal = Number.isFinite(row.gi_star_z_score)
                            ? Math.abs(this._toNumber(row.gi_star_z_score, 0))
                            : 0;
                        let lisaSignal = 0;
                        if (Number.isFinite(row.lisa_i)) {
                            if (lisaStd > 0) {
                                lisaSignal = Math.abs((this._toNumber(row.lisa_i, 0) - lisaMean) / lisaStd);
                            } else {
                                lisaSignal = Math.abs(this._toNumber(row.lisa_i, 0) - lisaMean) > 0 ? 1 : 0;
                            }
                        }
                        const structureSignal = Math.max(giSignal, lisaSignal);
                        const hasStructureMetric = Number.isFinite(row.gi_star_z_score) || Number.isFinite(row.lisa_i);
                        return Object.assign({}, row, {
                            structure_signal: structureSignal,
                            structure_rank: structureSignal,
                            is_structure_signal: hasStructureMetric && structureSignal > 1,
                        });
                    });
                    const structureSignalByH3 = {};
                    structureRowsBase.forEach((row) => {
                        const key = String(row.h3_id || '');
                        if (!key) return;
                        structureSignalByH3[key] = {
                            structure_signal: row.structure_signal,
                            structure_rank: row.structure_rank,
                            is_structure_signal: !!row.is_structure_signal,
                        };
                    });
                    const typingRowsAllWithSignal = typingRowsAll.map((row) => {
                        const key = String(row.h3_id || '');
                        const signalMeta = structureSignalByH3[key] || {};
                        return Object.assign({}, row, signalMeta);
                    });
                    const typingRows = (this.h3OnlySignificant
                        ? typingRowsAllWithSignal.filter(r => r.is_structure_signal)
                        : typingRowsAllWithSignal
                    );
                    const typingCountByType = {};
                    typingRows.forEach(row => {
                        const key = row.type_key || 'unknown';
                        typingCountByType[key] = (typingCountByType[key] || 0) + 1;
                    });
                    const typingOpportunityCount = typingRows.filter(r => r.is_opportunity).length;
                    const typingMaxDensity = typingRows.length ? Math.max(...typingRows.map(r => this._toNumber(r.density, 0))) : 0;
                    const structureRows = (this.h3OnlySignificant
                        ? structureRowsBase.filter(r => r.is_structure_signal)
                        : structureRowsBase
                    ).sort((a, b) => {
                        const rankDiff = this._toNumber(b.structure_rank, 0) - this._toNumber(a.structure_rank, 0);
                        if (rankDiff !== 0) return rankDiff;
                        const giDiff = Math.abs(this._toNumber(b.gi_star_z_score, 0)) - Math.abs(this._toNumber(a.gi_star_z_score, 0));
                        if (giDiff !== 0) return giDiff;
                        if (b.density !== a.density) return b.density - a.density;
                        return this._toNumber(b.poi_count, 0) - this._toNumber(a.poi_count, 0);
                    });
                    const giZStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_z_stats,
                        this._calcContinuousStats(structureRowsBase.map(r => r.gi_star_z_score))
                    );
                    const lisaIStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_i_stats,
                        this._calcContinuousStats(structureRowsBase.map(r => r.lisa_i))
                    );
                    const giRenderMeta = this._normalizeGiRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_render_meta
                    );
                    const lisaRenderMeta = this._normalizeLisaRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_render_meta,
                        lisaIStats
                    );
                    const lisaValidCount = Math.max(0, this._toNumber(lisaIStats.count, 0));
                    const lisaPositiveCount = structureRowsBase.filter(r => Number.isFinite(r.lisa_i) && this._toNumber(r.lisa_i, 0) > 0).length;
                    const lisaNegativeCount = structureRowsBase.filter(r => Number.isFinite(r.lisa_i) && this._toNumber(r.lisa_i, 0) < 0).length;
                    const lisaPositivePct = lisaValidCount > 0 ? (lisaPositiveCount / lisaValidCount) : null;
                    const lisaNegativePct = lisaValidCount > 0 ? (lisaNegativeCount / lisaValidCount) : null;

                    const rowsWithSignal = structureRowsBase;
                    const globalCategoryCounts = {};
                    (this.h3CategoryMeta || []).forEach(item => { globalCategoryCounts[item.key] = 0; });
                    rowsWithSignal.forEach(row => {
                        (this.h3CategoryMeta || []).forEach(item => {
                            globalCategoryCounts[item.key] += this._toNumber(row.category_counts[item.key], 0);
                        });
                    });
                    const globalTotal = Object.values(globalCategoryCounts).reduce((s, v) => s + this._toNumber(v, 0), 0);
                    const lqRowsAll = rowsWithSignal.map(row => {
                        const lqMap = this.computeCellLQ(row, globalCategoryCounts, globalTotal);
                        let dominantKey = null;
                        let dominantValue = null;
                        if (lqMap) {
                            (this.h3CategoryMeta || []).forEach(item => {
                                const v = lqMap[item.key];
                                if (!Number.isFinite(v)) return;
                                if (!Number.isFinite(dominantValue) || v > dominantValue) {
                                    dominantValue = v;
                                    dominantKey = item.key;
                                }
                            });
                        }
                        return Object.assign({}, row, {
                            lq_map: lqMap,
                            lq_target: lqMap ? lqMap[this.h3TargetCategory] : null,
                            dominant_key: dominantKey,
                            dominant_value: dominantValue,
                        });
                    }).sort((a, b) => {
                        const lqDiff = this._toNumber(b.lq_target, -1) - this._toNumber(a.lq_target, -1);
                        if (lqDiff !== 0) return lqDiff;
                        return this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                    });
                    const lqRows = this.h3OnlySignificant
                        ? lqRowsAll.filter(r => r.is_structure_signal)
                        : lqRowsAll;
                    const lqOpportunityCount = lqRows.filter(r => Number.isFinite(r.lq_target) && r.lq_target >= 1.2).length;
                    const lqMax = lqRows.length ? Math.max(...lqRows.map(r => this._toNumber(r.lq_target, 0))) : 0;
                    const dominantCounts = {};
                    (this.h3CategoryMeta || []).forEach(item => { dominantCounts[item.key] = 0; });
                    lqRowsAll.forEach(row => {
                        if (row.dominant_key && Number.isFinite(row.dominant_value) && row.dominant_value > 1) {
                            dominantCounts[row.dominant_key] += 1;
                        }
                    });

                    const gapDemandCategory = this._resolveGapDemandCategoryMap();
                    const missingMapTitles = gapDemandCategory.missingTitles || [];
                    const gapMappingWarning = missingMapTitles.length
                        ? `Gap映射缺失：未找到“${missingMapTitles.join('、')}”，对应权重按0处理`
                        : '';
                    const gapRowsRaw = rowsWithSignal.map(row => Object.assign({}, row, this.computeGapScore(
                        row,
                        this.h3TargetCategory,
                        gapDemandCategory.mapping || {}
                    )));
                    const demandValues = gapRowsRaw.map(r => r.demand_proxy).filter(v => Number.isFinite(v));
                    const supplyValues = gapRowsRaw.map(r => r.supply_target_density).filter(v => Number.isFinite(v));
                    const demandSorted = demandValues.slice().sort((a, b) => a - b);
                    const supplySorted = supplyValues.slice().sort((a, b) => a - b);
                    const gapRowsAll = gapRowsRaw.map(row => {
                        const demandPct = this._percentileFromSorted(demandSorted, row.demand_proxy);
                        const supplyPct = this._percentileFromSorted(supplySorted, row.supply_target_density);
                        const gapScore = demandPct - supplyPct;
                        return Object.assign({}, row, {
                            demand_pct: demandPct,
                            supply_pct: supplyPct,
                            gap_score: gapScore,
                            gap_zone_label: this.classifyGapZone(demandPct, supplyPct, gapScore),
                        });
                    }).sort((a, b) => {
                        const gapDiff = this._toNumber(b.gap_score, -999) - this._toNumber(a.gap_score, -999);
                        if (gapDiff !== 0) return gapDiff;
                        return this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                    });
                    const gapRows = this.h3OnlySignificant
                        ? gapRowsAll.filter(r => r.is_structure_signal)
                        : gapRowsAll;
                    const gapOpportunityCount = gapRows.filter(r => this._toNumber(r.gap_score, 0) > 0.25 && this._toNumber(r.demand_pct, 0) >= 0.6).length;
                    const gapMax = gapRows.length ? Math.max(...gapRows.map(r => this._toNumber(r.gap_score, 0))) : 0;
                    const topGap = gapRows.length ? gapRows[0] : null;
                    const gapInsightBase = topGap
                        ? `Top1 网格需求分位 ${Math.round(this._toNumber(topGap.demand_pct, 0) * 100)}，供给分位 ${Math.round(this._toNumber(topGap.supply_pct, 0) * 100)}，结论：${topGap.gap_zone_label}`
                        : '当前缺口结果为空，请调整范围或业态后重算';
                    const gapInsight = gapMappingWarning
                        ? `${gapMappingWarning}。${gapInsightBase}`
                        : gapInsightBase;

                    this.h3DerivedStats = {
                        structureSummary: {
                            rows: structureRows,
                            giZStats: giZStats,
                            lisaIStats: lisaIStats,
                            lisaPositivePct: lisaPositivePct,
                            lisaNegativePct: lisaNegativePct,
                            giRenderMeta: giRenderMeta,
                            lisaRenderMeta: lisaRenderMeta,
                            recommendation: structureRows.length > 0
                                ? '优先观察Gi*与LMiIndex连续梯度，再结合LQ/缺口结果做落位'
                                : '当前结构梯度较弱，可扩大范围或切换圈层复核',
                        },
                        typingSummary: {
                            counts: typingCountByType,
                            rows: typingRows,
                            densityP70: densityP70,
                            entropyP70: entropyP70,
                            opportunityCount: typingOpportunityCount,
                            maxDensity: typingMaxDensity,
                            recommendation: typingOpportunityCount > 0
                                ? '优先排查高密-高混合且邻域为正的网格'
                                : '当前高密高混合机会有限，可结合区位商优势与缺口优先区复核',
                        },
                        lqSummary: {
                            rows: lqRows,
                            dominantCounts: dominantCounts,
                            opportunityCount: lqOpportunityCount,
                            maxLq: lqMax,
                            recommendation: `${this._getH3CategoryLabel(this.h3TargetCategory)}区位商优势格可优先巩固`,
                        },
                        gapSummary: {
                            rows: gapRows,
                            opportunityCount: gapOpportunityCount,
                            maxGap: gapMax,
                            mappingWarning: gapMappingWarning,
                            recommendation: topGap
                                ? `${this._getH3CategoryLabel(this.h3TargetCategory)}优先关注${topGap.gap_zone_label}`
                                : `${this._getH3CategoryLabel(this.h3TargetCategory)}当前无明显缺口优先区`,
                            insight: gapInsight,
                        },
                        topCells: {
                            structure: structureRows.slice(0, topN),
                            typing: typingRows.slice(0, topN),
                            lq: lqRows.slice(0, topN),
                            gap: gapRows.slice(0, topN),
                        },
                    };
                },
                _renderTypingMap() {
                    const typing = this.h3DerivedStats && this.h3DerivedStats.typingSummary;
                    if (!typing || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const colorByType = {
                        high_density_high_mix: '#0f766e',
                        high_density_low_mix: '#b45309',
                        low_density_high_mix: '#2563eb',
                        low_density_low_mix: '#64748b',
                        no_data: '#d1d5db',
                    };
                    const rowMap = {};
                    (typing.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const typeKey = row.type_key || 'no_data';
                        props.fillColor = colorByType[typeKey] || '#d1d5db';
                        props.fillOpacity = typeKey === 'no_data' ? 0.10 : 0.24;
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.h3Legend = {
                        title: '功能混合度',
                        unit: '分类',
                        items: [
                            { color: colorByType.high_density_high_mix, label: '高密-高混合' },
                            { color: colorByType.high_density_low_mix, label: '高密-低混合' },
                            { color: colorByType.low_density_high_mix, label: '低密-高混合' },
                            { color: colorByType.low_density_low_mix, label: '低密-低混合' },
                        ],
                        noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                        noDataColor: '#d1d5db',
                    };
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2, webglBatch: true });
                    this.tryRefocusSelectedGrid();
                },
                _interpolateHexColor(fromHex, toHex, t) {
                    const from = String(fromHex || '#000000').replace('#', '');
                    const to = String(toHex || '#000000').replace('#', '');
                    if (from.length !== 6 || to.length !== 6) return fromHex || '#000000';
                    const ratio = Math.max(0, Math.min(1, this._toNumber(t, 0)));
                    const fr = parseInt(from.slice(0, 2), 16);
                    const fg = parseInt(from.slice(2, 4), 16);
                    const fb = parseInt(from.slice(4, 6), 16);
                    const tr = parseInt(to.slice(0, 2), 16);
                    const tg = parseInt(to.slice(2, 4), 16);
                    const tb = parseInt(to.slice(4, 6), 16);
                    const rr = Math.round(fr + (tr - fr) * ratio);
                    const rg = Math.round(fg + (tg - fg) * ratio);
                    const rb = Math.round(fb + (tb - fb) * ratio);
                    return '#' + [rr, rg, rb].map((v) => {
                        const s = v.toString(16);
                        return s.length === 1 ? `0${s}` : s;
                    }).join('');
                },
                _resolveContinuousDivergingStyle(value, min, center, max, options = {}) {
                    if (!Number.isFinite(value)) return { fillColor: '#000000', fillOpacity: 0 };
                    const low = Number.isFinite(this._toNumber(min, NaN)) ? this._toNumber(min, -1) : -1;
                    const high = Number.isFinite(this._toNumber(max, NaN)) ? this._toNumber(max, 1) : 1;
                    if (!(high > low)) {
                        return {
                            fillColor: options.midColor || '#f8fafc',
                            fillOpacity: options.minOpacity || 0.08,
                        };
                    }
                    const mid = Number.isFinite(this._toNumber(center, NaN))
                        ? this._toNumber(center, 0)
                        : (low + high) / 2;
                    const clamp = (v) => Math.min(high, Math.max(low, v));
                    const vv = clamp(value);
                    const safeMid = Math.min(high, Math.max(low, mid));
                    const minOpacity = Number.isFinite(this._toNumber(options.minOpacity, NaN))
                        ? this._toNumber(options.minOpacity, 0.08)
                        : 0.08;
                    const maxOpacity = Number.isFinite(this._toNumber(options.maxOpacity, NaN))
                        ? this._toNumber(options.maxOpacity, 0.48)
                        : 0.48;
                    const threshold = Number.isFinite(this._toNumber(options.thresholdAbs, NaN))
                        ? Math.max(0, this._toNumber(options.thresholdAbs, 0))
                        : 0;
                    const lowColor = options.lowColor || '#1d4ed8';
                    const midColor = options.midColor || '#f8fafc';
                    const highColor = options.highColor || '#b91c1c';
                    let ratio = 0;
                    let color = midColor;
                    if (vv >= safeMid) {
                        const span = Math.max(1e-9, high - safeMid);
                        ratio = (vv - safeMid) / span;
                        color = this._interpolateHexColor(midColor, highColor, ratio);
                    } else {
                        const span = Math.max(1e-9, safeMid - low);
                        ratio = (safeMid - vv) / span;
                        color = this._interpolateHexColor(midColor, lowColor, ratio);
                    }
                    if (Math.abs(vv - safeMid) < threshold) {
                        return { fillColor: color, fillOpacity: minOpacity * 0.6 };
                    }
                    const fillOpacity = minOpacity + (maxOpacity - minOpacity) * Math.max(0, Math.min(1, ratio));
                    return { fillColor: color, fillOpacity };
                },
                _resolveGiZFillStyle(zValue, giMeta) {
                    const meta = giMeta || { min: -3, max: 3, center: 0 };
                    return this._resolveContinuousDivergingStyle(
                        zValue,
                        this._toNumber(meta.min, -3),
                        this._toNumber(meta.center, 0),
                        this._toNumber(meta.max, 3),
                        {
                            lowColor: '#1d4ed8',
                            midColor: '#f8fafc',
                            highColor: '#b91c1c',
                            minOpacity: 0.06,
                            maxOpacity: 0.42,
                            thresholdAbs: 0.2,
                        }
                    );
                },
                _resolveLisaIFillStyle(lisaValue, lisaMeta) {
                    const meta = lisaMeta || {};
                    if (meta.degraded) {
                        if (!Number.isFinite(lisaValue)) return { fillColor: '#000000', fillOpacity: 0 };
                        return { fillColor: '#cbd5e1', fillOpacity: 0.06 };
                    }
                    return this._resolveContinuousDivergingStyle(
                        lisaValue,
                        this._toNumber(meta.clip_min, this._toNumber(meta.mean, 0)),
                        this._toNumber(meta.mean, 0),
                        this._toNumber(meta.clip_max, this._toNumber(meta.mean, 0)),
                        {
                            lowColor: '#0f766e',
                            midColor: '#f8fafc',
                            highColor: '#f97316',
                            minOpacity: 0.06,
                            maxOpacity: 0.38,
                            thresholdAbs: 0,
                        }
                    );
                },
                _formatStructureValue(value) {
                    if (!Number.isFinite(this._toNumber(value, NaN))) return '-';
                    return this._toNumber(value, 0).toFixed(2);
                },
                _buildGiLegend(giMeta) {
                    const meta = giMeta || { min: -3, max: 3, center: 0 };
                    const min = this._toNumber(meta.min, -3);
                    const max = this._toNumber(meta.max, 3);
                    const marks = [min, -2, -1, 0, 1, 2, max];
                    const items = [];
                    for (let i = 0; i < marks.length - 1; i += 1) {
                        const left = marks[i];
                        const right = marks[i + 1];
                        const mid = (left + right) / 2;
                        const style = this._resolveGiZFillStyle(mid, meta);
                        items.push({
                            color: style.fillColor,
                            label: `${this._formatStructureValue(left)} ~ ${this._formatStructureValue(right)}`,
                        });
                    }
                    return {
                        title: '结构图（Gi*）',
                        unit: 'GiZScore',
                        items: items,
                        noDataLabel: '|z| 近0或缺失时透明',
                        noDataColor: '#d1d5db',
                    };
                },
                _buildLisaLegend(lisaMeta) {
                    const meta = lisaMeta || {};
                    if (meta.degraded) {
                        return {
                            title: '结构图（LISA）',
                            unit: 'LMiIndex',
                            items: [{ color: '#cbd5e1', label: '方差不足（弱结构）' }],
                            noDataLabel: '无效值透明',
                            noDataColor: '#d1d5db',
                        };
                    }
                    const mean = this._toNumber(meta.mean, 0);
                    const std = Math.max(0, this._toNumber(meta.std, 0));
                    const clipMin = this._toNumber(meta.clip_min, mean - 3 * std);
                    const clipMax = this._toNumber(meta.clip_max, mean + 3 * std);
                    const marks = [clipMin, mean - 2 * std, mean - std, mean, mean + std, mean + 2 * std, clipMax];
                    const items = [];
                    for (let i = 0; i < marks.length - 1; i += 1) {
                        const left = marks[i];
                        const right = marks[i + 1];
                        const mid = (left + right) / 2;
                        const style = this._resolveLisaIFillStyle(mid, meta);
                        items.push({
                            color: style.fillColor,
                            label: `${this._formatStructureValue(left)} ~ ${this._formatStructureValue(right)}`,
                        });
                    }
                    return {
                        title: '结构图（LISA）',
                        unit: 'LMiIndex（标准差）',
                        items: items,
                        noDataLabel: '无效值透明',
                        noDataColor: '#d1d5db',
                    };
                },
                _renderStructureMapStandalone() {
                    const summary = this.h3DerivedStats && this.h3DerivedStats.structureSummary;
                    if (!summary || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    const mode = this.h3StructureFillMode === 'lisa_i' ? 'lisa_i' : 'gi_z';
                    const rowMap = {};
                    (summary.rows || []).forEach((row) => { rowMap[row.h3_id] = row; });
                    const giMeta = summary.giRenderMeta || this._normalizeGiRenderMeta(this.h3AnalysisSummary && this.h3AnalysisSummary.gi_render_meta);
                    const lisaMeta = summary.lisaRenderMeta || this._normalizeLisaRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_render_meta,
                        summary.lisaIStats
                    );
                    const styled = (this.h3AnalysisGridFeatures || []).map((feature) => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const giZValue = Number.isFinite(Number(row.gi_star_z_score))
                            ? Number(row.gi_star_z_score)
                            : (Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null);
                        const lisaIValue = Number.isFinite(Number(row.lisa_i))
                            ? Number(row.lisa_i)
                            : (Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null);
                        const fillStyle = mode === 'lisa_i'
                            ? this._resolveLisaIFillStyle(lisaIValue, lisaMeta)
                            : this._resolveGiZFillStyle(giZValue, giMeta);
                        props.gi_star_z_score = giZValue;
                        props.lisa_i = lisaIValue;
                        props.fillColor = fillStyle.fillColor;
                        props.fillOpacity = fillStyle.fillOpacity;
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.h3Legend = mode === 'lisa_i' ? this._buildLisaLegend(lisaMeta) : this._buildGiLegend(giMeta);
                    this.mapCore.setGridFeatures(styled, {
                        fillOpacity: 0.22,
                        strokeWeight: 1.2,
                        structureBoundaryEdges: false,
                        webglBatch: true,
                    });
                    this.h3StructureRenderStats = null;
                    this.tryRefocusSelectedGrid();
                },
                _renderLqMap() {
                    const lq = this.h3DerivedStats && this.h3DerivedStats.lqSummary;
                    if (!lq || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const metricSpec = {
                        key: 'lq',
                        label: `${this._getH3CategoryLabel(this.h3TargetCategory)} 区位商优势（LQ）`,
                        unit: '相对值',
                        palette: ['#edf7ed', '#c4e3c4', '#8ccb8c', '#4ea95d', '#1b6e33'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                    };
                    const rowMap = {};
                    (lq.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const validValues = (lq.rows || []).map(r => r.lq_target).filter(v => Number.isFinite(v));
                    const breaks = this._buildQuantileBreaks(validValues, 5);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const value = row.lq_target;
                        if (!Number.isFinite(value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                        } else {
                            props.fillColor = this._colorByBreaks(value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2, webglBatch: true });
                    this.tryRefocusSelectedGrid();
                },
                _renderGapMap() {
                    const gap = this.h3DerivedStats && this.h3DerivedStats.gapSummary;
                    if (!gap || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const metricSpec = {
                        key: 'gap',
                        label: `${this._getH3CategoryLabel(this.h3TargetCategory)} 缺口分`,
                        unit: '百分位差值',
                        palette: ['#2b6cb0', '#90cdf4', '#f7f7f7', '#f6ad55', '#c53030'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: '',
                    };
                    const rowMap = {};
                    (gap.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const validValues = (gap.rows || []).map(r => r.gap_score).filter(v => Number.isFinite(v));
                    const breaks = this._buildDivergingBreaks(validValues);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const value = row.gap_score;
                        if (!Number.isFinite(value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                        } else {
                            props.fillColor = this._colorByBreaks(value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2, webglBatch: true });
                    this.tryRefocusSelectedGrid();
                },
                renderH3BySubTab() {
                    if (!this.h3AnalysisGridFeatures || !this.h3AnalysisGridFeatures.length) {
                        this.h3Legend = null;
                        return;
                    }
                    if (this.h3SubTab === 'structure_map') {
                        this._renderStructureMapStandalone();
                    } else if (this.h3SubTab === 'typing') {
                        this._renderTypingMap();
                    } else if (this.h3SubTab === 'lq') {
                        this._renderLqMap();
                    } else if (this.h3SubTab === 'gap') {
                        this._renderGapMap();
                    } else {
                        this.renderH3AnalysisGrid(this.h3MetricView);
                    }
                },
                updateDecisionCards() {
                    if (!window.echarts || !this.h3DerivedStats) return;
                    const lqEl = document.getElementById('h3LqChart');
                    const gapEl = document.getElementById('h3GapChart');
                    const structureEl = document.getElementById('h3StructureChart');
                    if (!this.h3ChartsResizeHandler) {
                        this.h3ChartsResizeHandler = () => {
                            if (this.h3CategoryChart) this.h3CategoryChart.resize();
                            if (this.h3DensityChart) this.h3DensityChart.resize();
                            if (this.h3LqChart) this.h3LqChart.resize();
                            if (this.h3GapChart) this.h3GapChart.resize();
                            if (this.h3StructureChart) this.h3StructureChart.resize();
                        };
                        window.addEventListener('resize', this.h3ChartsResizeHandler);
                    }

                    if (structureEl && this.h3SubTab === 'structure_map') {
                        let chart = echarts.getInstanceByDom(structureEl);
                        if (!chart) chart = echarts.init(structureEl);
                        this.h3StructureChart = chart;
                        const summary = this.h3DerivedStats.structureSummary || {};
                        const structureMode = this.h3StructureFillMode === 'lisa_i' ? 'lisa_i' : 'gi_z';
                        const giStats = summary.giZStats || {};
                        const lisaStats = summary.lisaIStats || {};
                        const labels = ['均值', '中位数', 'P90', 'P10', '最小', '最大'];
                        const activeStats = structureMode === 'lisa_i' ? lisaStats : giStats;
                        const activeSeriesName = structureMode === 'lisa_i' ? 'LISA I' : 'Gi* Z';
                        const activeSeriesColor = structureMode === 'lisa_i' ? '#0f766e' : '#b91c1c';
                        const activeValues = [
                            this._toNumber(activeStats.mean, 0),
                            this._toNumber(activeStats.p50, 0),
                            this._toNumber(activeStats.p90, 0),
                            this._toNumber(activeStats.p10, 0),
                            this._toNumber(activeStats.min, 0),
                            this._toNumber(activeStats.max, 0),
                        ];
                        chart.setOption({
                            title: { text: `结构连续指标概览（${activeSeriesName}）`, left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 44, right: 14, top: 28, bottom: 24, containLabel: true },
                            legend: { top: 4, right: 8, itemWidth: 10, itemHeight: 8, textStyle: { fontSize: 11 } },
                            xAxis: { type: 'value', splitLine: { lineStyle: { color: '#eceff3' } } },
                            yAxis: {
                                type: 'category',
                                data: labels,
                                axisTick: { show: false },
                                axisLine: { show: false }
                            },
                            series: [
                                {
                                    name: activeSeriesName,
                                    type: 'bar',
                                    data: activeValues,
                                    barWidth: 10,
                                    itemStyle: { color: activeSeriesColor },
                                }
                            ]
                        }, true);
                    }

                    if (lqEl && this.h3SubTab === 'lq') {
                        let chart = echarts.getInstanceByDom(lqEl);
                        if (!chart) chart = echarts.init(lqEl);
                        this.h3LqChart = chart;
                        const summary = this.h3DerivedStats.lqSummary || {};
                        const labels = (this.h3CategoryMeta || []).map(item => item.label);
                        const values = (this.h3CategoryMeta || []).map(item => this._toNumber((summary.dominantCounts || {})[item.key], 0));
                        chart.setOption({
                            title: { text: '主导优势类别分布', left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 44, right: 14, top: 28, bottom: 24, containLabel: true },
                            xAxis: { type: 'value', minInterval: 1, splitLine: { lineStyle: { color: '#eceff3' } } },
                            yAxis: { type: 'category', data: labels, axisTick: { show: false }, axisLine: { show: false } },
                            series: [{ type: 'bar', data: values, barWidth: 12, itemStyle: { color: '#4f8ad9' } }]
                        }, true);
                    }

                    if (gapEl && this.h3SubTab === 'gap') {
                        let chart = echarts.getInstanceByDom(gapEl);
                        if (!chart) chart = echarts.init(gapEl);
                        this.h3GapChart = chart;
                        const rows = ((this.h3DerivedStats.gapSummary || {}).rows || []);
                        const data = rows.map((row) => {
                            const demandPct = Math.max(0, Math.min(1, this._toNumber(row.demand_pct, 0)));
                            const supplyPct = Math.max(0, Math.min(1, this._toNumber(row.supply_pct, 0)));
                            const gapScore = this._toNumber(row.gap_score, 0);
                            const poiCount = Math.max(0, this._toNumber(row.poi_count, 0));
                            const symbolSize = Math.max(8, Math.min(26, 8 + Math.sqrt(poiCount) * 2));
                            return {
                                h3_id: row.h3_id,
                                gap_zone_label: row.gap_zone_label || '',
                                confidence_label: (row.confidence && row.confidence.label) || '低',
                                demand_pct: demandPct,
                                supply_pct: supplyPct,
                                gap_score: gapScore,
                                poi_count: poiCount,
                                symbolSize: symbolSize,
                                value: [Math.round(supplyPct * 100), Math.round(demandPct * 100), gapScore]
                            };
                        });
                        chart.setOption({
                            title: { text: '需求-供给散点（每点=网格）', left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 54, right: 14, top: 28, bottom: 34, containLabel: true },
                            tooltip: {
                                trigger: 'item',
                                formatter: (params) => {
                                    const d = params.data || {};
                                    const hid = d.h3_id || '-';
                                    return [
                                        `<b>${this.shortH3Id(hid)}</b>`,
                                        `需求分位: ${d.value ? d.value[1] : 0}`,
                                        `供给分位: ${d.value ? d.value[0] : 0}`,
                                        `缺口分: ${this._toNumber(d.gap_score, 0).toFixed(2)}`,
                                        `可信度: ${d.confidence_label || '-'}`,
                                        `结论: ${d.gap_zone_label || '-'}`,
                                    ].join('<br/>');
                                }
                            },
                            xAxis: {
                                type: 'value',
                                name: '供给百分位',
                                min: 0,
                                max: 100,
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: '需求百分位',
                                min: 0,
                                max: 100,
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            series: [{
                                type: 'scatter',
                                data: data,
                                symbolSize: (item) => item.symbolSize || 10,
                                itemStyle: {
                                    color: (params) => {
                                        const gap = this._toNumber(params && params.data && params.data.gap_score, 0);
                                        if (gap >= 0.25) return '#d8573f';
                                        if (gap <= -0.25) return '#3f7fd8';
                                        return '#93a5bf';
                                    },
                                    opacity: 0.85
                                },
                                emphasis: {
                                    itemStyle: {
                                        borderColor: '#111827',
                                        borderWidth: 1
                                    }
                                },
                                markLine: {
                                    silent: true,
                                    symbol: ['none', 'none'],
                                    lineStyle: { type: 'dashed', color: '#cbd5e1' },
                                    data: [{ xAxis: 50 }, { yAxis: 50 }]
                                }
                            }]
                        }, true);
                        chart.off('click');
                        chart.on('click', (params) => {
                            const h3Id = params && params.data && params.data.h3_id;
                            if (h3Id) this.focusGridByH3Id(h3Id);
                        });
                    }
                },
                renderH3AnalysisGrid(metricKey) {
                    const source = this.h3AnalysisGridFeatures;
                    if (!Array.isArray(source) || source.length === 0 || !this.mapCore || !this.mapCore.setGridFeatures) {
                        this.h3Legend = null;
                        return;
                    }
                    this.h3StructureRenderStats = null;

                    const metricSpec = this._getMetricSpec(metricKey);
                    const measured = source.map((feature) => {
                        const datum = this._getH3MetricValue((feature && feature.properties) || {}, metricKey);
                        return {
                            feature: feature,
                            value: datum.value,
                            noData: datum.noData
                        };
                    });
                    const validValues = measured
                        .filter(item => !item.noData && Number.isFinite(item.value))
                        .map(item => item.value);
                    const breaks = metricSpec.diverging
                        ? this._buildDivergingBreaks(validValues)
                        : this._buildQuantileBreaks(validValues, 5);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);

                    const styled = measured.map((item) => {
                        const feature = item.feature;
                        const props = Object.assign({}, feature.properties || {});
                        if (item.noData || !Number.isFinite(item.value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                            props.metric_value = null;
                            props.metric_no_data = true;
                        } else {
                            props.fillColor = this._colorByBreaks(item.value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                            props.metric_value = item.value;
                            props.metric_no_data = false;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;

                        return {
                            type: feature.type,
                            geometry: feature.geometry,
                            properties: props
                        };
                    });

                    this.mapCore.setGridFeatures(styled, {
                        fillOpacity: 0.22,
                        strokeWeight: 1.2,
                        structureBoundaryEdges: false,
                        structureBoundaryGi: false,
                        structureBoundaryLisa: false,
                        webglBatch: true,
                    });
                    this.tryRefocusSelectedGrid();
                },
                getH3CurrentStageTabs() {
                    const fallback = ['metric_map'];
                    const stageTabs = this.h3MainStageTabs || {};
                    const tabs = stageTabs[this.h3MainStage] || fallback;
                    return Array.isArray(tabs) && tabs.length ? tabs : fallback;
                },
                getH3DefaultSubTabByStage(stage) {
                    const stageTabs = this.h3MainStageTabs || {};
                    const tabs = stageTabs[stage];
                    if (Array.isArray(tabs) && tabs.length) return tabs[0];
                    return 'metric_map';
                },
                resolveH3MainStageBySubTab(tab) {
                    const stageTabs = this.h3MainStageTabs || {};
                    const stageOrder = ['analysis', 'diagnosis', 'evaluate'];
                    for (const stage of stageOrder) {
                        const tabs = stageTabs[stage];
                        if (Array.isArray(tabs) && tabs.includes(tab)) return stage;
                    }
                    return 'analysis';
                },
                async onH3MainStageChange(stage) {
                    if (stage !== 'params' && stage !== 'analysis' && stage !== 'diagnosis' && stage !== 'evaluate') return;
                    this.h3MainStage = stage;
                    if (stage === 'params') {
                        this.h3ParamsSubTab = 'grid';
                        return;
                    }
                    const targetTab = this.getH3DefaultSubTabByStage(stage);
                    await this.onH3SubTabChange(targetTab);
                },
                onH3MetricViewChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'metric_map') return;
                    this.refreshMetricMapView();
                },
                onH3StructureFillModeChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'structure_map') return;
                    this._renderStructureMapStandalone();
                    this.$nextTick(() => {
                        this.updateDecisionCards();
                    });
                },
                async refreshMetricMapView() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'metric_map') return;
                    this.renderH3AnalysisGrid(this.h3MetricView);
                    await this.$nextTick();
                    this.updateH3Charts();
                },
                async onH3SubTabChange(tab) {
                    this.h3SubTab = tab;
                    this.h3MainStage = this.resolveH3MainStageBySubTab(tab);
                    if (!this.h3AnalysisGridFeatures.length) return;
                    this.computeH3DerivedStats();
                    await this.$nextTick();
                    this.renderH3BySubTab();
                    await this.$nextTick();
                    this.updateH3Charts();
                    this.updateDecisionCards();
                },
                async onH3DecisionSettingsChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    this.computeH3DerivedStats();
                    await this.$nextTick();
                    this.renderH3BySubTab();
                    await this.$nextTick();
                    this.updateH3Charts();
                    this.updateDecisionCards();
                },
                toggleH3ExportMenu() {
                    if (this.h3ExportScope === 'analysis_result' && !this.hasH3AnalysisForExport()) {
                        this.h3ExportScope = 'grid_only';
                    }
                    this.h3ExportTasksOpen = false;
                    this.h3ExportMenuOpen = !this.h3ExportMenuOpen;
                },
                closeH3ExportMenu() {
                    this.h3ExportMenuOpen = false;
                },
                toggleH3ExportTasks() {
                    this.h3ExportMenuOpen = false;
                    this.h3ExportTasksOpen = !this.h3ExportTasksOpen;
                },
                closeH3ExportTasks() {
                    this.h3ExportTasksOpen = false;
                },
                handleGlobalClick(event) {
                    const target = event && event.target;
                    const hasClosest = !!(target && target.closest);
                    const inExportWrap = hasClosest && !!target.closest('.h3-export-wrap');
                    const inTaskPanel = hasClosest && !!target.closest('.h3-export-task-panel');
                    const inTaskWrap = hasClosest && !!target.closest('.h3-task-wrap');
                    if (this.h3ExportMenuOpen && !inExportWrap) {
                        this.h3ExportMenuOpen = false;
                    }
                    if (this.h3ExportTasksOpen && !inTaskPanel && !inTaskWrap) {
                        this.h3ExportTasksOpen = false;
                    }
                },
                getH3PendingTaskCount() {
                    return (this.h3ExportTasks || []).filter((task) => task.status === 'running').length;
                },
                _buildH3ExportTaskTitle(exportFormat) {
                    return exportFormat === 'arcgis_package' ? '高级导出（LPK+MPK）' : '快速导出（.gpkg）';
                },
                _buildH3ExportScopeLabel() {
                    return this.h3ExportScope === 'analysis_result' ? '分析结果' : '仅网格';
                },
                _createH3ExportTask(exportFormat) {
                    this.h3ExportTaskSeq = Number(this.h3ExportTaskSeq || 0) + 1;
                    const now = new Date();
                    const task = {
                        id: `h3-export-${Date.now()}-${this.h3ExportTaskSeq}`,
                        title: this._buildH3ExportTaskTitle(exportFormat),
                        scope_label: this._buildH3ExportScopeLabel(),
                        status: 'running',
                        status_label: '导出中',
                        created_at: now.toISOString(),
                        created_at_text: now.toLocaleTimeString([], { hour12: false }),
                        filename: '',
                        error: '',
                    };
                    this.h3ExportTasks = [task].concat(this.h3ExportTasks || []).slice(0, 20);
                    return task.id;
                },
                _updateH3ExportTask(taskId, patch) {
                    this.h3ExportTasks = (this.h3ExportTasks || []).map((task) => {
                        if (task.id !== taskId) return task;
                        return Object.assign({}, task, patch || {});
                    });
                },
                clearH3CompletedTasks() {
                    this.h3ExportTasks = (this.h3ExportTasks || []).filter((task) => task.status === 'running');
                },
                _showH3ExportToast(message, type = 'info', durationMs = 2200) {
                    if (this.h3ToastTimer) {
                        clearTimeout(this.h3ToastTimer);
                        this.h3ToastTimer = null;
                    }
                    this.h3Toast = {
                        message: String(message || ''),
                        type: String(type || 'info'),
                    };
                    this.h3ToastTimer = setTimeout(() => {
                        this.h3Toast = { message: '', type: 'info' };
                        this.h3ToastTimer = null;
                    }, Math.max(800, Number(durationMs) || 2200));
                },
                _resolveH3ExportStyleMode() {
                    if (this.h3ExportScope === 'grid_only') return 'density';
                    if (this.h3MainStage === 'analysis' && this.h3SubTab === 'structure_map') {
                        return this.h3StructureFillMode === 'lisa_i' ? 'lisa_i' : 'gi_z';
                    }
                    return 'density';
                },
                hasH3GridForExport() {
                    return Array.isArray(this.h3GridFeatures) && this.h3GridFeatures.length > 0;
                },
                hasH3AnalysisForDisplay() {
                    return Array.isArray(this.h3AnalysisGridFeatures)
                        && this.h3AnalysisGridFeatures.length > 0;
                },
                hasH3AnalysisForExport() {
                    return Array.isArray(this.h3AnalysisGridFeatures)
                        && this.h3AnalysisGridFeatures.length > 0
                        && !!this.h3AnalysisSummary;
                },
                ensureH3PanelEntryState() {
                    const hasAnalysis = this.hasH3AnalysisForDisplay();
                    if (!hasAnalysis) {
                        this.h3MainStage = 'params';
                        this.h3ParamsSubTab = 'grid';
                        if (!this.h3GridFeatures.length && !this.isGeneratingGrid && !this.isComputingH3Analysis) {
                            this.h3GridStatus = '已进入网格参数页，请点击“计算分析”';
                        }
                        return;
                    }

                    if (this.h3MainStage === 'params' || !['analysis', 'diagnosis', 'evaluate'].includes(this.h3MainStage)) {
                        this.h3MainStage = 'analysis';
                    }
                    const currentTabs = this.getH3CurrentStageTabs();
                    if (!currentTabs.includes(this.h3SubTab)) {
                        this.h3SubTab = this.getH3DefaultSubTabByStage(this.h3MainStage);
                    }
                },
                _resolveH3ExportSourceFeatures() {
                    if (this.h3ExportScope === 'analysis_result') {
                        return this.hasH3AnalysisForExport() ? this.h3AnalysisGridFeatures : [];
                    }
                    if (this.hasH3GridForExport()) {
                        return this.h3GridFeatures;
                    }
                    if (this.hasH3AnalysisForExport()) {
                        return this.h3AnalysisGridFeatures;
                    }
                    return [];
                },
                _buildH3ExportGridFeatures() {
                    const source = this._resolveH3ExportSourceFeatures();
                    return (source || []).map((feature) => ({
                        type: String((feature && feature.type) || 'Feature'),
                        geometry: this._normalizeGeometryForExport((feature && feature.geometry) || null),
                        properties: Object.assign({}, (feature && feature.properties) || {}),
                    })).filter((feature) => feature.geometry && feature.properties);
                },
                _normalizeCoordPointForExport(point) {
                    if (Array.isArray(point) && point.length >= 2) {
                        const lng = Number(point[0]);
                        const lat = Number(point[1]);
                        if (Number.isFinite(lng) && Number.isFinite(lat)) return [lng, lat];
                    }
                    if (point && typeof point === 'object') {
                        const lng = Number(point.lng ?? point.lon);
                        const lat = Number(point.lat);
                        if (Number.isFinite(lng) && Number.isFinite(lat)) return [lng, lat];
                    }
                    return null;
                },
                _normalizeRingForExport(ring) {
                    if (!Array.isArray(ring)) return [];
                    const points = ring
                        .map((pt) => this._normalizeCoordPointForExport(pt))
                        .filter((pt) => Array.isArray(pt) && pt.length >= 2);
                    if (points.length < 3) return [];
                    const first = points[0];
                    const last = points[points.length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        points.push([first[0], first[1]]);
                    }
                    return points.length >= 4 ? points : [];
                },
                _normalizeGeometryForExport(geometry) {
                    if (!geometry || typeof geometry !== 'object') return null;
                    const type = String(geometry.type || '');
                    const coords = geometry.coordinates;
                    if (type === 'Polygon') {
                        if (!Array.isArray(coords)) return null;
                        const first = coords[0];
                        const directRing = this._normalizeRingForExport(coords);
                        if (directRing.length) {
                            return { type: 'Polygon', coordinates: [directRing] };
                        }
                        const outerRing = this._normalizeRingForExport(first);
                        if (!outerRing.length) return null;
                        return { type: 'Polygon', coordinates: [outerRing] };
                    }
                    if (type === 'MultiPolygon') {
                        if (!Array.isArray(coords)) return null;
                        const polygons = [];
                        coords.forEach((poly) => {
                            if (!Array.isArray(poly)) return;
                            const directRing = this._normalizeRingForExport(poly);
                            if (directRing.length) {
                                polygons.push([directRing]);
                                return;
                            }
                            const outer = this._normalizeRingForExport(poly[0]);
                            if (outer.length) polygons.push([outer]);
                        });
                        if (!polygons.length) return null;
                        return { type: 'MultiPolygon', coordinates: polygons };
                    }
                    return null;
                },
                _buildH3ExportPoiFeatures() {
                    if (!this.h3ExportIncludePoi) return [];
                    const source = this._buildH3AnalysisPois();
                    if (!source.length) return [];
                    return source
                        .map((poi) => {
                            const location = Array.isArray(poi && poi.location) ? poi.location : [];
                            const lng = Number(location[0]);
                            const lat = Number(location[1]);
                            if (!Number.isFinite(lng) || !Number.isFinite(lat)) return null;
                            const category = this.resolvePoiCategory(poi && poi.type);
                            return {
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [lng, lat],
                                },
                                properties: {
                                    id: String((poi && poi.id) || ''),
                                    name: String((poi && poi.name) || ''),
                                    type: String((poi && poi.type) || ''),
                                    category_id: String((category && category.id) || ''),
                                    category: String((category && category.name) || ''),
                                }
                            };
                        })
                        .filter(Boolean);
                },
                _getFilenameFromContentDisposition(disposition) {
                    const raw = String(disposition || '');
                    if (!raw) return '';
                    const utf8Match = raw.match(/filename\*=UTF-8''([^;]+)/i);
                    if (utf8Match && utf8Match[1]) {
                        try { return decodeURIComponent(utf8Match[1]); } catch (_) { return utf8Match[1]; }
                    }
                    const normalMatch = raw.match(/filename=\"?([^\";]+)\"?/i);
                    return normalMatch && normalMatch[1] ? normalMatch[1] : '';
                },
                _downloadBlobFile(blob, filename) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename || 'h3_export.bin';
                    document.body.appendChild(link);
                    link.click();
                    link.remove();
                    URL.revokeObjectURL(url);
                },
                async exportH3Analysis(format) {
                    if (this.isExportingH3) {
                        this._showH3ExportToast('已有导出任务进行中，请稍候', 'info');
                        this.h3ExportTasksOpen = true;
                        return;
                    }
                    if (this.h3ExportScope === 'analysis_result' && !this.hasH3AnalysisForExport()) {
                        this._showH3ExportToast('请先完成计算分析，再导出分析结果', 'warning');
                        return;
                    }
                    const gridFeatures = this._buildH3ExportGridFeatures();
                    if (!gridFeatures.length) {
                        this._showH3ExportToast('暂无可导出的网格', 'warning');
                        return;
                    }
                    const exportFormat = format === 'arcgis_package' ? 'arcgis_package' : 'gpkg';
                    const taskId = this._createH3ExportTask(exportFormat);
                    this.h3ExportTasksOpen = true;
                    const styleMode = this._resolveH3ExportStyleMode();
                    const payload = {
                        format: exportFormat,
                        include_poi: !!this.h3ExportIncludePoi,
                        style_mode: styleMode,
                        grid_features: gridFeatures,
                        poi_features: this._buildH3ExportPoiFeatures(),
                        style_meta: {
                            legend: this.h3Legend || null,
                            metric_view: this.h3MetricView,
                            structure_fill_mode: this.h3StructureFillMode,
                            gi_render_meta: (this.h3AnalysisSummary && this.h3AnalysisSummary.gi_render_meta) || null,
                            lisa_render_meta: (this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_render_meta) || null,
                        },
                        arcgis_python_path: this.h3ArcgisPythonPath || null,
                        arcgis_timeout_sec: 300,
                    };
                    this.isExportingH3 = true;
                    try {
                        const res = await fetch('/api/v1/analysis/h3/export', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                const errJson = await res.json();
                                detail = errJson && (errJson.detail || errJson.error || JSON.stringify(errJson));
                            } catch (_) {
                                try { detail = await res.text(); } catch (_) { detail = ''; }
                            }
                            throw new Error(detail || `HTTP ${res.status}`);
                        }
                        const blob = await res.blob();
                        const filename = this._getFilenameFromContentDisposition(res.headers.get('content-disposition'))
                            || (exportFormat === 'arcgis_package' ? 'h3_analysis.zip' : 'h3_analysis.gpkg');
                        this._downloadBlobFile(blob, filename);
                        this._updateH3ExportTask(taskId, {
                            status: 'success',
                            status_label: '已完成',
                            filename: filename,
                            error: '',
                        });
                        this._showH3ExportToast(`导出成功：${filename}`, 'success');
                        this.h3ExportMenuOpen = false;
                    } catch (e) {
                        console.error(e);
                        this._updateH3ExportTask(taskId, {
                            status: 'failed',
                            status_label: '失败',
                            error: String((e && e.message) || e || '导出失败'),
                        });
                        this._showH3ExportToast(`导出失败：${(e && e.message) || e}`, 'error', 3200);
                    } finally {
                        this.isExportingH3 = false;
                    }
                },
                async computeH3Analysis() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing || this.isComputingH3Analysis) return;
                    const progressTotal = 5;
                    const startedAt = Date.now();
                    const engineName = 'ArcGIS';
                    let progressStep = 0;
                    let progressLabel = '准备中';
                    let progressTimer = null;
                    const setProgress = (step, label) => {
                        progressStep = step;
                        progressLabel = label;
                        const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
                        this.h3GridStatus = `网格分析进度 ${progressStep}/${progressTotal}：${progressLabel}（${sec}s）`;
                    };
                    this.isComputingH3Analysis = true;
                    setProgress(1, '准备分析参数');
                    progressTimer = window.setInterval(() => {
                        if (!this.isComputingH3Analysis) return;
                        const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
                        this.h3GridStatus = `网格分析进度 ${progressStep}/${progressTotal}：${progressLabel}（${sec}s）`;
                    }, 1000);
                    try {
                        const polygon = rawRing.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        }).filter(pt => Array.isArray(pt) && pt.length >= 2);
                        const neighborRing = Math.max(1, Math.min(3, Math.round(this._toNumber(this.h3NeighborRing, 1))));
                        this.h3NeighborRing = neighborRing;
                        const analysisPois = this._buildH3AnalysisPois();
                        if (!analysisPois.length) {
                            throw new Error('当前“分析POI”配置下无可计算样本，请先在参数页勾选至少一个有数据的POI分类');
                        }

                        const payload = {
                            polygon: polygon,
                            resolution: this.h3GridResolution,
                            coord_type: 'gcj02',
                            include_mode: this.h3GridIncludeMode,
                            min_overlap_ratio: this.h3GridIncludeMode === 'intersects' ? this.h3GridMinOverlapRatio : 0,
                            pois: analysisPois,
                            poi_coord_type: 'gcj02',
                            neighbor_ring: neighborRing,
                            use_arcgis: true,
                            arcgis_python_path: this.h3ArcgisPythonPath || null,
                            arcgis_neighbor_ring: neighborRing,
                            arcgis_export_image: false,
                            arcgis_timeout_sec: 240
                        };

                        setProgress(2, `请求已发送，后端计算中（${engineName}）`);
                        const res = await fetch('/api/v1/analysis/h3-metrics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                const errJson = await res.json();
                                if (errJson && typeof errJson === 'object') {
                                    detail = errJson.detail || JSON.stringify(errJson);
                                } else {
                                    detail = String(errJson || '');
                                }
                            } catch (_) {
                                try { detail = await res.text(); } catch (_) { }
                            }
                            throw new Error(detail || '网格分析失败');
                        }

                        setProgress(3, '结果已返回，正在解析数据');
                        const data = await res.json();
                        const grid = data.grid || {};
                        this.h3AnalysisGridFeatures = grid.features || [];
                        this.h3GridFeatures = this.h3AnalysisGridFeatures;
                        this.h3GridCount = Number.isFinite(grid.count) ? grid.count : this.h3AnalysisGridFeatures.length;
                        this.h3AnalysisSummary = data.summary || null;
                        this.h3AnalysisCharts = data.charts || null;
                        // 分析完成后默认进入“分析”主栏，避免停留在参数页。
                        this.h3MainStage = 'analysis';
                        this.h3SubTab = this.getH3DefaultSubTabByStage('analysis');
                        this.h3ArcgisSnapshotLoadError = false;
                        this.h3ArcgisImageVersion = Date.now();
                        setProgress(4, '正在计算衍生指标');
                        this.computeH3DerivedStats();
                        setProgress(5, '正在渲染图层与图表');
                        this.renderH3BySubTab();
                        await this.$nextTick();
                        this.updateH3Charts();
                        this.updateDecisionCards();
                        this.h3GridStatus = this.h3GridCount > 0
                            ? `分析完成：${this.h3GridCount} 个网格，${(this.h3AnalysisSummary && this.h3AnalysisSummary.poi_count) || 0} 个POI`
                            : '分析完成，但当前范围无可用网格';
                    } catch (e) {
                        console.error(e);
                        this.h3GridStatus = '网格分析失败: ' + e.message;
                    } finally {
                        if (progressTimer) {
                            window.clearInterval(progressTimer);
                            progressTimer = null;
                        }
                        this.isComputingH3Analysis = false;
                    }
                },
                async generateH3ArcgisSnapshot() {
                    if (this.isComputingH3Analysis || this.isGeneratingH3ArcgisSnapshot) return;
                    if (!this.h3AnalysisGridFeatures || this.h3AnalysisGridFeatures.length === 0) {
                        this.h3GridStatus = '请先完成网格分析，再生成结构快照';
                        return;
                    }
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing) {
                        this.h3GridStatus = '当前无有效范围，无法生成结构快照';
                        return;
                    }
                    this.isGeneratingH3ArcgisSnapshot = true;
                    this.h3ArcgisSnapshotLoadError = false;
                    const startedAt = Date.now();
                    this.h3GridStatus = '正在生成 ArcGIS 结构快照...';
                    try {
                        const polygon = rawRing.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        }).filter(pt => Array.isArray(pt) && pt.length >= 2);
                        const neighborRing = Math.max(1, Math.min(3, Math.round(this._toNumber(this.h3NeighborRing, 1))));
                        const analysisPois = this._buildH3AnalysisPois();
                        if (!analysisPois.length) {
                            throw new Error('当前“分析POI”配置下无可计算样本，请先勾选至少一个有数据的POI分类');
                        }
                        const payload = {
                            polygon: polygon,
                            resolution: this.h3GridResolution,
                            coord_type: 'gcj02',
                            include_mode: this.h3GridIncludeMode,
                            min_overlap_ratio: this.h3GridIncludeMode === 'intersects' ? this.h3GridMinOverlapRatio : 0,
                            pois: analysisPois,
                            poi_coord_type: 'gcj02',
                            neighbor_ring: neighborRing,
                            use_arcgis: true,
                            arcgis_python_path: this.h3ArcgisPythonPath || null,
                            arcgis_neighbor_ring: neighborRing,
                            arcgis_export_image: true,
                            arcgis_timeout_sec: 240
                        };
                        const res = await fetch('/api/v1/analysis/h3-metrics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                const errJson = await res.json();
                                if (errJson && typeof errJson === 'object') {
                                    detail = errJson.detail || JSON.stringify(errJson);
                                } else {
                                    detail = String(errJson || '');
                                }
                            } catch (_) {
                                try { detail = await res.text(); } catch (_) { }
                            }
                            throw new Error(detail || '结构快照生成失败');
                        }
                        const data = await res.json();
                        const grid = data.grid || {};
                        if (Array.isArray(grid.features) && grid.features.length) {
                            this.h3AnalysisGridFeatures = grid.features;
                            this.h3GridFeatures = this.h3AnalysisGridFeatures;
                            this.h3GridCount = Number.isFinite(grid.count) ? grid.count : this.h3AnalysisGridFeatures.length;
                        }
                        this.h3AnalysisSummary = data.summary || this.h3AnalysisSummary;
                        this.h3AnalysisCharts = data.charts || this.h3AnalysisCharts;
                        this.computeH3DerivedStats();
                        this.renderH3BySubTab();
                        await this.$nextTick();
                        this.updateH3Charts();
                        this.updateDecisionCards();
                        this.h3ArcgisImageVersion = Date.now();
                        this.h3ArcgisSnapshotLoadError = false;
                        const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
                        this.h3GridStatus = `ArcGIS 结构快照已生成（${sec}s）`;
                    } catch (e) {
                        console.error(e);
                        this.h3GridStatus = '结构快照生成失败: ' + ((e && e.message) ? e.message : String(e));
                    } finally {
                        this.isGeneratingH3ArcgisSnapshot = false;
                    }
                },
                selectStep3Panel(panelId) {
                    if (this.isDraggingNav) return;
                    if (panelId === 'h3_settings') {
                        panelId = 'h3';
                    }
                    if (panelId === 'syntax' && !this.roadSyntaxModulesReady) {
                        this.roadSyntaxSetStatus(`路网模块未完整加载：${(this.roadSyntaxModuleMissing || []).join(', ')}`);
                        return;
                    }
                    if (!this.isStep3PanelVisible(panelId)) return;
                    const previousPanel = this.activeStep3Panel;
                    this.activeStep3Panel = panelId;
                    if (previousPanel === 'syntax' && panelId !== 'syntax') {
                        this.suspendRoadSyntaxDisplay();
                    }
                    if (panelId !== 'h3') {
                        this.h3ExportMenuOpen = false;
                        this.h3ExportTasksOpen = false;
                    }
                    if (panelId === 'poi') {
                        this.applySimplifyPointVisibility();
                        this.$nextTick(() => {
                            this.updatePoiCharts();
                            setTimeout(() => this.resizePoiChart(), 0);
                        });
                        return;
                    }
                    if (panelId === 'h3') {
                        this.syncH3PoiFilterSelection(false);
                        this.ensureH3PanelEntryState();
                        this.restoreH3GridDisplayOnEnter();
                        this.applySimplifyPointVisibility();
                        return;
                    }
                    if (panelId === 'syntax') {
                        this.setRoadSyntaxMainTab('params', { refresh: false, syncMetric: false });
                        this.resumeRoadSyntaxDisplay();
                    }
                    this.applySimplifyPointVisibility();
                },
                suspendPoiSystemForSyntax() {
                    if (this.poiSystemSuspendedForSyntax) return;
                    this.clearPoiOverlayLayers({
                        reason: 'suspend_for_syntax',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        resetFilterPanel: true,
                        immediate: true
                    });
                    this.poiSystemSuspendedForSyntax = true;
                },
                resumePoiSystemAfterSyntax() {
                    if (!this.poiSystemSuspendedForSyntax) return;
                    this.poiSystemSuspendedForSyntax = false;
                    if (!this.markerManager && Array.isArray(this.allPoisDetails) && this.allPoisDetails.length) {
                        this.updateLegacySystem(this.allPoisDetails);
                    }
                },
                onStep3DragStart(index, event) {
                    this.dragIndex = index;
                    this.dragOverIndex = index;
                    this.dragInsertPosition = 'before';
                    this.isDraggingNav = true;
                    if (event && event.dataTransfer) {
                        event.dataTransfer.effectAllowed = 'move';
                    }
                },
                onStep3DragOver(index, event) {
                    if (event) event.preventDefault();
                    this.dragOverIndex = index;
                    const bounds = event.currentTarget.getBoundingClientRect();
                    const midY = bounds.top + bounds.height / 2;
                    this.dragInsertPosition = event.clientY < midY ? 'before' : 'after';
                },
                onStep3Drop(index) {
                    if (this.dragIndex === null) {
                        this.dragOverIndex = null;
                        this.dragInsertPosition = null;
                        return;
                    }
                    const items = this.step3NavItems.slice();
                    const moved = items.splice(this.dragIndex, 1)[0];
                    let insertIndex = index;
                    if (this.dragInsertPosition === 'after') {
                        insertIndex = index + 1;
                    }
                    if (this.dragIndex < insertIndex) {
                        insertIndex -= 1;
                    }
                    items.splice(insertIndex, 0, moved);
                    this.step3NavItems = items;
                    this.dragIndex = null;
                    this.dragOverIndex = null;
                    this.dragInsertPosition = null;
                    this.isDraggingNav = false;
                },
                onStep3DragEnd() {
                    this.dragIndex = null;
                    this.dragOverIndex = null;
                    this.dragInsertPosition = null;
                    this.isDraggingNav = false;
                },
                goToStep(targetStep) {
                    this.confirmNavigation(() => {
                        if (targetStep < this.step) {
                            // Backwards navigation cleanup
                            if (this.step === 3 && targetStep <= 2) {
                                // Clear POI markers & data
                                this.clearPoiOverlayLayers({
                                    reason: 'go_to_step_back_to_step2',
                                    clearManager: true,
                                    clearSimpleMarkers: true,
                                    resetFilterPanel: true
                                });
                                this.clearAoiMarkers();
                                this.allAoisDetails = [];
                                this.aoiSamplePoints = 0;
                                this.aoiTotalCalls = 0;
                                this.resetRoadSyntaxState();

                                this.poiStatus = '';
                                this.aoiStatus = '';
                                this.clearH3Grid();
                            }

                            if (this.step >= 2 && targetStep <= 1) {
                                // Clear Isochrone Polygon
                                if (this.mapCore && this.mapCore.clearCustomPolygons) {
                                    this.mapCore.clearCustomPolygons();
                                }
                                this.clearAoiMarkers();
                                this.allAoisDetails = [];
                                this.aoiSamplePoints = 0;
                                this.aoiTotalCalls = 0;
                                this.aoiStatus = '';
                                this.resetRoadSyntaxState();
                                this.lastIsochroneGeoJSON = null;
                                this.clearH3Grid();
                            }
                        }
                        this.step = targetStep;
                    });
                },
                confirmNavigation(callback) {
                    if (this.isFetchingPois || this.isFetchingAois) {
                        if (confirm('数据抓取正在进行中，离开将取消未完成的任务。确定要离开吗？')) {
                            this.cancelFetch();
                            callback();
                        }
                    } else {
                        callback();
                    }
                },
                cancelFetch() {
                    if (this.abortController) {
                        this.abortController.abort();
                        this.abortController = null;
                    }
                    this.isFetchingPois = false;
                    this.isFetchingAois = false;
                    this.poiStatus = "任务已取消";
                    this.aoiStatus = "任务已取消";
                    this.resetFetchSubtypeProgress();
                },
                backToHome() {
                    this.confirmNavigation(() => {
                        this.destroyPlaceSearch();
                        this.clearAnalysisLayers();
                        this.sidebarView = 'start';
                        this.step = 1;
                        this.selectedPoint = null;
                        if (this.marker) {
                            this.safeMapSet(this.marker, null);
                            this.marker = null;
                        }
                        this.errorMessage = '';
                    });
                },
                loadAMapScript(key, securityCode) {
                    return new Promise((resolve, reject) => {
                        if (window.AMap && window.AMap.Map) {
                            resolve();
                            return;
                        }
                        window._AMapSecurityConfig = { securityJsCode: securityCode };
                        const script = document.createElement('script');
                        script.src = `https://webapi.amap.com/maps?v=1.4.15&key=${key}`;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                },
                async probeTiandituTile(timeoutMs = 4500) {
                    const key = (this.config && this.config.tianditu_key ? String(this.config.tianditu_key) : '').trim();
                    if (!key) {
                        return {
                            ok: false,
                            phase: 'wmts-probe',
                            status: null,
                            contentType: '',
                            bodySnippet: '',
                            reason: 'missing-key',
                            url: '',
                        };
                    }
                    const probeUrl = `https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX=7&TILEROW=53&TILECOL=107&tk=${encodeURIComponent(key)}&_ts=${Date.now()}`;
                    const controller = new AbortController();
                    const timer = window.setTimeout(() => controller.abort(), timeoutMs);
                    try {
                        const response = await fetch(probeUrl, {
                            method: 'GET',
                            cache: 'no-store',
                            signal: controller.signal,
                        });
                        const contentType = String(response.headers.get('content-type') || '').toLowerCase();
                        const isImage = this.isImageContentType(contentType);
                        let bodySnippet = '';
                        if (!isImage) {
                            try {
                                bodySnippet = this._trimText(await response.text(), 300);
                            } catch (_) {
                                bodySnippet = '';
                            }
                        }
                        const status = response.status;
                        const ok = response.ok && isImage;
                        let reason = 'ok';
                        if (!ok) {
                            if (status === 418) reason = 'http-418';
                            else if (status >= 500) reason = 'http-5xx';
                            else if (status >= 400) reason = 'http-4xx';
                            else if (response.ok) reason = 'non-image-response';
                            else reason = 'http-error';
                        }
                        return {
                            ok: ok,
                            phase: 'wmts-probe',
                            status: status,
                            contentType: contentType,
                            bodySnippet: bodySnippet,
                            reason: reason,
                            url: probeUrl,
                        };
                    } catch (e) {
                        if (e && e.name === 'AbortError') {
                            return {
                                ok: false,
                                phase: 'wmts-probe',
                                status: null,
                                contentType: '',
                                bodySnippet: '',
                                reason: 'timeout',
                                url: probeUrl,
                            };
                        }
                        return {
                            ok: false,
                            phase: 'wmts-probe',
                            status: null,
                            contentType: '',
                            bodySnippet: this._trimText(e && e.message ? e.message : String(e), 300),
                            reason: 'network-error',
                            url: probeUrl,
                        };
                    } finally {
                        window.clearTimeout(timer);
                    }
                },
                async validateTiandituSource() {
                    const result = await this.probeTiandituTile();
                    this.tdtDiag = result;
                    this.tdtDiagCopyStatus = '';
                    if (result.ok) {
                        if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                            this.errorMessage = '';
                        }
                        return true;
                    }
                    if (result.reason === 'missing-key') {
                        this.errorMessage = '未配置天地图 Key（TIANDITU_KEY）。';
                    } else if (result.reason === 'timeout') {
                        this.errorMessage = '天地图 WMTS 探测超时，请稍后重试（配置修改可能需要 5-10 分钟生效）。';
                    } else if (result.reason === 'http-418') {
                        this.errorMessage = '天地图 WMTS 探测被拦截（HTTP 418），请检查 Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                    } else {
                        this.errorMessage = `天地图 WMTS 探测失败（${result.status || 'NO_STATUS'}），请检查 Key 与白名单。`;
                    }
                    return false;
                },
                isImageContentType(contentType) {
                    const ct = String(contentType || '').toLowerCase();
                    return ct.indexOf('image/') >= 0 || ct.indexOf('application/octet-stream') >= 0;
                },
                _trimText(value, maxLen = 300) {
                    const text = String(value || '');
                    if (text.length <= maxLen) return text;
                    return text.slice(0, maxLen) + '...';
                },
                buildTdtDiagText() {
                    if (!this.tdtDiag) return '';
                    const rows = [
                        `ok=${this.tdtDiag.ok}`,
                        `phase=${this.tdtDiag.phase || '-'}`,
                        `reason=${this.tdtDiag.reason || '-'}`,
                        `status=${this.tdtDiag.status === null || this.tdtDiag.status === undefined ? '-' : this.tdtDiag.status}`,
                        `contentType=${this.tdtDiag.contentType || '-'}`,
                    ];
                    if (this.tdtDiag.url) rows.push(`url=${this.tdtDiag.url}`);
                    if (this.tdtDiag.bodySnippet) rows.push(`body=${this.tdtDiag.bodySnippet}`);
                    return rows.join('\n');
                },
                async copyTdtDiag() {
                    const text = this.buildTdtDiagText();
                    if (!text) {
                        this.tdtDiagCopyStatus = '无可复制内容';
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(text);
                        this.tdtDiagCopyStatus = '已复制';
                    } catch (e) {
                        console.error(e);
                        this.tdtDiagCopyStatus = '复制失败，请手动复制';
                    }
                },
                initMap() {
                    const markRaw = (window.Vue && typeof window.Vue.markRaw === 'function')
                        ? window.Vue.markRaw
                        : (value) => value;
                    const mapCore = new MapCore('container', {
                        center: { lng: 112.9388, lat: 28.2282 },
                        zoom: 13,
                        zooms: [3, 20],
                        mapData: {},
                        basemapSource: this.basemapSource,
                        basemapMuted: false,
                        tiandituKey: this.config ? this.config.tianditu_key : '',
                        tiandituContainerId: 'tianditu-container',
                        onGridFeatureClick: (payload) => this.onH3GridFeatureClick(payload)
                    });
                    mapCore.initMap();
                    this.mapCore = markRaw(mapCore);
                    this.pointSimplifyEnabled = !!(this.pointSimplifyEnabled || this.h3BasemapMuted);
                    this.h3BasemapMuted = this.pointSimplifyEnabled;
                    this.applySimplifyBasemapStyle();
                    this.applySimplifyPointVisibility();
                    if (this.basemapSource === 'tianditu' && mapCore.lastBasemapError) {
                        this.tdtDiag = {
                            ok: false,
                            phase: 'map-init',
                            status: null,
                            contentType: '',
                            bodySnippet: mapCore.lastBasemapError.message || '',
                            reason: mapCore.lastBasemapError.code || 'wmts-layer-init-failed',
                        };
                        this.errorMessage = '天地图 WMTS 图层初始化失败，请检查：Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                    }

                    mapCore.map.on('click', (e) => {
                        // Limit marker adjustment to Step 1 in Wizard mode
                        if (this.sidebarView !== 'wizard' || this.step !== 1) return;
                        this.setSelectedPoint(e.lnglat);
                    });
                    this.roadSyntaxAttachMapListeners();
                },
                isRoadSyntaxPanelActive() {
                    return this.activeStep3Panel === 'syntax';
                },
                isRoadSyntaxMetricViewActive() {
                    return this.isRoadSyntaxPanelActive() && this.roadSyntaxMainTab !== 'params';
                },
                roadSyntaxAttachMapListeners() {
                    const map = this.mapCore && this.mapCore.map ? this.mapCore.map : null;
                    if (!map) return;
                    this.roadSyntaxDetachMapListeners();
                    this.roadSyntaxZoomStartListener = () => {
                        this.roadSyntaxMapInteracting = true;
                        if (this.isRoadSyntaxMetricViewActive()) {
                            this.roadSyntaxEnterLowFidelityMode();
                        }
                    };
                    this.roadSyntaxMoveStartListener = () => {
                        this.roadSyntaxMapInteracting = true;
                        if (this.isRoadSyntaxMetricViewActive()) {
                            this.roadSyntaxEnterLowFidelityMode();
                        }
                    };
                    this.roadSyntaxMoveEndListener = () => {
                        this.roadSyntaxMapInteracting = false;
                        if (this.isRoadSyntaxMetricViewActive()) {
                            this.scheduleRoadSyntaxViewportRefresh('moveend');
                            this.roadSyntaxLogOverlayHealth('moveend');
                        }
                        if (this.markerManager && typeof this.markerManager.logCoordinateHealth === 'function') {
                            this.markerManager.logCoordinateHealth('road-syntax:moveend');
                        }
                    };
                    this.roadSyntaxZoomListener = () => {
                        this.roadSyntaxMapInteracting = false;
                        if (this.isRoadSyntaxMetricViewActive()) {
                            this.scheduleRoadSyntaxViewportRefresh('zoomend');
                            this.roadSyntaxLogOverlayHealth('zoomend');
                        }
                        if (this.markerManager && typeof this.markerManager.logCoordinateHealth === 'function') {
                            this.markerManager.logCoordinateHealth('road-syntax:zoomend');
                        }
                    };
                    map.on('zoomstart', this.roadSyntaxZoomStartListener);
                    map.on('movestart', this.roadSyntaxMoveStartListener);
                    map.on('moveend', this.roadSyntaxMoveEndListener);
                    map.on('zoomend', this.roadSyntaxZoomListener);
                },
                roadSyntaxDetachMapListeners() {
                    const map = this.mapCore && this.mapCore.map ? this.mapCore.map : null;
                    if (map && this.roadSyntaxZoomListener) {
                        try { map.off('zoomend', this.roadSyntaxZoomListener); } catch (_) { }
                    }
                    if (map && this.roadSyntaxZoomStartListener) {
                        try { map.off('zoomstart', this.roadSyntaxZoomStartListener); } catch (_) { }
                    }
                    if (map && this.roadSyntaxMoveStartListener) {
                        try { map.off('movestart', this.roadSyntaxMoveStartListener); } catch (_) { }
                    }
                    if (map && this.roadSyntaxMoveEndListener) {
                        try { map.off('moveend', this.roadSyntaxMoveEndListener); } catch (_) { }
                    }
                    this.roadSyntaxZoomListener = null;
                    this.roadSyntaxZoomStartListener = null;
                    this.roadSyntaxMoveStartListener = null;
                    this.roadSyntaxMoveEndListener = null;
                },
                destroyPlaceSearch() {
                    this.placeSearchBuildToken += 1;
                    if (this.placeSearchErrorListener && window.AMap && AMap.event && typeof AMap.event.removeListener === 'function') {
                        try {
                            AMap.event.removeListener(this.placeSearchErrorListener);
                        } catch (_) { }
                    }
                    this.placeSearchErrorListener = null;
                    this.placeSearch = null;
                    this.placeSearchLoadingPromise = null;
                },
                async ensurePlaceSearchReady(timeoutMs = 3000) {
                    if (this.step !== 1) {
                        return { ok: false, reason: 'step' };
                    }
                    if (this.placeSearch && typeof this.placeSearch.search === 'function') {
                        return { ok: true, cached: true };
                    }
                    if (!window.AMap || typeof AMap.plugin !== 'function') {
                        return { ok: false, reason: 'amap-not-ready' };
                    }
                    if (this.placeSearchLoadingPromise) {
                        return this.placeSearchLoadingPromise;
                    }
                    const buildToken = this.placeSearchBuildToken + 1;
                    this.placeSearchBuildToken = buildToken;
                    const startAt = Date.now();
                    const timeoutPromise = new Promise((resolve) => {
                        window.setTimeout(() => resolve({ ok: false, reason: 'timeout' }), Math.max(800, Number(timeoutMs) || 3000));
                    });
                    const initPromise = new Promise((resolve) => {
                        try {
                            AMap.plugin(['AMap.PlaceSearch'], () => {
                                try {
                                    if (buildToken !== this.placeSearchBuildToken || this.step !== 1) {
                                        resolve({ ok: false, reason: 'stale-request' });
                                        return;
                                    }
                                    const placeSearch = new AMap.PlaceSearch({
                                        pageSize: 10,
                                        autoFitView: false,
                                    });
                                    this.placeSearch = placeSearch;
                                    this.placeSearchErrorListener = AMap.event.addListener(placeSearch, 'error', (e) => {
                                        console.error('PlaceSearch error', e);
                                    });
                                    resolve({ ok: true, createdAt: Date.now() });
                                } catch (e) {
                                    console.error('PlaceSearch init error', e);
                                    resolve({ ok: false, reason: 'init-failed' });
                                }
                            });
                        } catch (e) {
                            console.error('AMap.plugin PlaceSearch failed', e);
                            resolve({ ok: false, reason: 'plugin-failed' });
                        }
                    });
                    this.placeSearchLoadingPromise = Promise.race([initPromise, timeoutPromise])
                        .then((result) => {
                            if (!result || !result.ok) {
                                this.destroyPlaceSearch();
                            }
                            if (result && result.ok) {
                                console.info('[place-search] ready', { ms: Date.now() - startAt });
                            } else {
                                console.warn('[place-search] unavailable', result);
                            }
                            return result || { ok: false, reason: 'unknown' };
                        })
                        .finally(() => {
                            this.placeSearchLoadingPromise = null;
                        });
                    return this.placeSearchLoadingPromise;
                },
                extractSearchPois(result) {
                    const list = result && result.poiList && Array.isArray(result.poiList.pois)
                        ? result.poiList.pois
                        : [];
                    return list.filter((poi) => poi && poi.location);
                },
                runPlaceSearch(keyword) {
                    return new Promise((resolve) => {
                        if (!this.placeSearch || typeof this.placeSearch.search !== 'function') {
                            resolve({ ok: false, pois: [], status: 'error', raw: null, serviceError: true, errorInfo: '' });
                            return;
                        }
                        const query = (typeof keyword === 'string' ? keyword : String(keyword || '')).trim();
                        if (!query) {
                            resolve({ ok: false, pois: [], status: 'empty', raw: null, serviceError: false, errorInfo: '' });
                            return;
                        }

                        try {
                            this.placeSearch.search(query, (status, result) => {
                                const pois = this.extractSearchPois(result);
                                const errorInfo = String((result && result.info) || '');
                                resolve({
                                    ok: status === 'complete',
                                    pois: pois,
                                    status: status || '',
                                    raw: result || null,
                                    serviceError: status === 'error',
                                    errorInfo: errorInfo
                                });
                            });
                        } catch (e) {
                            console.error('placeSearch.search error', e);
                            resolve({ ok: false, pois: [], status: 'error', raw: null, serviceError: true, errorInfo: '' });
                        }
                    });
                },
                resolveCurrentSearchCity() {
                    return new Promise((resolve) => {
                        const map = this.mapCore && this.mapCore.map;
                        if (!map || typeof map.getCity !== 'function') {
                            resolve({ city: '', citycode: '' });
                            return;
                        }

                        let settled = false;
                        const done = (value) => {
                            if (settled) return;
                            settled = true;
                            const payload = value && typeof value === 'object' ? value : {};
                            resolve({
                                city: String(payload.city || payload.province || '').trim(),
                                citycode: String(payload.citycode || '').trim()
                            });
                        };

                        const timer = setTimeout(() => done({}), 1200);
                        try {
                            map.getCity((info) => {
                                clearTimeout(timer);
                                if (!info || info.info === 'FAILED') {
                                    done({});
                                    return;
                                }
                                done(info);
                            });
                        } catch (e) {
                            clearTimeout(timer);
                            console.warn('map.getCity failed', e);
                            done({});
                        }
                    });
                },
                setSelectedPoint(lnglat) {
                    if (!lnglat) return;
                    const lng = (typeof lnglat.lng === 'number')
                        ? lnglat.lng
                        : (typeof lnglat.getLng === 'function' ? lnglat.getLng() : NaN);
                    const lat = (typeof lnglat.lat === 'number')
                        ? lnglat.lat
                        : (typeof lnglat.getLat === 'function' ? lnglat.getLat() : NaN);
                    if (!Number.isFinite(lng) || !Number.isFinite(lat)) return;

                    this.selectedPoint = { lng, lat };
                    if (this.mapCore) {
                        this.mapCore.center = { lng, lat };
                    }
                    this.errorMessage = '';
                    const markerPos = (window.AMap && typeof AMap.LngLat === 'function')
                        ? new AMap.LngLat(lng, lat)
                        : [lng, lat];
                    if (this.marker) {
                        this.marker.setPosition(markerPos);
                        return;
                    }
                    if (!this.mapCore || !this.mapCore.map) return;
                    const markRaw = (window.Vue && typeof window.Vue.markRaw === 'function')
                        ? window.Vue.markRaw
                        : (value) => value;
                    this.marker = markRaw(new AMap.Marker({ position: markerPos }));
                    this.mapCore.map.add(this.marker);
                },
                resolveMapCenterTarget() {
                    if (this.selectedPoint && Number.isFinite(Number(this.selectedPoint.lng)) && Number.isFinite(Number(this.selectedPoint.lat))) {
                        return [Number(this.selectedPoint.lng), Number(this.selectedPoint.lat)];
                    }
                    const polygon = this.getIsochronePolygonPoints();
                    if (Array.isArray(polygon) && polygon.length >= 3) {
                        let minLng = Infinity;
                        let minLat = Infinity;
                        let maxLng = -Infinity;
                        let maxLat = -Infinity;
                        polygon.forEach((pt) => {
                            if (!Array.isArray(pt) || pt.length < 2) return;
                            const lng = Number(pt[0]);
                            const lat = Number(pt[1]);
                            if (!Number.isFinite(lng) || !Number.isFinite(lat)) return;
                            if (lng < minLng) minLng = lng;
                            if (lat < minLat) minLat = lat;
                            if (lng > maxLng) maxLng = lng;
                            if (lat > maxLat) maxLat = lat;
                        });
                        if (Number.isFinite(minLng) && Number.isFinite(minLat) && Number.isFinite(maxLng) && Number.isFinite(maxLat)) {
                            return [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
                        }
                    }
                    const center = this.mapCore && this.mapCore.center ? this.mapCore.center : null;
                    if (center && Number.isFinite(Number(center.lng)) && Number.isFinite(Number(center.lat))) {
                        return [Number(center.lng), Number(center.lat)];
                    }
                    return [112.9388, 28.2282];
                },
                goMapBackToCenter() {
                    const map = this.mapCore && this.mapCore.map ? this.mapCore.map : null;
                    if (!map) return;
                    const target = this.resolveMapCenterTarget();
                    const currentZoom = Number(map.getZoom ? map.getZoom() : NaN);
                    if (typeof map.setZoomAndCenter === 'function' && Number.isFinite(currentZoom)) {
                        map.setZoomAndCenter(currentZoom, target);
                        return;
                    }
                    if (typeof map.setCenter === 'function') {
                        map.setCenter(target);
                    }
                },
                onCaptureTargetChange(target) {
                    const next = target === 'aoi' ? 'aoi' : 'poi';
                    this.captureTarget = next;
                    this.poiStatus = '';
                    this.aoiStatus = '';
                    this.fetchProgress = 0;
                    if (this.step === 3) {
                        this.activeStep3Panel = next === 'aoi' ? 'aoi' : 'poi';
                    }
                },
                isStep3PanelVisible(panelId) {
                    if (panelId === 'syntax' && !this.roadSyntaxModulesReady) {
                        return false;
                    }
                    if (this.captureTarget === 'aoi') {
                        return panelId === 'aoi' || panelId === 'syntax';
                    }
                    return panelId !== 'aoi';
                },
                step2StatusText() {
                    return this.captureTarget === 'aoi' ? this.aoiStatus : this.poiStatus;
                },
                getIsochronePolygonPoints() {
                    if (!this.lastIsochroneGeoJSON || !this.lastIsochroneGeoJSON.geometry) return [];
                    const geometry = this.lastIsochroneGeoJSON.geometry;
                    const rawPoly = (geometry.type === 'Polygon')
                        ? geometry.coordinates[0]
                        : (geometry.coordinates[0] ? geometry.coordinates[0][0] : []);
                    return (rawPoly || []).map((pt) => {
                        if (Array.isArray(pt)) return [pt[0], pt[1]];
                        if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                        return pt;
                    }).filter((pt) => Array.isArray(pt) && pt.length >= 2);
                },
                async fetchStep2Data() {
                    if (this.captureTarget === 'aoi') {
                        await this.fetchAois();
                        return;
                    }
                    await this.fetchPois();
                },
                async startAnalysis() {
                    if (!this.selectedPoint || this.isCalculating) return;
                    this.isCalculating = true;
                    this.errorMessage = '';
                    this.fetchProgress = 0;
                    this.poiStatus = '';
                    this.aoiStatus = '';
                    this.allAoisDetails = [];
                    this.aoiSamplePoints = 0;
                    this.aoiTotalCalls = 0;
                    this.clearAoiMarkers();
                    this.roadSyntaxMode = this.transportMode || 'walking';
                    this.resetRoadSyntaxState();

                    try {
                        const payload = {
                            lat: this.selectedPoint.lat,
                            lon: this.selectedPoint.lng,
                            time_min: parseInt(this.timeHorizon),
                            mode: this.transportMode,
                            coord_type: 'gcj02'
                        };

                        const res = await fetch('/api/v1/analysis/isochrone', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!res.ok) throw new Error("API 请求失败");
                        const geojson = await res.json();

                        this.clearH3Grid();
                        this.lastIsochroneGeoJSON = geojson;
                        this.renderResult(geojson);
                        this.step = 2; // Advance to Step 2
                        this.activeStep3Panel = this.captureTarget === 'aoi' ? 'aoi' : 'poi';

                    } catch (e) {
                        console.error(e);
                        this.errorMessage = "计算失败: " + e.message;
                    } finally {
                        this.isCalculating = false;
                    }
                },
                async fetchPois() {
                    if (!this.lastIsochroneGeoJSON) return;
                    this.isFetchingPois = true;
                    this.fetchProgress = 0;
                    this.poiStatus = "准备抓取...";
                    this.aoiStatus = '';
                    this.allAoisDetails = [];
                    this.aoiSamplePoints = 0;
                    this.aoiTotalCalls = 0;
                    this.clearAoiMarkers();
                    this.resetRoadSyntaxState();
                    this.resetFetchSubtypeProgress();

                    this.clearPoiOverlayLayers({
                        reason: 'fetch_pois_start',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        resetFilterPanel: true
                    });
                    this.allPoisDetails = [];

                    try {
                        const polygon = this.getIsochronePolygonPoints();

                        // Get selected categories (derived from selected subtypes).
                        const selectedCats = this.buildSelectedCategoryBuckets();
                        if (selectedCats.length === 0) {
                            alert("请至少选择一个分类");
                            this.isFetchingPois = false;
                            return;
                        }

                        let totalFetched = 0;
                        const totalCats = selectedCats.length;
                        if (selectedCats[0]) {
                            this.updateFetchSubtypeProgressDisplay(selectedCats[0]);
                        }

                        // Parallel Fetching: process in batches.
                        this.abortController = new AbortController();
                        const batchSize = 4;
                        this.poiStatus = `正在并行抓取 ${totalCats} 个分类（每批 ${batchSize} 个）...`;

                        const fetchOneCategory = async (cat) => {
                            const payload = {
                                polygon: polygon,
                                keywords: "",
                                types: String(cat.types || ''),
                                save_history: false, // Don't save individual batches
                                center: [this.selectedPoint.lng, this.selectedPoint.lat],
                                time_min: parseInt(this.timeHorizon),
                                mode: this.transportMode,
                                location_name: this.selectedPoint.name || (this.selectedPoint.lng.toFixed(4) + ',' + this.selectedPoint.lat.toFixed(4))
                            };

                            try {
                                const res = await fetch('/api/v1/analysis/pois', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(payload),
                                    signal: this.abortController.signal
                                });

                                if (res.ok) {
                                    const data = await res.json();
                                    return data.pois || [];
                                }
                            } catch (err) {
                                if (err.name !== 'AbortError') {
                                    console.warn(`Failed to fetch category ${cat.name}`, err);
                                }
                            }
                            return [];
                        };

                        for (let i = 0; i < selectedCats.length; i += batchSize) {
                            if (this.abortController.signal.aborted) return;
                            const batch = selectedCats.slice(i, i + batchSize);
                            const resultsArray = await Promise.all(batch.map(fetchOneCategory));
                            resultsArray.forEach((list, index) => {
                                if (list && list.length) this.allPoisDetails.push(...list);
                                const cat = batch[index];
                                if (cat) {
                                    this.accumulateFetchSubtypeHits(cat, list || []);
                                }
                            });

                            totalFetched = this.allPoisDetails.length;
                            const done = Math.min(i + batch.length, totalCats);
                            this.fetchProgress = Math.round((done / totalCats) * 100);
                            this.poiStatus = `已完成 ${done}/${totalCats} 分类，累计 ${totalFetched} 个结果`;
                        }

                        if (this.abortController.signal.aborted) return;

                        this.fetchProgress = 100;
                        this.poiStatus = `完成！共找到 ${totalFetched} 个结果`;

                        // Integration with Legacy Filter Panel (single render path).
                        this.updateLegacySystem(this.allPoisDetails);

                        setTimeout(() => {
                            this.step = 3; // Advance to Step 3 after short delay to see 100%
                            this.activeStep3Panel = 'poi';
                            this.updatePoiCharts();
                            this.resizePoiChart();
                        }, 120);
                        this.saveAnalysisHistoryAsync(polygon, selectedCats, this.allPoisDetails);

                    } catch (e) {
                        if (e.name !== 'AbortError') {
                            console.error(e);
                            this.poiStatus = "失败: " + e.message;
                        }
                    } finally {
                        this.isFetchingPois = false;
                        this.abortController = null;
                        this.resetFetchSubtypeProgress();
                    }
                },
                roadSyntaxMap() {
                    return (this.mapCore && this.mapCore.map) ? this.mapCore.map : null;
                },
                roadSyntaxQuantizeChannel(value, step = 24) {
                    const safe = Number.isFinite(Number(value)) ? Number(value) : 0;
                    const safeStep = Math.max(1, Number(step) || 1);
                    return Math.max(0, Math.min(255, Math.round(safe / safeStep) * safeStep));
                },
                roadSyntaxQuantizeHexColor(color = '', step = 24) {
                    const raw = String(color || '').trim();
                    const hex = raw.startsWith('#') ? raw.slice(1) : raw;
                    if (!/^[0-9a-fA-F]{6}$/.test(hex)) return '#9ca3af';
                    const r = this.roadSyntaxQuantizeChannel(parseInt(hex.slice(0, 2), 16), step);
                    const g = this.roadSyntaxQuantizeChannel(parseInt(hex.slice(2, 4), 16), step);
                    const b = this.roadSyntaxQuantizeChannel(parseInt(hex.slice(4, 6), 16), step);
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                },
                roadSyntaxNormalizeLayerStyleForBucket(style = null) {
                    const raw = style || {};
                    const colorStep = Math.max(1, Number(this.roadSyntaxStyleBucketColorStep || 24));
                    const weightStep = Math.max(0.1, Number(this.roadSyntaxStyleBucketWeightStep || 0.5));
                    const opacityStep = Math.max(0.02, Number(this.roadSyntaxStyleBucketOpacityStep || 0.08));
                    const strokeWeightRaw = Number(raw.strokeWeight);
                    const strokeOpacityRaw = Number(raw.strokeOpacity);
                    const zIndexRaw = Number(raw.zIndex);
                    return {
                        strokeColor: this.roadSyntaxQuantizeHexColor(raw.strokeColor || '#9ca3af', colorStep),
                        strokeWeight: Math.max(1, Math.round((Number.isFinite(strokeWeightRaw) ? strokeWeightRaw : 1.8) / weightStep) * weightStep),
                        strokeOpacity: Math.max(0.08, Math.min(1, Math.round((Number.isFinite(strokeOpacityRaw) ? strokeOpacityRaw : 0.32) / opacityStep) * opacityStep)),
                        zIndex: Number.isFinite(zIndexRaw) ? Math.round(zIndexRaw) : 90,
                    };
                },
                roadSyntaxBuildLayerStyleBucketKey(style = null) {
                    const s = this.roadSyntaxNormalizeLayerStyleForBucket(style);
                    return `${s.strokeColor}|${s.strokeWeight}|${s.strokeOpacity}|${s.zIndex}`;
                },
                roadSyntaxCloneIndexSet(setLike = null) {
                    const out = {};
                    const source = setLike && typeof setLike === 'object' ? setLike : {};
                    Object.keys(source).forEach((key) => {
                        const idx = Number(key);
                        if (!Number.isFinite(idx) || idx < 0) return;
                        out[idx] = true;
                    });
                    return out;
                },
                roadSyntaxBuildLayerLodIndexSet(layerKey = '') {
                    const key = String(layerKey || '');
                    const cache = Object.assign({}, this.roadSyntaxLayerLodIndexCache || {});
                    if (cache[key]) {
                        return this.roadSyntaxCloneIndexSet(cache[key]);
                    }
                    const items = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems : [];
                    if (!items.length) return {};

                    const parsed = this.parseRoadSyntaxLayerKey(key);
                    const metric = parsed.metric || this.resolveRoadSyntaxActiveMetric();
                    const radiusLabel = parsed.radiusLabel || 'global';
                    const metricField = this.resolveRoadSyntaxMetricField(metric, radiusLabel);
                    const fallbackField = this.resolveRoadSyntaxFallbackField(metric);
                    const rankField = this.resolveRoadSyntaxRankField(metric);
                    const scored = [];
                    for (let idx = 0; idx < items.length; idx += 1) {
                        const item = items[idx] || {};
                        const coords = Array.isArray(item.coords) ? item.coords : [];
                        if (coords.length < 2) continue;
                        const props = item.props || {};
                        const rank = Number(rankField ? props[rankField] : NaN);
                        const mainScore = Number(props[metricField]);
                        const fallbackScore = Number(props[fallbackField]);
                        const score = Number.isFinite(rank)
                            ? this.clamp01(rank)
                            : (Number.isFinite(mainScore)
                                ? this.clamp01(mainScore)
                                : (Number.isFinite(fallbackScore) ? this.clamp01(fallbackScore) : 0));
                        scored.push({ idx, score });
                    }
                    if (!scored.length) return {};
                    scored.sort((a, b) => (b.score - a.score) || (a.idx - b.idx));

                    const cap = Math.max(80, Math.floor(Number(this.roadSyntaxLayerLodCap || 180)));
                    const selected = [];
                    if (scored.length <= cap) {
                        scored.forEach((it) => selected.push(it.idx));
                    } else {
                        const headCount = Math.max(1, Math.min(cap, Math.floor(cap * 0.75)));
                        for (let i = 0; i < headCount; i += 1) {
                            selected.push(scored[i].idx);
                        }
                        const remain = cap - selected.length;
                        if (remain > 0) {
                            const tail = scored.slice(headCount);
                            const step = tail.length / remain;
                            for (let i = 0; i < remain; i += 1) {
                                const pickIdx = Math.min(tail.length - 1, Math.floor(i * step));
                                selected.push(tail[pickIdx].idx);
                            }
                        }
                    }
                    const out = {};
                    selected.forEach((idx) => {
                        const n = Number(idx);
                        if (!Number.isFinite(n) || n < 0) return;
                        out[n] = true;
                    });
                    cache[key] = out;
                    this.roadSyntaxLayerLodIndexCache = cache;
                    return this.roadSyntaxCloneIndexSet(out);
                },
                roadSyntaxResolveDesiredLayerVariant() {
                    const total = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems.length : 0;
                    if (!total) return 'full';
                    if (typeof this.roadSyntaxResolveLodPolicy !== 'function') return 'full';
                    const policy = this.roadSyntaxResolveLodPolicy(total);
                    return (policy && policy.backboneOnly) ? 'lod' : 'full';
                },
                roadSyntaxResolveLayerRuntimeEntry(layer = null, variant = 'full') {
                    const requested = String(variant || 'full');
                    const base = layer && typeof layer === 'object' ? layer : null;
                    if (!base) return null;
                    if (requested === 'lod' && base.lodLayer && Array.isArray(base.lodLayer.overlays) && base.lodLayer.overlays.length) {
                        return base.lodLayer;
                    }
                    return base;
                },
                roadSyntaxApplyVisibleIndexSet(indexSet = {}, reason = '') {
                    const normalized = this.roadSyntaxCloneIndexSet(indexSet);
                    this.roadSyntaxTargetVisibleLineSet = Object.assign({}, normalized);
                    this.roadSyntaxAppliedVisibleLineSet = Object.assign({}, normalized);
                    this.roadSyntaxOverlayCommitToken = Number(this.roadSyntaxOverlayCommitToken || 0) + 1;
                    this.roadSyntaxOverlayLastCommitPath = 'pool_state_apply';
                    this.roadSyntaxOverlayLastCommitReason = String(reason || 'switch');
                },
                roadSyntaxDisposeLayerEntry(layer = null, mapRef = null) {
                    if (!layer) return;
                    const map = mapRef || this.roadSyntaxMap();
                    if (layer.overlayGroup) {
                        this.roadSyntaxSetOverlayGroupVisible(layer.overlayGroup, false, map);
                    }
                    const overlays = Array.isArray(layer.overlays) ? layer.overlays : [];
                    if (overlays.length) {
                        this.roadSyntaxSetLinesVisible(overlays, false, map, { preferBatch: true });
                    }
                    if (layer.lodLayer) {
                        this.roadSyntaxDisposeLayerEntry(layer.lodLayer, map);
                    }
                },
                roadSyntaxBuildLayerFromStyles(layerKey = '', styles = [], options = {}) {
                    const markRaw = (window.Vue && typeof window.Vue.markRaw === 'function')
                        ? window.Vue.markRaw
                        : (value) => value;
                    const items = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems : [];
                    const includeIndexSet = (options && options.includeIndexSet && typeof options.includeIndexSet === 'object')
                        ? options.includeIndexSet
                        : null;
                    const variant = String((options && options.variant) || 'full');
                    const zIndexBoost = Number((options && options.zIndexBoost) || 0);
                    const buckets = Object.create(null);
                    let featureCount = 0;
                    const indexSet = {};
                    let invalidPathCount = 0;
                    let polylineCreateErrorCount = 0;
                    const invalidPathSamples = [];
                    for (let idx = 0; idx < items.length; idx += 1) {
                        if (includeIndexSet && !includeIndexSet[idx]) continue;
                        const item = items[idx] || {};
                        const coords = Array.isArray(item.coords) ? item.coords : [];
                        if (coords.length < 2) continue;
                        featureCount += 1;
                        indexSet[idx] = true;
                        const rawStyle = this.roadSyntaxNormalizeLayerStyleForBucket(styles[idx] || null);
                        const style = zIndexBoost
                            ? Object.assign({}, rawStyle, { zIndex: (Number(rawStyle.zIndex) || 90) + zIndexBoost })
                            : rawStyle;
                        const bucketKey = this.roadSyntaxBuildLayerStyleBucketKey(style);
                        if (!buckets[bucketKey]) {
                            buckets[bucketKey] = { style, paths: [] };
                        }
                        buckets[bucketKey].paths.push(coords);
                    }
                    const overlays = [];
                    const bucketValues = Object.values(buckets);
                    bucketValues.forEach((bucket) => {
                        const style = bucket.style || {};
                        const pathsRaw = Array.isArray(bucket.paths) ? bucket.paths : [];
                        if (!pathsRaw.length || !window.AMap) return;
                        const safePaths = [];
                        pathsRaw.forEach((path, pIdx) => {
                            const safePath = this.normalizePath(path, 2, 'road_syntax.layer_build.path');
                            if (!safePath.length) {
                                invalidPathCount += 1;
                                if (invalidPathSamples.length < 5) {
                                    invalidPathSamples.push({
                                        layer_key: String(layerKey || ''),
                                        variant: String(variant || ''),
                                        path_index: pIdx,
                                        sample: this.roadSyntaxSummarizeCoordInput(Array.isArray(path) ? path[0] : path)
                                    });
                                }
                                return;
                            }
                            safePaths.push(safePath);
                        });
                        if (!safePaths.length) return;
                        safePaths.forEach((safePath) => {
                            try {
                                const line = markRaw(new AMap.Polyline({
                                    path: safePath,
                                    strokeColor: style.strokeColor || '#9ca3af',
                                    strokeWeight: Number(style.strokeWeight) || 1.8,
                                    strokeOpacity: Number(style.strokeOpacity) || 0.32,
                                    zIndex: Number(style.zIndex) || 90,
                                    bubble: true,
                                    clickable: false,
                                    cursor: 'default',
                                }));
                                overlays.push(line);
                            } catch (_) {
                                polylineCreateErrorCount += 1;
                            }
                        });
                    });
                    if (invalidPathCount > 0 || polylineCreateErrorCount > 0) {
                        console.warn('[road-syntax] layer build skipped invalid paths', {
                            layer_key: String(layerKey || ''),
                            variant: String(variant || ''),
                            invalid_path_count: invalidPathCount,
                            polyline_create_error_count: polylineCreateErrorCount,
                            sample_paths: invalidPathSamples
                        });
                    }
                    let overlayGroup = null;
                    try {
                        if (window.AMap && typeof AMap.OverlayGroup === 'function' && overlays.length) {
                            overlayGroup = markRaw(new AMap.OverlayGroup(overlays));
                        }
                    } catch (_) {
                        overlayGroup = null;
                    }
                    return {
                        layerKey: String(layerKey || ''),
                        mode: 'bucket_pool',
                        variant: variant,
                        overlays,
                        overlayGroup,
                        bucketCount: bucketValues.length,
                        featureCount,
                        indexSet,
                    };
                },
                roadSyntaxHasCache() {
                    if (Array.isArray(this.roadSyntaxPolylines) && this.roadSyntaxPolylines.length) return true;
                    const pool = this.roadSyntaxLayerPool || {};
                    if (Object.keys(pool).length > 0) return true;
                    const styleCache = this.roadSyntaxLayerStyleCache || {};
                    return Object.keys(styleCache).length > 0;
                },
                roadSyntaxGetLayer(layerKey = '') {
                    const pool = this.roadSyntaxLayerPool || {};
                    const key = String(layerKey || '');
                    return key ? (pool[key] || null) : null;
                },
                roadSyntaxSetStatus(text = '') {
                    this.roadSyntaxStatus = String(text || '');
                },
                roadSyntaxUseLegacyPoolStatus() {
                    return false;
                },
                roadSyntaxLogOverlayHealth(reason = '', options = {}) {
                    const force = !!(options && options.force);
                    const throttleMs = Math.max(0, Number((options && options.throttleMs) || 1200));
                    const now = this.roadSyntaxNow();
                    const lastAt = Number(this._roadSyntaxOverlayHealthLastAt || 0);
                    if (!force && (now - lastAt) < throttleMs) {
                        return null;
                    }
                    this._roadSyntaxOverlayHealthLastAt = now;
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && this.roadSyntaxWebglActive
                        && this.roadSyntaxWebglPayload
                    ) {
                        const webglCount = Number((((this.roadSyntaxWebglPayload || {}).roads || {}).count) || 0);
                        if (force || webglCount <= 0) {
                            console.info('[road-syntax] overlay pool health', {
                                reason: String(reason || ''),
                                active_layer: String(this.roadSyntaxActiveLayerKey || ''),
                                visible_lines: webglCount,
                                applied_visible_lines: webglCount,
                                target_visible_lines: webglCount,
                                total_lines: webglCount,
                                mode: 'arcgis_webgl',
                            });
                        }
                        return {
                            inspectedLines: webglCount,
                            visibleLines: webglCount,
                            invalid: { path: 0, endpoint: 0, line: 0 },
                            totalLines: webglCount,
                        };
                    }
                    const appliedSet = (this.roadSyntaxAppliedVisibleLineSet && typeof this.roadSyntaxAppliedVisibleLineSet === 'object')
                        ? this.roadSyntaxAppliedVisibleLineSet
                        : {};
                    const targetSet = (this.roadSyntaxTargetVisibleLineSet && typeof this.roadSyntaxTargetVisibleLineSet === 'object')
                        ? this.roadSyntaxTargetVisibleLineSet
                        : {};
                    const totalCount = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems.length : 0;
                    const appliedCount = Object.keys(appliedSet).length;
                    const targetCount = Object.keys(targetSet).length;
                    const visibleCount = appliedCount > 0
                        ? appliedCount
                        : (this.roadSyntaxActiveLayerKey ? totalCount : 0);
                    if (force || visibleCount <= 0) {
                        console.info('[road-syntax] overlay pool health', {
                            reason: String(reason || ''),
                            active_layer: String(this.roadSyntaxActiveLayerKey || ''),
                            visible_lines: visibleCount,
                            applied_visible_lines: appliedCount,
                            target_visible_lines: targetCount,
                            total_lines: totalCount,
                            mode: 'bucket_pool',
                        });
                    }
                    return {
                        inspectedLines: visibleCount,
                        visibleLines: visibleCount,
                        invalid: { path: 0, endpoint: 0, line: 0 },
                        totalLines: totalCount,
                    };
                },
                invalidateRoadSyntaxCache(reason = 'manual', options = {}) {
                    const resetData = !!(options && options.resetData);
                    const resetPerf = !!(options && options.resetPerf);
                    if (typeof this.roadSyntaxClearMapWriteQueue === 'function') {
                        this.roadSyntaxClearMapWriteQueue({ dispose: reason === 'unmount' });
                    }
                    this.roadSyntaxStyleUpdateToken += 1;
                    this.roadSyntaxPoolWarmToken += 1;
                    this.roadSyntaxLayerBuildToken += 1;
                    this.roadSyntaxLayerSwitchToken += 1;
                    this.roadSyntaxPrewarmToken += 1;
                    this.roadSyntaxStyleApplyToken += 1;
                    this.roadSyntaxSwitchInProgress = false;
                    this.roadSyntaxSwitchQueuedLayerKey = '';
                    this.roadSyntaxSwitchLastAt = 0;
                    this.roadSyntaxClearSwitchThrottleTimer();
                    this.roadSyntaxClearViewportRefreshHandles();
                    this.roadSyntaxClearNodeRefreshTimer();
                    this.roadSyntaxBumpViewportRefreshToken();
                    this._roadSyntaxPinnedAttachKey = '';
                    this._roadSyntaxViewportToggleDisabledLogged = false;
                    this.roadSyntaxOverlayCommitToken = 0;
                    this.roadSyntaxOverlayLastCommitPath = '';
                    this.roadSyntaxOverlayLastCommitReason = '';
                    this.roadSyntaxInteractionLowFidelity = false;
                    this.roadSyntaxDisplaySuspended = false;
                    this.clearRoadSyntaxLayerPool();
                    this.roadSyntaxPolylines = [];
                    this.roadSyntaxPolylineItems = [];
                    this.roadSyntaxResetVisibleIndexCache();
                    this.roadSyntaxResetLodScoreCache();
                    this.roadSyntaxResetSpatialIndex();
                    this.roadSyntaxSourceFingerprint = '';
                    this.roadSyntaxPoolRadiusLabel = '';
                    this.roadSyntaxLastStyleKey = '';
                    this.roadSyntaxConnectivityReuseLayerKey = '';
                    this.roadSyntaxNodeBuildToken += 1;
                    this.roadSyntaxNodeBuildRunning = false;
                    this.roadSyntaxNodeSourceFingerprint = '';
                    this.clearRoadSyntaxNodeMarkers({ immediate: true });
                    this.disposeRoadSyntaxScatterChart();
                    this.roadSyntaxWebglPayload = null;
                    this.roadSyntaxWebglStatus = '';
                    if (typeof this.clearRoadSyntaxArcgisWebgl === 'function') {
                        this.clearRoadSyntaxArcgisWebgl({ dispose: reason === 'unmount' });
                    }
                    if (resetData) {
                        this.roadSyntaxStatus = '';
                        this.roadSyntaxStatusCopyHint = '';
                        this.roadSyntaxSummary = null;
                        this.roadSyntaxRoadFeatures = [];
                        this.roadSyntaxNodes = [];
                        this.roadSyntaxDiagnostics = null;
                        this.roadSyntaxScatterPointsCache = [];
                        this.roadSyntaxLegendModel = null;
                        this.roadSyntaxSkeletonOnly = false;
                        this.roadSyntaxMainTab = 'params';
                        const defaultMetric = this.roadSyntaxDefaultMetric();
                        this.roadSyntaxMetric = defaultMetric;
                        this.roadSyntaxLastMetricTab = defaultMetric;
                        this.roadSyntaxRadiusLabel = 'global';
                    }
                    if (resetPerf) {
                        this.roadSyntaxSwitchSamples = [];
                        this.roadSyntaxSwitchLastMs = 0;
                        this.roadSyntaxSwitchP50Ms = 0;
                        this.roadSyntaxSwitchP95Ms = 0;
                        this.roadSyntaxSwitchStatsText = '';
                        this.roadSyntaxSwitchPath = '';
                    }
                    if (reason === 'unmount') {
                        this.roadSyntaxStatus = '';
                    }
                },
                resetRoadSyntaxState() {
                    this.roadSyntaxRequestToken += 1;
                    this.isComputingRoadSyntax = false;
                    this.invalidateRoadSyntaxCache('reset-state', { resetData: true, resetPerf: true });
                },
                clearRoadSyntaxOverlays() {
                    this.invalidateRoadSyntaxCache('clear-overlays', { resetData: false, resetPerf: false });
                },
                suspendRoadSyntaxDisplay() {
                    const map = this.roadSyntaxMap();
                    if (!map) return;
                    this.roadSyntaxDisplaySuspended = true;
                    this.roadSyntaxLayerSwitchToken += 1;
                    this.roadSyntaxClearViewportRefreshHandles();
                    this.roadSyntaxClearNodeRefreshTimer();
                    this.roadSyntaxBumpViewportRefreshToken();
                    this._roadSyntaxPinnedAttachKey = '';
                    this.roadSyntaxInteractionLowFidelity = false;
                    const activeLayer = this.roadSyntaxGetLayer(this.roadSyntaxActiveLayerKey || '');
                    const activeRuntime = this.roadSyntaxResolveLayerRuntimeEntry(activeLayer, this.roadSyntaxActiveLayerVariant || 'full');
                    if (activeRuntime) {
                        if (activeRuntime.overlayGroup) {
                            this.roadSyntaxSetOverlayGroupVisible(activeRuntime.overlayGroup, false, map);
                        } else if (Array.isArray(activeRuntime.overlays) && activeRuntime.overlays.length) {
                            this.roadSyntaxSetLinesVisible(activeRuntime.overlays, false, map, { preferBatch: true });
                        }
                    }
                    this.roadSyntaxResetVisibleIndexCache();
                    this.roadSyntaxCurrentStride = 1;
                    if (typeof this.setRoadSyntaxArcgisWebglVisible === 'function') {
                        this.setRoadSyntaxArcgisWebglVisible(false);
                    }
                    this.cancelRoadSyntaxNodeBuild();
                    this.setRoadSyntaxNodeMarkersVisible(false);
                    this.disposeRoadSyntaxScatterChart();
                },
                resumeRoadSyntaxDisplay() {
                    if (
                        !this.roadSyntaxSummary
                        || !Array.isArray(this.roadSyntaxRoadFeatures)
                        || !this.roadSyntaxRoadFeatures.length
                    ) {
                        this.roadSyntaxDisplaySuspended = false;
                        return;
                    }
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    ) {
                        this.roadSyntaxDisplaySuspended = false;
                        this.renderRoadSyntaxByMetric(this.resolveRoadSyntaxActiveMetric());
                        return;
                    }
                    if (this.roadSyntaxStrictWebglOnly) {
                        this.roadSyntaxDisplaySuspended = false;
                        this.roadSyntaxSetStatus('ArcGIS-WebGL 数据未就绪（已禁用旧版回退）');
                        return;
                    }
                    this._roadSyntaxPinnedAttachKey = '';
                    this.roadSyntaxDisplaySuspended = true;
                    this.renderRoadSyntaxOverlays({
                        type: 'FeatureCollection',
                        features: this.roadSyntaxRoadFeatures,
                    }, { forceRebuild: false, displayActive: true });
                },
                clearRoadSyntaxLayerPool() {
                    const map = this.roadSyntaxMap();
                    const lines = Array.isArray(this.roadSyntaxPolylines) ? this.roadSyntaxPolylines : [];
                    this.roadSyntaxSetLinesVisible(lines, false, map, { preferBatch: true });
                    this.roadSyntaxClearViewportRefreshHandles();
                    this.roadSyntaxClearNodeRefreshTimer();
                    const pool = this.roadSyntaxLayerPool || {};
                    Object.keys(pool).forEach((key) => {
                        this.roadSyntaxDisposeLayerEntry(pool[key], map);
                    });
                    this.roadSyntaxLayerPool = {};
                    this.roadSyntaxLayerStyleCache = {};
                    this.roadSyntaxLayerLodIndexCache = {};
                    this.roadSyntaxPolylines = [];
                    this.roadSyntaxTargetVisibleLineSet = {};
                    this.roadSyntaxAppliedVisibleLineSet = {};
                    this.roadSyntaxResetVisibleIndexCache();
                    this.roadSyntaxResetLodScoreCache();
                    this.roadSyntaxResetSpatialIndex();
                    this.roadSyntaxBumpViewportRefreshToken();
                    this.roadSyntaxInteractionLowFidelity = false;
                    this.roadSyntaxCurrentStride = 1;
                    this.roadSyntaxActiveLayerKey = '';
                    this.roadSyntaxActiveLayerVariant = 'full';
                    this.roadSyntaxPendingLayerKey = '';
                    this.roadSyntaxLayerBuildState = {};
                    this.roadSyntaxLayerBuildQueue = [];
                    this.roadSyntaxLayerBuildRunning = false;
                    this.roadSyntaxPoolInitRunning = false;
                    this.roadSyntaxPoolReady = false;
                    this.roadSyntaxPoolDegraded = false;
                    this.roadSyntaxPoolInitTotal = 0;
                    this.roadSyntaxPoolInitDone = 0;
                    this.roadSyntaxLayerReadyMap = {};
                    this.roadSyntaxConnectivityReuseLayerKey = '';
                },
                refreshRoadSyntaxLayerReadyMap() {
                    const keys = this.roadSyntaxLayerKeysForPrebuild();
                    const state = this.roadSyntaxLayerBuildState || {};
                    const cache = this.roadSyntaxLayerStyleCache || {};
                    const readyMap = {};
                    keys.forEach((key) => {
                        readyMap[key] = !!cache[key] && state[key] === 'ready';
                    });
                    this.roadSyntaxLayerReadyMap = readyMap;
                    this.roadSyntaxPoolInitTotal = keys.length;
                    this.roadSyntaxPoolInitDone = Object.values(readyMap).filter((v) => !!v).length;
                    return readyMap;
                },
                isRoadSyntaxMetricReady(metricValue = null, options = {}) {
                    if (!this.roadSyntaxSummary) return false;
                    const metric = String(metricValue || this.resolveRoadSyntaxActiveMetric() || this.roadSyntaxDefaultMetric());
                    if (this.roadSyntaxStrictWebglOnly) {
                        return !!(
                            this.roadSyntaxUseArcgisWebgl
                            && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                            && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                        );
                    }
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    ) {
                        return true;
                    }
                    const radiusLabel = options && Object.prototype.hasOwnProperty.call(options, 'radiusLabel')
                        ? String(options.radiusLabel || 'global')
                        : (this.roadSyntaxMetricUsesRadius(metric) ? String(this.roadSyntaxRadiusLabel || 'global') : 'global');
                    const skeletonOnly = options && Object.prototype.hasOwnProperty.call(options, 'skeletonOnly')
                        ? !!options.skeletonOnly
                        : false;
                    const key = this.resolveRoadSyntaxLayerKey(metric, { radiusLabel, skeletonOnly });
                    return this.isRoadSyntaxLayerReady(key);
                },
                canActivateRoadSyntaxTab(tabValue) {
                    const tab = String(tabValue || '').trim();
                    if (tab === 'params') return true;
                    if (!this.roadSyntaxSummary) return false;
                    return this.isRoadSyntaxMetricReady(tab);
                },
                canToggleRoadSyntaxSkeleton() {
                    const metric = this.resolveRoadSyntaxActiveMetric();
                    if (!this.roadSyntaxSupportsSkeleton(metric)) return false;
                    if (!this.roadSyntaxSummary) return false;
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    ) {
                        return false;
                    }
                    if (!this.roadSyntaxSkeletonOnly) {
                        return this.isRoadSyntaxMetricReady(metric, { skeletonOnly: true });
                    }
                    return this.isRoadSyntaxMetricReady(metric, { skeletonOnly: false });
                },
                cancelRoadSyntaxNodeBuild() {
                    this.roadSyntaxNodeBuildToken += 1;
                    this.roadSyntaxNodeBuildRunning = false;
                },
                shouldRenderRoadSyntaxConnectivityNodes() {
                    if (!this.mapCore || !this.mapCore.map) return false;
                    const minZoom = Number(this.roadSyntaxConnectivityNodeMinZoom || 15);
                    const zoom = Number(this.mapCore.map.getZoom ? this.mapCore.map.getZoom() : NaN);
                    if (!Number.isFinite(zoom)) return true;
                    return zoom >= minZoom;
                },
                setRoadSyntaxNodeMarkersVisible(visible) {
                    if (!Array.isArray(this.roadSyntaxNodeMarkers) || !this.roadSyntaxNodeMarkers.length) {
                        return;
                    }
                    if (visible && !this.shouldRenderRoadSyntaxConnectivityNodes()) {
                        visible = false;
                    }
                    const markers = this.roadSyntaxNodeMarkers.slice();
                    const targetMap = (visible && this.mapCore && this.mapCore.map) ? this.mapCore.map : null;
                    this.roadSyntaxEnqueueMapWrite(() => {
                        markers.forEach((marker) => this.safeMapSet(marker, targetMap));
                        return {
                            ok: true,
                                marker_count: markers.length,
                                visible: !!targetMap
                            };
                    }, {
                        key: 'road_syntax_node_visibility',
                        replaceExisting: true,
                        meta: {
                            reason: 'road_syntax_node_visibility',
                            marker_count: markers.length,
                            visible: !!targetMap
                        }
                    });
                },
                clearRoadSyntaxNodeMarkers(options = {}) {
                    this.cancelRoadSyntaxNodeBuild();
                    if (!Array.isArray(this.roadSyntaxNodeMarkers)) {
                        this.roadSyntaxNodeMarkers = [];
                        return;
                    }
                    const immediate = !!(options && options.immediate);
                    const markers = this.roadSyntaxNodeMarkers.slice();
                    this.roadSyntaxNodeMarkers = [];
                    if (!markers.length) return;
                    if (immediate) {
                        markers.forEach((marker) => this.safeMapSet(marker, null));
                        return;
                    }
                    this.roadSyntaxEnqueueMapWrite(() => {
                        markers.forEach((marker) => this.safeMapSet(marker, null));
                        return {
                            ok: true,
                            marker_count: markers.length
                        };
                    }, {
                        key: 'road_syntax_node_clear',
                        replaceExisting: false,
                        meta: {
                            reason: 'road_syntax_node_clear',
                            marker_count: markers.length
                        }
                    });
                },
                disposeRoadSyntaxScatterChart() {
                    this.clearRoadSyntaxScatterRenderTimer();
                    const chart = this.roadSyntaxScatterChart;
                    if (chart && typeof chart.dispose === 'function') {
                        chart.dispose();
                    }
                    this.roadSyntaxScatterChart = null;
                },
                clearRoadSyntaxScatterRenderTimer() {
                    if (this.roadSyntaxScatterRenderTimer) {
                        window.clearTimeout(this.roadSyntaxScatterRenderTimer);
                        this.roadSyntaxScatterRenderTimer = null;
                    }
                },
                scheduleRoadSyntaxScatterRender(attempt = 0) {
                    if (this.roadSyntaxMainTab !== 'intelligibility') return;
                    const retry = Math.max(0, Number(attempt) || 0);
                    const maxRetry = 8;
                    this.clearRoadSyntaxScatterRenderTimer();
                    const delay = retry === 0 ? 0 : Math.min(180, 40 + retry * 20);
                    this.roadSyntaxScatterRenderTimer = window.setTimeout(() => {
                        this.roadSyntaxScatterRenderTimer = null;
                        const rendered = this.renderRoadSyntaxScatterChart();
                        if (!rendered && retry < maxRetry && this.roadSyntaxMainTab === 'intelligibility') {
                            this.scheduleRoadSyntaxScatterRender(retry + 1);
                        }
                    }, delay);
                },
                setRoadSyntaxMainTab(tabValue, options = {}) {
                    const value = String(tabValue || '').trim();
                    const validTabs = (this.roadSyntaxTabs || []).map((tab) => tab.value);
                    if (!validTabs.includes(value)) return;
                    if (value !== 'params' && this.roadSyntaxPoolInitRunning && this.roadSyntaxUseLegacyPoolStatus()) {
                        this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层预加载中', this.roadSyntaxPoolInitDone, this.roadSyntaxPoolInitTotal || 0));
                        return;
                    }
                    const syncMetric = options.syncMetric !== false;
                    const refresh = options.refresh !== false;
                    const previousTab = this.roadSyntaxMainTab;
                    const previousMetric = this.roadSyntaxMetric;
                    this.roadSyntaxMainTab = value;
                    if (value === 'params') {
                        this.cancelRoadSyntaxNodeBuild();
                        this.setRoadSyntaxNodeMarkersVisible(false);
                        this.disposeRoadSyntaxScatterChart();
                        return;
                    }
                    if (!this.isRoadSyntaxMetricReady(value)) {
                        if (this.roadSyntaxStrictWebglOnly) {
                            this.roadSyntaxSetStatus(`指标“${this.roadSyntaxLabelByMetric(value)}”对应 ArcGIS-WebGL 数据未就绪`);
                        } else {
                            const counts = this.roadSyntaxLayerReadyCounts();
                            if (this.roadSyntaxPoolDegraded) {
                                this.roadSyntaxSetStatus(`图层预处理已降级，指标“${this.roadSyntaxLabelByMetric(value)}”仍未就绪（${counts.ready}/${counts.total || 0}）`);
                            } else {
                                this.roadSyntaxSetStatus(`指标“${this.roadSyntaxLabelByMetric(value)}”仍在预处理（${counts.ready}/${counts.total || 0}）`);
                            }
                        }
                        return;
                    }
                    if (syncMetric) {
                        this.roadSyntaxMetric = value;
                        this.roadSyntaxLastMetricTab = value;
                    }
                    if (!this.roadSyntaxMetricUsesRadius(value)) {
                        this.roadSyntaxRadiusLabel = 'global';
                    }
                    if (previousTab === value && previousMetric === this.roadSyntaxMetric) {
                        return;
                    }
                    if (refresh) {
                        this.refreshRoadSyntaxOverlay();
                    }
                },
                roadSyntaxMetricTabs() {
                    return (this.roadSyntaxTabs || []).filter((item) => item.value !== 'params');
                },
                roadSyntaxDefaultMetric() {
                    const tabs = this.roadSyntaxMetricTabs();
                    if (tabs.length) {
                        return String((tabs[0] && tabs[0].value) || 'connectivity');
                    }
                    return 'connectivity';
                },
                roadSyntaxMetricDataCount(metricValue = null) {
                    const metric = String(metricValue || this.resolveRoadSyntaxActiveMetric() || this.roadSyntaxDefaultMetric());
                    const summary = this.roadSyntaxSummary || {};
                    if (metric === 'control') return Number(summary.control_valid_count || 0);
                    if (metric === 'depth') return Number(summary.depth_valid_count || 0);
                    return Number(summary.edge_count || 0);
                },
                isRoadSyntaxMetricAvailable(metricValue = null) {
                    const metric = String(metricValue || this.resolveRoadSyntaxActiveMetric() || this.roadSyntaxDefaultMetric());
                    if (metric !== 'control' && metric !== 'depth') return true;
                    return this.roadSyntaxMetricDataCount(metric) > 0;
                },
                roadSyntaxLabelByMetric(metricValue) {
                    const metric = String(metricValue || '').trim();
                    const matched = this.roadSyntaxMetricTabs().find((item) => item.value === metric);
                    return matched ? matched.label : metric;
                },
                roadSyntaxMetricUsesRadius(metricValue = null) {
                    const metric = metricValue || this.roadSyntaxMetric || this.roadSyntaxDefaultMetric();
                    return metric === 'choice' || metric === 'integration';
                },
                roadSyntaxSupportsSkeleton(metricValue = null) {
                    void metricValue;
                    return false;
                },
                onRoadSyntaxMetricChange(metricValue) {
                    this.setRoadSyntaxMainTab(metricValue);
                },
                formatRoadSyntaxMetricValue(metricValue) {
                    const summary = this.roadSyntaxSummary || {};
                    const metric = metricValue || this.roadSyntaxDefaultMetric();
                    if (!this.isRoadSyntaxMetricAvailable(metric)) return '--';
                    let value = NaN;
                    if (metric === 'accessibility') {
                        value = Number(summary.avg_accessibility_global ?? summary.avg_closeness);
                    } else if (metric === 'connectivity') {
                        value = Number(summary.avg_connectivity ?? summary.avg_degree);
                    } else if (metric === 'control') {
                        value = Number(summary.avg_control);
                    } else if (metric === 'depth') {
                        value = Number(summary.avg_depth);
                    } else if (metric === 'choice') {
                        value = Number(summary.avg_choice_global);
                    } else if (metric === 'integration') {
                        value = Number(summary.avg_integration_global);
                    } else if (metric === 'intelligibility') {
                        value = Number(summary.avg_intelligibility);
                    }
                    if (!Number.isFinite(value)) return '--';
                    if (metric === 'connectivity') return value.toFixed(2);
                    if (metric === 'intelligibility') return value.toFixed(4);
                    return value.toFixed(6);
                },
                async copyRoadSyntaxStatus() {
                    const text = String(this.roadSyntaxStatus || '').trim();
                    if (!text) return;
                    try {
                        await navigator.clipboard.writeText(text);
                        this.roadSyntaxStatusCopyHint = '已复制';
                    } catch (_) {
                        this.roadSyntaxStatusCopyHint = '复制失败';
                    }
                    if (this._syntaxCopyHintTimer) {
                        window.clearTimeout(this._syntaxCopyHintTimer);
                    }
                    this._syntaxCopyHintTimer = window.setTimeout(() => {
                        this.roadSyntaxStatusCopyHint = '';
                    }, 1400);
                },
                roadSyntaxRadiusOptions() {
                    const labels = (this.roadSyntaxSummary && Array.isArray(this.roadSyntaxSummary.radius_labels))
                        ? this.roadSyntaxSummary.radius_labels
                        : [];
                    const options = labels.map((label) => {
                        const radiusNum = Number(String(label || '').replace(/^r/i, ''));
                        const radiusText = Number.isFinite(radiusNum) && radiusNum > 0 ? `${radiusNum}m` : String(label || '');
                        return { value: label, label: `局部 ${radiusText}` };
                    });
                    options.push({ value: 'global', label: '全局 (Rn)' });
                    return options;
                },
                resolveRoadSyntaxRequestMetric() {
                    return this.roadSyntaxMetric === 'choice' ? 'choice' : 'integration';
                },
                clamp01(value) {
                    return Math.max(0, Math.min(1, Number(value) || 0));
                },
                blendTwoColor(colorA, colorB, ratio) {
                    const a = Array.isArray(colorA) ? colorA : [0, 0, 0];
                    const b = Array.isArray(colorB) ? colorB : [0, 0, 0];
                    const t = this.clamp01(ratio);
                    const r = Math.round(a[0] + (b[0] - a[0]) * t);
                    const g = Math.round(a[1] + (b[1] - a[1]) * t);
                    const b2 = Math.round(a[2] + (b[2] - a[2]) * t);
                    const toHex = (c) => {
                        const hex = Math.max(0, Math.min(255, c)).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    return `#${toHex(r)}${toHex(g)}${toHex(b2)}`;
                },
                blendPaletteColor(stops, ratio) {
                    const palette = Array.isArray(stops) && stops.length ? stops : [[0, 0, 0], [255, 255, 255]];
                    const t = this.clamp01(ratio);
                    const toHex = (c) => {
                        const hex = Math.max(0, Math.min(255, c)).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    if (palette.length === 1) {
                        const c = palette[0];
                        return `#${toHex(c[0])}${toHex(c[1])}${toHex(c[2])}`;
                    }
                    const seg = Math.min(palette.length - 2, Math.floor(t * (palette.length - 1)));
                    const segStart = seg / (palette.length - 1);
                    const segEnd = (seg + 1) / (palette.length - 1);
                    const local = (t - segStart) / Math.max(1e-9, segEnd - segStart);
                    return this.blendTwoColor(palette[seg], palette[seg + 1], local);
                },
                onRoadSyntaxDisplayRangeChange() {
                    const blue = this.clamp01(Number(this.roadSyntaxDisplayBlue));
                    const red = this.clamp01(Number(this.roadSyntaxDisplayRed));
                    this.roadSyntaxDisplayBlue = Number.isFinite(blue) ? blue : 0;
                    this.roadSyntaxDisplayRed = Number.isFinite(red) ? red : 1;
                    if (this.roadSyntaxMainTab !== 'params') {
                        this.refreshRoadSyntaxOverlay();
                    }
                },
                roadSyntaxDepthmapColorSchemes() {
                    return {
                        axmanesque: [
                            '#3333dd', '#3388dd', '#22ccdd', '#22ccbb', '#22dd88',
                            '#88dd22', '#bbcc22', '#ddcc22', '#dd8833', '#dd3333',
                        ],
                        hueonlyaxmanesque: [
                            '#3333dd', '#3377dd', '#33bbdd', '#33ddbb', '#33dd55',
                            '#55dd33', '#bbdd33', '#ddbb33', '#dd7733', '#dd3333',
                        ],
                        bluered: [
                            '#4575b4', '#91bfdb', '#e0f3f8', '#ffffbf', '#fee090', '#fc8d59', '#d73027',
                        ],
                        purpleorange: [
                            '#542788', '#998ec3', '#d8daeb', '#f7f7f7', '#fee0b6', '#f1a340', '#b35806',
                        ],
                        greyscale: [
                            '#000000', '#444444', '#777777', '#aaaaaa', '#cccccc', '#eeeeee', '#ffffff',
                        ],
                        monochrome: [
                            '#000000', '#444444', '#777777', '#aaaaaa', '#cccccc', '#eeeeee', '#ffffff',
                        ],
                    };
                },
                roadSyntaxDepthmapColorScaleOptions() {
                    return [
                        { value: 'axmanesque', label: 'Equal Ranges (3-Colour)' },
                        { value: 'bluered', label: 'Equal Ranges (Blue-Red)' },
                        { value: 'purpleorange', label: 'Equal Ranges (Purple-Orange)' },
                        { value: 'depthmapclassic', label: 'depthmapX Classic' },
                        { value: 'greyscale', label: 'Equal Ranges (Greyscale)' },
                        { value: 'monochrome', label: 'Equal Ranges (Monochrome)' },
                        { value: 'hueonlyaxmanesque', label: 'Equal Ranges (3-Colour Hue Only)' },
                    ];
                },
                roadSyntaxDepthmapColorScaleLabel() {
                    const current = String(this.roadSyntaxDepthmapColorScale || 'axmanesque');
                    const options = this.roadSyntaxDepthmapColorScaleOptions();
                    const matched = options.find((opt) => String(opt.value) === current);
                    return matched ? matched.label : 'Equal Ranges (3-Colour)';
                },
                roadSyntaxDepthmapDisplayParams() {
                    const rawBlue = this.clamp01(Number(this.roadSyntaxDisplayBlue));
                    const rawRed = this.clamp01(Number(this.roadSyntaxDisplayRed));
                    let blue = rawBlue;
                    let red = rawRed;
                    let inverted = false;
                    if (blue > red) {
                        inverted = true;
                        blue = 1.0 - rawBlue;
                        red = 1.0 - rawRed;
                    }
                    return {
                        rawBlue,
                        rawRed,
                        blue: this.clamp01(blue),
                        red: this.clamp01(red),
                        inverted,
                    };
                },
                roadSyntaxDepthmapPalette() {
                    const schemes = this.roadSyntaxDepthmapColorSchemes();
                    const key = String(this.roadSyntaxDepthmapColorScale || 'axmanesque').toLowerCase();
                    return Array.isArray(schemes[key]) && schemes[key].length
                        ? schemes[key]
                        : schemes.axmanesque;
                },
                roadSyntaxDepthmapClassIndex(field, classCount) {
                    const count = Math.max(1, Number(classCount) || 1);
                    const t = this.clamp01(field);
                    const raw = Math.floor((t - 1e-9) * count);
                    return Math.max(0, Math.min(count - 1, raw));
                },
                roadSyntaxDepthmapScaledField(field) {
                    if (!Number.isFinite(Number(field))) return NaN;
                    const scale = String(this.roadSyntaxDepthmapColorScale || 'axmanesque').toLowerCase();
                    const params = this.roadSyntaxDepthmapDisplayParams();
                    let value = this.clamp01(Number(field));
                    if (params.inverted) {
                        value = 1.0 - value;
                    }
                    if (scale === 'depthmapclassic') {
                        return value;
                    }
                    const denom = params.red - params.blue;
                    if (!(denom > 1e-9)) {
                        return 0.5;
                    }
                    const scaled = (value - params.blue) / denom;
                    if (!Number.isFinite(scaled)) return 0.5;
                    return this.clamp01(scaled);
                },
                roadSyntaxNormalizeScoreByRange(value, minValue, maxValue) {
                    const v = Number(value);
                    const lo = Number(minValue);
                    const hi = Number(maxValue);
                    if (!Number.isFinite(v)) return 0;
                    if (!Number.isFinite(lo) || !Number.isFinite(hi) || hi <= lo) return this.clamp01(v);
                    return this.clamp01((v - lo) / Math.max(1e-9, hi - lo));
                },
                roadSyntaxDepthmapClassicByte(value) {
                    const v = this.clamp01(value);
                    const scaled = Math.floor((v + 0.0333) * 15.0);
                    return Math.max(0, Math.min(255, scaled * 17));
                },
                roadSyntaxDepthmapClassicColor(score, blueValue = null, redValue = null) {
                    const field = this.clamp01(score);
                    const params = this.roadSyntaxDepthmapDisplayParams();
                    const blue = Number.isFinite(Number(blueValue)) ? this.clamp01(Number(blueValue)) : params.blue;
                    const red = Number.isFinite(Number(redValue)) ? this.clamp01(Number(redValue)) : params.red;
                    const green = blue + (red - blue) / 10.0;
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    if (field >= 0.0 && field < blue) {
                        r = this.roadSyntaxDepthmapClassicByte(0.5 * (blue - field) / Math.max(1e-9, blue));
                        b = 255;
                    } else if (field >= blue && field < (green + blue) / 2.0) {
                        b = 255;
                        g = this.roadSyntaxDepthmapClassicByte(2.0 * (field - blue) / Math.max(1e-9, green - blue));
                    } else if (field >= (green + blue) / 2.0 && field < green) {
                        b = this.roadSyntaxDepthmapClassicByte(2.0 * (green - field) / Math.max(1e-9, green - blue));
                        g = 255;
                    } else if (field >= green && field < (green + red) / 2.0) {
                        g = 255;
                        r = this.roadSyntaxDepthmapClassicByte(2.0 * (field - green) / Math.max(1e-9, red - green));
                    } else if (field >= (green + red) / 2.0 && field < red) {
                        g = this.roadSyntaxDepthmapClassicByte(2.0 * (red - field) / Math.max(1e-9, red - green));
                        r = 255;
                    } else {
                        r = 255;
                        b = this.roadSyntaxDepthmapClassicByte(0.5 * (field - red) / Math.max(1e-9, 1.0 - red));
                    }
                    const toHex = (c) => {
                        const hex = Math.max(0, Math.min(255, Number(c) || 0)).toString(16);
                        return hex.length === 1 ? `0${hex}` : hex;
                    };
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                },
                roadSyntaxDepthmapClassColor(score, paletteValue = null) {
                    const palette = Array.isArray(paletteValue) && paletteValue.length
                        ? paletteValue
                        : this.roadSyntaxDepthmapPalette();
                    const scale = String(this.roadSyntaxDepthmapColorScale || 'axmanesque').toLowerCase();
                    if (!Number.isFinite(Number(score))) {
                        if (scale === 'monochrome' || scale === 'greyscale') {
                            return 'rgba(0,0,0,0)';
                        }
                        return '#7f7f7f';
                    }
                    const scaledField = this.roadSyntaxDepthmapScaledField(score);
                    if (scale === 'depthmapclassic') {
                        const params = this.roadSyntaxDepthmapDisplayParams();
                        return this.roadSyntaxDepthmapClassicColor(scaledField, params.blue, params.red);
                    }
                    const idx = this.roadSyntaxDepthmapClassIndex(scaledField, palette.length);
                    return String(palette[idx] || '#3333dd');
                },
                roadSyntaxEqualRangeLegendItems(scores, paletteValue = null) {
                    const scale = String(this.roadSyntaxDepthmapColorScale || 'axmanesque').toLowerCase();
                    const palette = Array.isArray(paletteValue) && paletteValue.length
                        ? paletteValue
                        : this.roadSyntaxDepthmapPalette();
                    const legendColors = (scale === 'depthmapclassic')
                        ? new Array(10).fill(0).map((_, idx) => this.roadSyntaxDepthmapClassColor((idx + 0.5) / 10, palette))
                        : palette;
                    const values = (Array.isArray(scores) ? scores : [])
                        .map((v) => Number(v))
                        .filter((v) => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!values.length) {
                        return legendColors.map((color, idx) => ({ color, label: `等级 ${idx + 1}` }));
                    }
                    const min = values[0];
                    const max = values[values.length - 1];
                    if (!(max > min)) {
                        return legendColors.map((color, idx) => ({
                            color,
                            label: idx === 0 ? `${min.toFixed(2)}` : '-',
                        }));
                    }
                    const span = max - min;
                    const colors = legendColors;
                    const params = this.roadSyntaxDepthmapDisplayParams();
                    return colors.map((color, idx) => {
                        let loField = idx / colors.length;
                        let hiField = (idx + 1) / colors.length;
                        if (scale !== 'depthmapclassic') {
                            loField = params.blue + (params.red - params.blue) * loField;
                            hiField = params.blue + (params.red - params.blue) * hiField;
                        }
                        const lo = min + span * this.clamp01(loField);
                        const hi = min + span * this.clamp01(hiField);
                        return {
                            color,
                            label: `${lo.toFixed(2)} - ${hi.toFixed(2)}`,
                        };
                    });
                },
                roadSyntaxSummarizeCoordInput(input) {
                    if (input === null) return { type: 'null' };
                    if (typeof input === 'undefined') return { type: 'undefined' };
                    if (typeof input === 'string') return { type: 'string', value: String(input).slice(0, 80) };
                    if (Array.isArray(input)) {
                        return {
                            type: 'array',
                            length: input.length,
                            head: input.slice(0, 2),
                        };
                    }
                    if (typeof input === 'object') {
                        const out = { type: 'object' };
                        if (Object.prototype.hasOwnProperty.call(input, 'lng')) out.lng = input.lng;
                        if (Object.prototype.hasOwnProperty.call(input, 'lat')) out.lat = input.lat;
                        if (Object.prototype.hasOwnProperty.call(input, 'lon')) out.lon = input.lon;
                        if (typeof input.getLng === 'function') out.getLng = true;
                        if (typeof input.getLat === 'function') out.getLat = true;
                        return out;
                    }
                    return { type: typeof input, value: input };
                },
                roadSyntaxLogInvalidCoordInput(source = '', input = null) {
                    const key = String(source || 'unknown');
                    if (!this._roadSyntaxInvalidCoordStats) {
                        this._roadSyntaxInvalidCoordStats = Object.create(null);
                    }
                    const stats = this._roadSyntaxInvalidCoordStats;
                    if (!stats[key]) {
                        stats[key] = { count: 0 };
                    }
                    stats[key].count += 1;
                    const count = stats[key].count;
                    if (count <= 5) {
                        console.warn('[road-syntax] invalid coordinate input', {
                            source: key,
                            count: count,
                            sample: this.roadSyntaxSummarizeCoordInput(input)
                        });
                    } else if (count % 100 === 0) {
                        console.warn('[road-syntax] invalid coordinate input aggregated', {
                            source: key,
                            count: count
                        });
                    }
                },
                normalizeLngLat(input, source = '') {
                    let lng = NaN;
                    let lat = NaN;
                    if (Array.isArray(input) && input.length >= 2) {
                        lng = Number(input[0]);
                        lat = Number(input[1]);
                    } else if (input && typeof input === 'object') {
                        if (typeof input.getLng === 'function' && typeof input.getLat === 'function') {
                            lng = Number(input.getLng());
                            lat = Number(input.getLat());
                        } else if (Object.prototype.hasOwnProperty.call(input, 'lng') && Object.prototype.hasOwnProperty.call(input, 'lat')) {
                            lng = Number(input.lng);
                            lat = Number(input.lat);
                        } else if (Object.prototype.hasOwnProperty.call(input, 'lon') && Object.prototype.hasOwnProperty.call(input, 'lat')) {
                            lng = Number(input.lon);
                            lat = Number(input.lat);
                        }
                    } else if (typeof input === 'string') {
                        const parts = input.split(',');
                        if (parts.length >= 2) {
                            lng = Number(parts[0].trim());
                            lat = Number(parts[1].trim());
                        }
                    }
                    if (!Number.isFinite(lng) || !Number.isFinite(lat)) {
                        this.roadSyntaxLogInvalidCoordInput(source || 'normalize_lnglat', input);
                        return null;
                    }
                    if (lng < -180 || lng > 180 || lat < -90 || lat > 90) {
                        this.roadSyntaxLogInvalidCoordInput(source || 'normalize_lnglat_range', {
                            input: this.roadSyntaxSummarizeCoordInput(input),
                            lng,
                            lat
                        });
                        return null;
                    }
                    return [lng, lat];
                },
                normalizePath(path, minPoints = 2, source = '') {
                    const raw = Array.isArray(path) ? path : [];
                    const out = [];
                    raw.forEach((pt) => {
                        const loc = this.normalizeLngLat(pt, source || 'normalize_path');
                        if (!loc) return;
                        out.push(loc);
                    });
                    return out.length >= minPoints ? out : [];
                },
                resolveRoadSyntaxActiveMetric() {
                    const defaultMetric = this.roadSyntaxDefaultMetric();
                    const validMetrics = this.roadSyntaxMetricTabs().map((item) => String(item.value || ''));
                    const candidate = this.roadSyntaxMainTab === 'params'
                        ? (this.roadSyntaxLastMetricTab || this.roadSyntaxMetric)
                        : this.roadSyntaxMetric;
                    const normalized = String(candidate || '').trim();
                    if (validMetrics.includes(normalized)) return normalized;
                    const backup = String(this.roadSyntaxMetric || '').trim();
                    if (validMetrics.includes(backup)) return backup;
                    return defaultMetric;
                },
                resolveRoadSyntaxMetricField(metricValue = null, radiusLabelValue = null) {
                    const metric = metricValue || this.resolveRoadSyntaxActiveMetric();
                    const radiusLabel = radiusLabelValue || (this.roadSyntaxMetricUsesRadius(metric)
                        ? (this.roadSyntaxRadiusLabel || 'global')
                        : 'global');
                    if (metric === 'connectivity') {
                        return 'connectivity_score';
                    }
                    if (metric === 'control') {
                        return 'control_score';
                    }
                    if (metric === 'depth') {
                        return 'depth_score';
                    }
                    if (metric === 'intelligibility') {
                        return 'intelligibility_score';
                    }
                    if (metric === 'choice') {
                        return radiusLabel === 'global' ? 'choice_global' : `choice_${radiusLabel}`;
                    }
                    if (metric === 'integration') {
                        return radiusLabel === 'global' ? 'integration_global' : `integration_${radiusLabel}`;
                    }
                    return 'connectivity_score';
                },
                resolveRoadSyntaxLayerKey(metricValue = null, options = {}) {
                    const metric = metricValue || this.resolveRoadSyntaxActiveMetric();
                    const skeletonOnly = options && Object.prototype.hasOwnProperty.call(options, 'skeletonOnly')
                        ? !!options.skeletonOnly
                        : !!this.roadSyntaxSkeletonOnly;
                    const radiusLabel = options && Object.prototype.hasOwnProperty.call(options, 'radiusLabel')
                        ? String(options.radiusLabel || 'global')
                        : (this.roadSyntaxMetricUsesRadius(metric) ? String(this.roadSyntaxRadiusLabel || 'global') : 'global');
                    const supportsSkeleton = typeof this.roadSyntaxSupportsSkeleton === 'function'
                        ? !!this.roadSyntaxSupportsSkeleton(metric)
                        : (metric === 'choice' || metric === 'integration');
                    const useSkeleton = supportsSkeleton ? skeletonOnly : false;
                    const normalizedRadius = this.roadSyntaxMetricUsesRadius(metric) ? radiusLabel : 'global';
                    return `${metric}|${normalizedRadius}|${useSkeleton ? 1 : 0}`;
                },
                parseRoadSyntaxLayerKey(layerKey) {
                    const parts = String(layerKey || '').split('|');
                    const metric = parts[0] || this.roadSyntaxDefaultMetric();
                    const radiusLabel = parts[1] || 'global';
                    const skeletonOnly = parts[2] === '1';
                    return { metric, radiusLabel, skeletonOnly };
                },
                roadSyntaxLayerKeysForPrebuild() {
                    const radiusLabel = String(this.roadSyntaxRadiusLabel || 'global');
                    return [
                        this.resolveRoadSyntaxLayerKey('connectivity', { radiusLabel: 'global', skeletonOnly: false }),
                        this.resolveRoadSyntaxLayerKey('control', { radiusLabel: 'global', skeletonOnly: false }),
                        this.resolveRoadSyntaxLayerKey('depth', { radiusLabel: 'global', skeletonOnly: false }),
                        this.resolveRoadSyntaxLayerKey('choice', { radiusLabel, skeletonOnly: false }),
                        this.resolveRoadSyntaxLayerKey('integration', { radiusLabel, skeletonOnly: false }),
                        this.resolveRoadSyntaxLayerKey('intelligibility', { radiusLabel: 'global', skeletonOnly: false }),
                    ];
                },
                resolveRoadSyntaxRankField(activeMetric) {
                    if (activeMetric === 'choice') return 'rank_quantile_choice';
                    if (activeMetric === 'integration') return 'rank_quantile_integration';
                    if (activeMetric === 'accessibility') return 'rank_quantile_accessibility';
                    return '';
                },
                roadSyntaxScoreFromProps(props, metricField, fallbackField) {
                    const readField = (field) => {
                        if (!props || typeof props !== 'object') return NaN;
                        if (!Object.prototype.hasOwnProperty.call(props, field)) return NaN;
                        const raw = props[field];
                        if (raw === null || typeof raw === 'undefined' || raw === '') return NaN;
                        const n = Number(raw);
                        return Number.isFinite(n) ? n : NaN;
                    };
                    const main = readField(metricField);
                    const fallback = readField(fallbackField);
                    if (Number.isFinite(main)) return this.clamp01(main);
                    if (Number.isFinite(fallback)) return this.clamp01(fallback);
                    return NaN;
                },
                roadSyntaxQuantileBreakLabels(scores) {
                    const values = (Array.isArray(scores) ? scores : [])
                        .map((v) => Number(v))
                        .filter((v) => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!values.length) {
                        return ['P10 --', 'P30 --', 'P70 --', 'P90 --'];
                    }
                    const q = (ratio) => {
                        const t = Math.max(0, Math.min(1, ratio));
                        if (values.length === 1) return values[0];
                        const pos = t * (values.length - 1);
                        const lo = Math.floor(pos);
                        const hi = Math.min(values.length - 1, lo + 1);
                        const f = pos - lo;
                        return values[lo] + (values[hi] - values[lo]) * f;
                    };
                    return [
                        `P10 ${q(0.1).toFixed(2)}`,
                        `P30 ${q(0.3).toFixed(2)}`,
                        `P70 ${q(0.7).toFixed(2)}`,
                        `P90 ${q(0.9).toFixed(2)}`,
                    ];
                },
                buildRoadSyntaxLegendModel(activeMetric) {
                    const metric = activeMetric || this.resolveRoadSyntaxActiveMetric();
                    const metricField = this.resolveRoadSyntaxMetricField(metric);
                    const fallbackField = this.resolveRoadSyntaxFallbackField(metric);
                    const palette = this.roadSyntaxDepthmapPalette();
                    const scaleLabel = this.roadSyntaxDepthmapColorScaleLabel();
                    const polylineItems = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems : [];
                    let scores = polylineItems
                        .map((item) => this.roadSyntaxScoreFromProps((item && item.props) || {}, metricField, fallbackField));
                    if (!scores.length) {
                        const roadFeatures = Array.isArray(this.roadSyntaxRoadFeatures) ? this.roadSyntaxRoadFeatures : [];
                        scores = roadFeatures
                            .map((feature) => this.roadSyntaxScoreFromProps(((feature && feature.properties) || {}), metricField, fallbackField));
                    }
                    if (metric === 'accessibility') {
                        return {
                            type: 'discrete',
                            title: `可达性（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    if (metric === 'integration') {
                        return {
                            type: 'discrete',
                            title: `整合度（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    if (metric === 'choice') {
                        return {
                            type: 'discrete',
                            title: `选择度（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    if (metric === 'connectivity') {
                        return {
                            type: 'discrete',
                            title: `连接度（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    if (metric === 'control') {
                        return {
                            type: 'discrete',
                            title: `控制值（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    if (metric === 'depth') {
                        return {
                            type: 'discrete',
                            title: `深度值（${scaleLabel}）`,
                            items: this.roadSyntaxEqualRangeLegendItems(scores, palette),
                        };
                    }
                    return {
                        type: 'discrete',
                        title: '可理解度（散点回归）',
                        items: [
                            { label: '样本点', color: '#2563eb' },
                            { label: '回归线', color: '#dc2626' },
                        ],
                    };
                },
                roadSyntaxFootnoteByMetric() {
                    const metric = this.resolveRoadSyntaxActiveMetric();
                    const scaleLabel = this.roadSyntaxDepthmapColorScaleLabel();
                    const params = this.roadSyntaxDepthmapDisplayParams();
                    const rangeHint = `(Blue=${params.rawBlue.toFixed(2)}, Red=${params.rawRed.toFixed(2)})`;
                    if (metric === 'connectivity') {
                        return `连接度采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色图表达，不启用节点点层。`;
                    }
                    if (metric === 'control') {
                        const col = String((this.roadSyntaxSummary && this.roadSyntaxSummary.control_source_column) || '');
                        if (!this.isRoadSyntaxMetricAvailable('control')) {
                            return `控制值当前无有效样本${col ? `（列：${col}）` : ''}，请检查 depthmap 输出列与分析参数。`;
                        }
                        if (col === 'topology_fallback') {
                            return `控制值当前采用拓扑回退计算（depthmap 控制列不可用或近常量），用于保障稳定显示。`;
                        }
                        return `控制值采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色表达。`;
                    }
                    if (metric === 'depth') {
                        if (!this.isRoadSyntaxMetricAvailable('depth')) {
                            const col = String((this.roadSyntaxSummary && this.roadSyntaxSummary.depth_source_column) || '');
                            return `深度值当前无有效样本${col ? `（列：${col}）` : ''}，请检查 depthmap 输出列与分析参数。`;
                        }
                        return `深度值采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色表达。`;
                    }
                    if (metric === 'choice') {
                        return `选择度采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色表达。`;
                    }
                    if (metric === 'integration') {
                        return `整合度采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色表达网络中心性。`;
                    }
                    if (metric === 'intelligibility') {
                        return '可理解度主表达为散点回归图（x=连接度，y=整合度）；地图蓝线为网络参考层。';
                    }
                    return `连接度采用 depthmapX ${scaleLabel} ${rangeHint} 的线段着色表达。`;
                },
                roadSyntaxRegressionView() {
                    const diagnostics = this.roadSyntaxDiagnostics || {};
                    const reg = diagnostics.regression || {};
                    const summary = this.roadSyntaxSummary || {};
                    const r = Number(reg.r);
                    const r2 = Number(reg.r2);
                    const n = Number(reg.n);
                    const fallbackR = Number(summary.avg_intelligibility);
                    const fallbackR2 = Number(summary.avg_intelligibility_r2);
                    return {
                        r: Number.isFinite(r) ? r.toFixed(4) : (Number.isFinite(fallbackR) ? fallbackR.toFixed(4) : '--'),
                        r2: Number.isFinite(r2) ? r2.toFixed(4) : (Number.isFinite(fallbackR2) ? fallbackR2.toFixed(4) : '--'),
                        n: Number.isFinite(n) ? String(Math.round(n)) : String((diagnostics.intelligibility_scatter || []).length || 0),
                        slope: Number.isFinite(Number(reg.slope)) ? Number(reg.slope) : 0,
                        intercept: Number.isFinite(Number(reg.intercept)) ? Number(reg.intercept) : 0,
                    };
                },
                buildRoadSyntaxStyleForMetric(props, metricField, fallbackField, activeMetric, skeletonOnlyOverride = null) {
                    const score = this.roadSyntaxScoreFromProps(props, metricField, fallbackField);
                    const metric = activeMetric || this.resolveRoadSyntaxActiveMetric();
                    const supportsSkeleton = typeof this.roadSyntaxSupportsSkeleton === 'function'
                        ? !!this.roadSyntaxSupportsSkeleton(metric)
                        : (metric === 'choice' || metric === 'integration');
                    const skeletonOnly = supportsSkeleton && (skeletonOnlyOverride === null ? !!this.roadSyntaxSkeletonOnly : !!skeletonOnlyOverride);
                    const palette = this.roadSyntaxDepthmapPalette();
                    const scale = String(this.roadSyntaxDepthmapColorScale || 'axmanesque').toLowerCase();
                    const depthmapColor = this.roadSyntaxDepthmapClassColor(score, palette);
                    const baseWeight = 2.1;
                    const missingValue = !Number.isFinite(Number(score));
                    const hideMissing = missingValue && (scale === 'monochrome' || scale === 'greyscale');
                    const baseOpacity = hideMissing ? 0.0 : 0.88;
                    if (metric === 'accessibility') {
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 90,
                        };
                    }
                    if (metric === 'integration') {
                        const isSkeleton = !!(props && props.is_skeleton_integration_top20);
                        if (skeletonOnly && !isSkeleton) {
                            return {
                                strokeColor: '#a1a1aa',
                                strokeWeight: 1.5,
                                strokeOpacity: 0.15,
                                zIndex: 82,
                            };
                        }
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 91,
                        };
                    }
                    if (metric === 'choice') {
                        const isSkeleton = !!(props && props.is_skeleton_choice_top20);
                        if (skeletonOnly && !isSkeleton) {
                            return {
                                strokeColor: '#9ca3af',
                                strokeWeight: 1.5,
                                strokeOpacity: 0.15,
                                zIndex: 82,
                            };
                        }
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 92,
                        };
                    }
                    if (metric === 'connectivity') {
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 80,
                        };
                    }
                    if (metric === 'control') {
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 81,
                        };
                    }
                    if (metric === 'depth') {
                        return {
                            strokeColor: depthmapColor,
                            strokeWeight: baseWeight,
                            strokeOpacity: baseOpacity,
                            zIndex: 81,
                        };
                    }
                    if (metric === 'intelligibility') {
                        return {
                            strokeColor: '#2563eb',
                            strokeWeight: 2.2,
                            strokeOpacity: 0.62,
                            zIndex: 79,
                        };
                    }
                    return {
                        strokeColor: '#9ca3af',
                        strokeWeight: 1.4,
                        strokeOpacity: 0.22,
                        zIndex: 79,
                    };
                },
                refreshRoadSyntaxOverlay() {
                    if (this.roadSyntaxMainTab === 'params') {
                        return;
                    }
                    const metric = this.resolveRoadSyntaxActiveMetric();
                    if (metric === 'intelligibility') {
                        const parsedActive = this.parseRoadSyntaxLayerKey(this.roadSyntaxActiveLayerKey || '');
                        const activeMetric = String((parsedActive && parsedActive.metric) || '');
                        const webglActive = (typeof this.roadSyntaxIsArcgisWebglActive === 'function')
                            ? this.roadSyntaxIsArcgisWebglActive()
                            : !!this.roadSyntaxWebglActive;
                        if (webglActive && activeMetric === 'intelligibility') {
                            this.roadSyntaxLegendModel = this.buildRoadSyntaxLegendModel(metric);
                            this.$nextTick(() => this.scheduleRoadSyntaxScatterRender(0));
                            return;
                        }
                    }
                    const supportsSkeleton = this.roadSyntaxSupportsSkeleton(metric);
                    const effectiveSkeletonOnly = supportsSkeleton ? !!this.roadSyntaxSkeletonOnly : false;
                    if (!supportsSkeleton && this.roadSyntaxSkeletonOnly) {
                        this.roadSyntaxSkeletonOnly = false;
                    }
                    const targetReady = this.isRoadSyntaxMetricReady(metric, { skeletonOnly: effectiveSkeletonOnly });
                    if (!targetReady) {
                        if (this.roadSyntaxStrictWebglOnly) {
                            this.roadSyntaxSetStatus('ArcGIS-WebGL 数据未就绪（已禁用旧版回退）');
                        } else {
                            const counts = this.roadSyntaxLayerReadyCounts();
                            this.roadSyntaxSetStatus(`目标图层仍在预处理（${counts.ready}/${counts.total || 0}）`);
                        }
                        return;
                    }
                    this.renderRoadSyntaxByMetric(this.resolveRoadSyntaxActiveMetric());
                },
                async renderRoadSyntaxByMetric(metricValue = null) {
                    const activeMetric = metricValue || this.resolveRoadSyntaxActiveMetric();
                    const webglPayloadReady = (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    );
                    if (
                        webglPayloadReady
                        && typeof this.renderRoadSyntaxArcgisWebgl === 'function'
                    ) {
                        let webglRendered = false;
                        try {
                            webglRendered = await this.renderRoadSyntaxArcgisWebgl(this.roadSyntaxWebglPayload, {
                                hideWhenSuspended: true,
                            });
                        } catch (err) {
                            webglRendered = false;
                            console.warn('[road-syntax] arcgis webgl render failed', err);
                        }
                        if (webglRendered) {
                            this.cancelRoadSyntaxNodeBuild();
                            this.setRoadSyntaxNodeMarkersVisible(false);
                            if (activeMetric === 'intelligibility') {
                                this.$nextTick(() => this.scheduleRoadSyntaxScatterRender(0));
                            } else {
                                this.disposeRoadSyntaxScatterChart();
                            }
                            this.roadSyntaxLegendModel = this.buildRoadSyntaxLegendModel(activeMetric);
                            return;
                        }
                    }
                    this.clearRoadSyntaxOverlays();
                    this.roadSyntaxLegendModel = null;
                    this.cancelRoadSyntaxNodeBuild();
                    this.setRoadSyntaxNodeMarkersVisible(false);
                    this.disposeRoadSyntaxScatterChart();
                    if (webglPayloadReady) {
                        const webglReason = String(this.roadSyntaxWebglStatus || '').trim();
                        this.roadSyntaxSetStatus(
                            webglReason
                                ? `ArcGIS-WebGL 渲染失败（已禁用旧版回退）: ${webglReason}`
                                : 'ArcGIS-WebGL 渲染失败（已禁用旧版回退）'
                        );
                    } else {
                        this.roadSyntaxSetStatus('ArcGIS-WebGL 数据未就绪（已禁用旧版回退）');
                    }
                },
                resolveRoadSyntaxFallbackField(activeMetric) {
                    let fallbackField = 'connectivity_score';
                    if (activeMetric === 'choice') {
                        fallbackField = 'choice_score';
                    } else if (activeMetric === 'integration') {
                        fallbackField = 'integration_score';
                    } else if (activeMetric === 'connectivity') {
                        fallbackField = 'degree_score';
                    } else if (activeMetric === 'control') {
                        fallbackField = 'control_score';
                    } else if (activeMetric === 'depth') {
                        fallbackField = 'depth_score';
                    } else if (activeMetric === 'intelligibility') {
                        fallbackField = 'intelligibility_score';
                    }
                    return fallbackField;
                },
                renderRoadSyntaxNodeMarkers(options = {}) {
                    if (!this.mapCore || !this.mapCore.map || !window.AMap) return;
                    const forceRebuild = !!(options && options.forceRebuild);
                    if (!this.shouldRenderRoadSyntaxConnectivityNodes()) {
                        this.cancelRoadSyntaxNodeBuild();
                        this.setRoadSyntaxNodeMarkersVisible(false);
                        return;
                    }
                    let nodes = Array.isArray(this.roadSyntaxNodes) ? this.roadSyntaxNodes : [];
                    if (!nodes.length) {
                        const fallbackMap = {};
                        (this.roadSyntaxPolylineItems || []).forEach((item) => {
                            const coords = Array.isArray(item && item.coords) ? item.coords : [];
                            const props = (item && item.props) || {};
                            const score = this.clamp01(Number(props.degree_score));
                            const endpoints = [coords[0], coords[coords.length - 1]];
                            endpoints.forEach((pt) => {
                                const loc = this.normalizeLngLat(pt, 'road_syntax.node_fallback.endpoint');
                                if (!loc) return;
                                const key = `${loc[0].toFixed(6)},${loc[1].toFixed(6)}`;
                                const prev = fallbackMap[key];
                                if (!prev || score > prev.score) {
                                    fallbackMap[key] = { loc, score };
                                }
                            });
                        });
                        nodes = Object.keys(fallbackMap).map((key) => ({
                            geometry: { coordinates: fallbackMap[key].loc },
                            properties: {
                                degree_score: fallbackMap[key].score,
                                degree: Math.round(fallbackMap[key].score * 10),
                                integration_global: 0,
                            },
                        }));
                    }
                    if (!nodes.length) {
                        this.clearRoadSyntaxNodeMarkers({ immediate: true });
                        return;
                    }

                    const zoom = Number(this.mapCore.map.getZoom ? this.mapCore.map.getZoom() : NaN);
                    let sampledNodes = nodes;
                    if (Number.isFinite(zoom) && zoom < 16 && nodes.length > 2200) {
                        const stride = Math.max(1, Math.ceil(nodes.length / 1800));
                        sampledNodes = nodes.filter((_, idx) => idx % stride === 0);
                    }

                    const firstCoord = this.normalizeLngLat((((sampledNodes[0] || {}).geometry || {}).coordinates || []), 'road_syntax.node_fingerprint.first') || [0, 0];
                    const lastCoord = this.normalizeLngLat((((sampledNodes[sampledNodes.length - 1] || {}).geometry || {}).coordinates || []), 'road_syntax.node_fingerprint.last') || [0, 0];
                    const sourceFingerprint = `${sampledNodes.length}|${firstCoord[0].toFixed(6)},${firstCoord[1].toFixed(6)}|${lastCoord[0].toFixed(6)},${lastCoord[1].toFixed(6)}`;
                    if (
                        !forceRebuild &&
                        sourceFingerprint === this.roadSyntaxNodeSourceFingerprint &&
                        Array.isArray(this.roadSyntaxNodeMarkers) &&
                        this.roadSyntaxNodeMarkers.length
                    ) {
                        this.setRoadSyntaxNodeMarkersVisible(true);
                        return;
                    }

                    this.clearRoadSyntaxNodeMarkers({ immediate: true });
                    const buildToken = this.roadSyntaxNodeBuildToken + 1;
                    this.roadSyntaxNodeBuildToken = buildToken;
                    this.roadSyntaxNodeBuildRunning = true;
                    const markers = [];
                    let index = 0;

                    const step = () => {
                        if (buildToken !== this.roadSyntaxNodeBuildToken) {
                            this.roadSyntaxEnqueueMapWrite(() => {
                                markers.forEach((marker) => this.safeMapSet(marker, null));
                                return { ok: true, marker_count: markers.length };
                            }, {
                                key: `road_syntax_node_build_abort:${buildToken}`,
                                replaceExisting: false,
                                meta: {
                                    reason: 'road_syntax_node_build_abort',
                                    marker_count: markers.length
                                }
                            });
                            return;
                        }
                        if (!this.shouldRenderRoadSyntaxConnectivityNodes()) {
                            this.roadSyntaxEnqueueMapWrite(() => {
                                markers.forEach((marker) => this.safeMapSet(marker, null));
                                return { ok: true, marker_count: markers.length };
                            }, {
                                key: `road_syntax_node_build_hidden:${buildToken}`,
                                replaceExisting: false,
                                meta: {
                                    reason: 'road_syntax_node_build_hidden',
                                    marker_count: markers.length
                                }
                            });
                            this.roadSyntaxNodeBuildRunning = false;
                            return;
                        }
                        const nowFn = (window.performance && typeof window.performance.now === 'function')
                            ? () => window.performance.now()
                            : () => Date.now();
                        const frameStart = nowFn();
                        const budgetMs = this.roadSyntaxResolveFrameBudget('node');
                        const chunkMarkers = [];
                        while (index < sampledNodes.length) {
                            const feature = sampledNodes[index] || {};
                            index += 1;
                            const loc = this.normalizeLngLat((((feature || {}).geometry || {}).coordinates || []), 'road_syntax.node_marker.center');
                            if (!loc) continue;
                            const props = (feature && feature.properties) || {};
                            const score = this.clamp01(Number(props.degree_score));
                            const marker = new AMap.CircleMarker({
                                center: loc,
                                radius: 3 + score * 7,
                                strokeColor: '#ffffff',
                                strokeWeight: 1,
                                fillColor: this.blendTwoColor([203, 213, 225], [153, 27, 27], score),
                                fillOpacity: 0.88,
                                zIndex: 115,
                                bubble: true,
                                clickable: false,
                                cursor: 'default',
                            });
                            markers.push(marker);
                            chunkMarkers.push(marker);
                            if ((nowFn() - frameStart) >= budgetMs) break;
                        }
                        if (chunkMarkers.length) {
                            const chunkMarkerCount = chunkMarkers.length;
                            const chunkEndIndex = index;
                            this.roadSyntaxEnqueueMapWrite(() => {
                                if (buildToken !== this.roadSyntaxNodeBuildToken) {
                                    chunkMarkers.forEach((marker) => this.safeMapSet(marker, null));
                                    return { ok: false, skipped: true, reason: 'stale_node_build_chunk' };
                                }
                                const targetMap = (this.mapCore && this.mapCore.map && this.shouldRenderRoadSyntaxConnectivityNodes())
                                    ? this.mapCore.map
                                    : null;
                                chunkMarkers.forEach((marker) => this.safeMapSet(marker, targetMap));
                                return {
                                    ok: true,
                                    marker_count: chunkMarkerCount,
                                    visible: !!targetMap
                                };
                            }, {
                                key: `road_syntax_node_build_chunk:${buildToken}:${chunkEndIndex}`,
                                replaceExisting: false,
                                meta: {
                                    reason: 'road_syntax_node_build_chunk',
                                    marker_count: chunkMarkerCount
                                }
                            });
                        }
                        this.roadSyntaxNodeMarkers = markers;
                        if (index < sampledNodes.length) {
                            window.requestAnimationFrame(step);
                            return;
                        }
                        this.roadSyntaxNodeBuildRunning = false;
                        this.roadSyntaxNodeSourceFingerprint = sourceFingerprint;
                        this.setRoadSyntaxNodeMarkersVisible(true);
                    };
                    window.requestAnimationFrame(step);
                },
                renderRoadSyntaxScatterChart() {
                    if (this.roadSyntaxMainTab !== 'intelligibility') {
                        this.disposeRoadSyntaxScatterChart();
                        return false;
                    }
                    if (!window.echarts) {
                        this.roadSyntaxSetStatus('可理解度图表库未加载（echarts）');
                        return false;
                    }
                    const el = document.getElementById('roadSyntaxScatterChart');
                    if (!el) return false;
                    if (el.clientWidth === 0 || el.clientHeight === 0) return false;
                    const diagnostics = this.roadSyntaxDiagnostics || {};
                    let points = this.normalizeRoadSyntaxScatterPoints(diagnostics.intelligibility_scatter);
                    if (!points.length && Array.isArray(this.roadSyntaxScatterPointsCache) && this.roadSyntaxScatterPointsCache.length) {
                        points = this.normalizeRoadSyntaxScatterPoints(this.roadSyntaxScatterPointsCache);
                    }
                    if (!points.length) {
                        points = this.buildRoadSyntaxScatterFallbackPoints();
                    }
                    if (points.length) {
                        this.roadSyntaxScatterPointsCache = points.slice();
                    }
                    if (!points.length) {
                        this.roadSyntaxSetStatus('可理解度样本为空（暂无可回归数据）');
                        let emptyChart = this.roadSyntaxScatterChart;
                        if (!emptyChart || emptyChart.isDisposed()) {
                            emptyChart = echarts.getInstanceByDom(el) || echarts.init(el);
                            this.roadSyntaxScatterChart = emptyChart;
                        }
                        emptyChart.setOption({
                            animation: false,
                            xAxis: { show: false, min: 0, max: 1 },
                            yAxis: { show: false, min: 0, max: 1 },
                            series: [],
                            graphic: [{
                                type: 'text',
                                left: 'center',
                                top: 'middle',
                                style: {
                                    text: '暂无可理解度样本点',
                                    fill: '#6b7280',
                                    fontSize: 13
                                }
                            }]
                        }, true);
                        emptyChart.resize();
                        return true;
                    }
                    let chart = this.roadSyntaxScatterChart;
                    if (!chart || chart.isDisposed()) {
                        chart = echarts.getInstanceByDom(el) || echarts.init(el);
                        this.roadSyntaxScatterChart = chart;
                    }
                    const rv = this.roadSyntaxRegressionView();
                    const xMin = Math.min(...points.map((p) => p[0]));
                    const xMax = Math.max(...points.map((p) => p[0]));
                    const lineData = Number.isFinite(rv.slope) && Number.isFinite(rv.intercept)
                        ? [
                            [xMin, rv.slope * xMin + rv.intercept],
                            [xMax, rv.slope * xMax + rv.intercept],
                        ]
                        : [];
                    try {
                        chart.setOption({
                            animation: false,
                            grid: { left: 42, right: 16, top: 20, bottom: 34 },
                            xAxis: { type: 'value', name: '连接度', nameLocation: 'middle', nameGap: 26, splitLine: { lineStyle: { color: '#eef2f7' } } },
                            yAxis: { type: 'value', name: '整合度', nameGap: 14, splitLine: { lineStyle: { color: '#eef2f7' } } },
                            series: [
                                {
                                    type: 'scatter',
                                    data: points,
                                    symbolSize: 6,
                                    z: 3,
                                    itemStyle: {
                                        color: '#2563eb',
                                        opacity: 0.82,
                                        borderColor: '#ffffff',
                                        borderWidth: 0.8,
                                    },
                                    emphasis: { scale: false },
                                },
                                {
                                    type: 'line',
                                    data: lineData,
                                    showSymbol: false,
                                    z: 2,
                                    lineStyle: { width: 2, color: '#dc2626', opacity: lineData.length ? 0.9 : 0 },
                                },
                            ],
                            graphic: [],
                        }, true);
                    } catch (err) {
                        console.warn('[road-syntax] scatter setOption failed, retry with simplified series', err);
                        chart.clear();
                        chart.setOption({
                            animation: false,
                            grid: { left: 42, right: 16, top: 20, bottom: 34 },
                            xAxis: { type: 'value', name: '连接度', nameLocation: 'middle', nameGap: 26 },
                            yAxis: { type: 'value', name: '整合度', nameGap: 14 },
                            series: [{
                                type: 'scatter',
                                data: points,
                                symbolSize: 6,
                                itemStyle: { color: '#2563eb', opacity: 0.85 },
                                emphasis: { scale: false },
                            }],
                            graphic: [],
                        }, true);
                    }
                    chart.resize();
                    if (String(this.roadSyntaxStatus || '').indexOf('可理解度样本为空') >= 0) {
                        this.roadSyntaxSetStatus('');
                    }
                    return true;
                },
                normalizeRoadSyntaxScatterPoints(rawPoints) {
                    const list = Array.isArray(rawPoints) ? rawPoints : [];
                    const out = [];
                    list.forEach((row) => {
                        let x = NaN;
                        let y = NaN;
                        if (Array.isArray(row)) {
                            x = Number(row[0]);
                            y = Number(row[1]);
                        } else if (row && typeof row === 'object') {
                            x = Number(row.x);
                            if (!Number.isFinite(x)) x = Number(row.connectivity_score ?? row.connectivity ?? row.degree_score ?? row.degree);
                            y = Number(row.y);
                            if (!Number.isFinite(y)) y = Number(row.integration_global ?? row.integration_score ?? row.integration);
                        }
                        if (Number.isFinite(x) && Number.isFinite(y)) {
                            out.push([x, y]);
                        }
                    });
                    if (out.length > 8000) {
                        const stride = Math.max(1, Math.ceil(out.length / 8000));
                        return out.filter((_, idx) => idx % stride === 0);
                    }
                    return out;
                },
                buildRoadSyntaxScatterFallbackPoints() {
                    let points = [];
                    const nodes = Array.isArray(this.roadSyntaxNodes) ? this.roadSyntaxNodes : [];
                    if (nodes.length) {
                        points = nodes.map((f) => {
                            const props = (f && f.properties) || {};
                            const x = Number.isFinite(Number(props.degree_score))
                                ? Number(props.degree_score)
                                : Number(props.degree);
                            return [x, Number(props.integration_global)];
                        }).filter((p) => Number.isFinite(p[0]) && Number.isFinite(p[1]));
                    }
                    if (!points.length) {
                        const roads = Array.isArray(this.roadSyntaxRoadFeatures) ? this.roadSyntaxRoadFeatures : [];
                        points = roads.map((f) => {
                            const props = (f && f.properties) || {};
                            return [Number(props.connectivity_score), Number(props.integration_global)];
                        }).filter((p) => Number.isFinite(p[0]) && Number.isFinite(p[1]));
                    }
                    if (points.length > 8000) {
                        const stride = Math.max(1, Math.ceil(points.length / 8000));
                        points = points.filter((_, idx) => idx % stride === 0);
                    }
                    return points;
                },
                buildRoadSyntaxRenderItems(features) {
                    const out = [];
                    let invalidCount = 0;
                    const invalidSamples = [];
                    (Array.isArray(features) ? features : []).forEach((feature, idx) => {
                        const coords = this.normalizePath((((feature || {}).geometry || {}).coordinates || []), 2, 'road_syntax.render_items.path');
                        if (!coords.length) {
                            invalidCount += 1;
                            if (invalidSamples.length < 5) {
                                const props = ((feature || {}).properties || {});
                                invalidSamples.push({
                                    idx: idx,
                                    id: props.edge_id || props.id || '',
                                    name: props.name || ''
                                });
                            }
                            return;
                        }
                        out.push({
                            coords: coords,
                            boundsRect: this.buildRoadSyntaxBoundsRect(coords),
                            props: ((feature || {}).properties || {}),
                        });
                    });
                    if (invalidCount > 0) {
                        console.warn('[road-syntax] skipped invalid road geometries', {
                            invalid_count: invalidCount,
                            total_features: Array.isArray(features) ? features.length : 0,
                            samples: invalidSamples
                        });
                    }
                    return out;
                },
                buildRoadSyntaxRenderFingerprint(items) {
                    const list = Array.isArray(items) ? items : [];
                    if (!list.length) return '0';
                    const first = list[0] || {};
                    const last = list[list.length - 1] || {};
                    const firstPt = this.normalizeLngLat((first.coords || [])[0], 'road_syntax.render_fingerprint.first') || [0, 0];
                    const lastCoords = last.coords || [];
                    const lastPt = this.normalizeLngLat(lastCoords[lastCoords.length - 1], 'road_syntax.render_fingerprint.last') || [0, 0];
                    return `${list.length}|${firstPt[0].toFixed(6)},${firstPt[1].toFixed(6)}|${lastPt[0].toFixed(6)},${lastPt[1].toFixed(6)}`;
                },
                rebuildRoadSyntaxBasePolylines() {
                    this.roadSyntaxPolylines = [];
                    this.roadSyntaxLayerLodIndexCache = {};
                    this.roadSyntaxTargetVisibleLineSet = {};
                    this.roadSyntaxAppliedVisibleLineSet = {};
                    this.roadSyntaxResetVisibleIndexCache();
                    this.roadSyntaxResetLodScoreCache();
                    this.roadSyntaxResetSpatialIndex();
                    return [];
                },
                isRoadSyntaxLayerReady(layerKey) {
                    if (this.roadSyntaxStrictWebglOnly) {
                        return !!(
                            this.roadSyntaxUseArcgisWebgl
                            && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                            && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                        );
                    }
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    ) {
                        return true;
                    }
                    const state = this.roadSyntaxLayerBuildState || {};
                    const styleCache = this.roadSyntaxLayerStyleCache || {};
                    return !!styleCache[layerKey] && state[layerKey] === 'ready';
                },
                enqueueRoadSyntaxLayerBuild(layerKey, options = {}) {
                    if (this.roadSyntaxStrictWebglOnly) return;
                    if (!this.roadSyntaxMap() || !window.AMap) return;
                    if (!Array.isArray(this.roadSyntaxPolylineItems) || !this.roadSyntaxPolylineItems.length) return;
                    const priority = !!(options && options.priority);
                    const switchOnReady = !!(options && options.switchOnReady);
                    const state = Object.assign({}, this.roadSyntaxLayerBuildState || {});
                    const queue = Array.isArray(this.roadSyntaxLayerBuildQueue) ? this.roadSyntaxLayerBuildQueue.slice() : [];
                    const cur = state[layerKey];

                    if (cur === 'ready') {
                        if (switchOnReady) {
                            this.roadSyntaxPendingLayerKey = layerKey;
                            this.switchRoadSyntaxLayerByKey(layerKey);
                        }
                        return;
                    }
                    if (cur === 'building' || cur === 'queued') {
                        if (switchOnReady) {
                            this.roadSyntaxPendingLayerKey = layerKey;
                        }
                        return;
                    }

                    state[layerKey] = 'queued';
                    if (priority) {
                        queue.unshift(layerKey);
                    } else {
                        queue.push(layerKey);
                    }
                    if (switchOnReady) {
                        this.roadSyntaxPendingLayerKey = layerKey;
                    }
                    this.roadSyntaxLayerBuildState = state;
                    this.roadSyntaxLayerBuildQueue = queue;
                    this.scheduleRoadSyntaxLayerBuilder();
                },
                scheduleRoadSyntaxLayerBuilder() {
                    if (this.roadSyntaxLayerBuildRunning) return;
                    const queue = Array.isArray(this.roadSyntaxLayerBuildQueue) ? this.roadSyntaxLayerBuildQueue : [];
                    if (!queue.length) return;
                    const layerKey = queue.shift();
                    this.roadSyntaxLayerBuildQueue = queue;
                    const state = Object.assign({}, this.roadSyntaxLayerBuildState || {});
                    state[layerKey] = 'building';
                    this.roadSyntaxLayerBuildState = state;
                    this.roadSyntaxLayerBuildRunning = true;
                    const buildToken = this.roadSyntaxLayerBuildToken + 1;
                    this.roadSyntaxLayerBuildToken = buildToken;

                    const parsed = this.parseRoadSyntaxLayerKey(layerKey);
                    const metric = parsed.metric;
                    const metricField = this.resolveRoadSyntaxMetricField(metric, parsed.radiusLabel);
                    const fallbackField = this.resolveRoadSyntaxFallbackField(metric);
                    const items = Array.isArray(this.roadSyntaxPolylineItems) ? this.roadSyntaxPolylineItems : [];
                    const styles = [];

                    let index = 0;
                    const step = () => {
                        if (buildToken !== this.roadSyntaxLayerBuildToken) return;
                        if (this.roadSyntaxIsInteractingInMetricView()) {
                            window.setTimeout(() => {
                                if (buildToken !== this.roadSyntaxLayerBuildToken) return;
                                window.requestAnimationFrame(step);
                            }, 60);
                            return;
                        }
                        const nowFn = (window.performance && typeof window.performance.now === 'function')
                            ? () => window.performance.now()
                            : () => Date.now();
                        const frameStart = nowFn();
                        const budgetMs = this.roadSyntaxResolveFrameBudget('layer');
                        while (index < items.length) {
                            const item = items[index] || {};
                            index += 1;
                            const style = this.buildRoadSyntaxStyleForMetric(
                                (item && item.props) || {},
                                metricField,
                                fallbackField,
                                metric,
                                parsed.skeletonOnly
                            );
                            styles.push(style);
                            if ((nowFn() - frameStart) >= budgetMs) {
                                break;
                            }
                        }
                        if (index < items.length) {
                            window.requestAnimationFrame(step);
                            return;
                        }
                        const styleCache = Object.assign({}, this.roadSyntaxLayerStyleCache || {});
                        styleCache[layerKey] = styles;
                        this.roadSyntaxLayerStyleCache = styleCache;
                        const map = this.roadSyntaxMap();
                        const pool = Object.assign({}, this.roadSyntaxLayerPool || {});
                        if (pool[layerKey]) {
                            this.roadSyntaxDisposeLayerEntry(pool[layerKey], map);
                        }
                        const fullLayer = this.roadSyntaxBuildLayerFromStyles(layerKey, styles, {
                            variant: 'full',
                        });
                        const lodIndexSet = this.roadSyntaxBuildLayerLodIndexSet(layerKey);
                        const lodLayer = this.roadSyntaxBuildLayerFromStyles(layerKey, styles, {
                            variant: 'lod',
                            includeIndexSet: lodIndexSet,
                            zIndexBoost: 3,
                        });
                        fullLayer.lodLayer = lodLayer;
                        fullLayer.lodIndexSet = this.roadSyntaxCloneIndexSet(lodLayer.indexSet || lodIndexSet);
                        pool[layerKey] = fullLayer;
                        this.roadSyntaxLayerPool = pool;
                        const doneState = Object.assign({}, this.roadSyntaxLayerBuildState || {});
                        doneState[layerKey] = 'ready';
                        this.roadSyntaxLayerBuildState = doneState;
                        this.roadSyntaxLayerBuildRunning = false;
                        const readyMap = this.refreshRoadSyntaxLayerReadyMap();
                        const readyCount = Object.values(readyMap).filter((v) => !!v).length;
                        const totalCount = Object.keys(readyMap).length;
                        if (totalCount > 0 && readyCount >= totalCount) {
                            const hadDegraded = !!this.roadSyntaxPoolDegraded;
                            this.roadSyntaxPoolReady = true;
                            this.roadSyntaxPoolDegraded = false;
                            if (this.roadSyntaxPoolInitRunning) {
                                this.roadSyntaxPoolInitRunning = false;
                            }
                            if (hadDegraded && this.roadSyntaxUseLegacyPoolStatus()) {
                                this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层补建完成', readyCount, totalCount));
                            }
                        } else if (this.roadSyntaxPoolInitRunning && this.roadSyntaxUseLegacyPoolStatus()) {
                            this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层预加载中', readyCount, totalCount));
                        }
                        if (this.roadSyntaxPendingLayerKey === layerKey) {
                            this.switchRoadSyntaxLayerByKey(layerKey, { force: true });
                        }
                        this.scheduleRoadSyntaxLayerBuilder();
                    };
                    window.requestAnimationFrame(step);
                },
                switchRoadSyntaxLayerByKey(layerKey, options = {}) {
                    const map = this.roadSyntaxMap();
                    if (!map) return;
                    const trackPerf = !options || options.trackPerf !== false;
                    const startAt = this.roadSyntaxNow();
                    if (!this.roadSyntaxUseArcgisWebgl) {
                        this.roadSyntaxSetStatus('ArcGIS-WebGL 未启用，旧版回退已禁用');
                        return;
                    }
                    if (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    ) {
                        this.roadSyntaxActiveLayerKey = String(layerKey || this.resolveRoadSyntaxLayerKey(this.resolveRoadSyntaxActiveMetric()));
                        this.roadSyntaxActiveLayerVariant = 'full';
                        this.roadSyntaxPendingLayerKey = '';
                        this.roadSyntaxDisplaySuspended = false;
                        if (typeof this.renderRoadSyntaxArcgisWebgl === 'function') {
                            this.renderRoadSyntaxArcgisWebgl(this.roadSyntaxWebglPayload, {
                                hideWhenSuspended: true,
                            }).then((ok) => {
                                if (ok) {
                                    if (trackPerf) {
                                        this.recordRoadSyntaxSwitchDuration(startAt, layerKey, 0, 0, 'arcgis_webgl');
                                    }
                                } else if (this.roadSyntaxStrictWebglOnly) {
                                    this.roadSyntaxSetStatus('ArcGIS-WebGL 切换失败（已禁用旧版回退）');
                                }
                            }).catch((err) => {
                                console.warn('[road-syntax] arcgis webgl switch render failed', err);
                                if (this.roadSyntaxStrictWebglOnly) {
                                    this.roadSyntaxSetStatus('ArcGIS-WebGL 切换失败（已禁用旧版回退）');
                                }
                            });
                        } else if (this.roadSyntaxStrictWebglOnly) {
                            this.roadSyntaxSetStatus('ArcGIS-WebGL 渲染器不可用（已禁用旧版回退）');
                        }
                        return;
                    }
                    this.roadSyntaxSetStatus('ArcGIS-WebGL 数据未就绪（已禁用旧版回退）');
                },
                warmRoadSyntaxLayerPool(activeLayerKey = '') {
                    const state = this.roadSyntaxLayerBuildState || {};
                    const keys = this.roadSyntaxLayerKeysForPrebuild().filter((key) => {
                        if (key === activeLayerKey) return false;
                        const s = state[key];
                        return s !== 'ready' && s !== 'building' && s !== 'queued';
                    });
                    keys.forEach((key) => this.enqueueRoadSyntaxLayerBuild(key, { priority: false, switchOnReady: false }));
                },
                waitRoadSyntaxLayerReady(layerKey, timeoutMs = ROAD_SYNTAX_CONST.PREBUILD_DEADLINE_MS) {
                    return new Promise((resolve) => {
                        const start = Date.now();
                        const tick = () => {
                            if (this.isRoadSyntaxLayerReady(layerKey)) {
                                resolve(true);
                                return;
                            }
                            if ((Date.now() - start) > timeoutMs) {
                                resolve(false);
                                return;
                            }
                            window.setTimeout(tick, 25);
                        };
                        tick();
                    });
                },
                prewarmRoadSyntaxLayerVisibility(requestToken, activeLayerKey = '') {
                    if (requestToken !== this.roadSyntaxRequestToken) return Promise.resolve(false);
                    return Promise.resolve(true);
                },
                prewarmRoadSyntaxSwitchPath(requestToken, activeLayerKey = '') {
                    return Promise.resolve(requestToken === this.roadSyntaxRequestToken);
                },
                async initializeRoadSyntaxPoolFully(requestToken, activeLayerKey = '') {
                    if (this.roadSyntaxStrictWebglOnly) {
                        this.roadSyntaxPoolInitRunning = false;
                        this.roadSyntaxPoolReady = true;
                        this.roadSyntaxPoolDegraded = false;
                        this.roadSyntaxPoolInitTotal = 1;
                        this.roadSyntaxPoolInitDone = 1;
                        return true;
                    }
                    const keysRaw = this.roadSyntaxLayerKeysForPrebuild();
                    const keys = activeLayerKey
                        ? [activeLayerKey].concat(keysRaw.filter((key) => key !== activeLayerKey))
                        : keysRaw.slice();
                    if (!keys.length) {
                        this.roadSyntaxPoolReady = true;
                        this.roadSyntaxPoolDegraded = false;
                        return true;
                    }
                    const totalBudgetMs = Number(this.roadSyntaxPrebuildDeadlineMs || ROAD_SYNTAX_CONST.PREBUILD_DEADLINE_MS);
                    const startedAt = Date.now();
                    this.roadSyntaxPoolInitRunning = true;
                    this.roadSyntaxPoolReady = false;
                    this.roadSyntaxPoolDegraded = false;
                    this.roadSyntaxPoolInitTotal = keys.length;
                    this.roadSyntaxPoolInitDone = 0;
                    if (this.roadSyntaxUseLegacyPoolStatus()) {
                        this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层预加载中', 0, keys.length));
                    }
                    this.refreshRoadSyntaxLayerReadyMap();
                    keys.forEach((key, idx) => this.enqueueRoadSyntaxLayerBuild(key, {
                        priority: idx === 0,
                        switchOnReady: false,
                    }));

                    let partial = false;
                    for (let i = 0; i < keys.length; i += 1) {
                        if (requestToken !== this.roadSyntaxRequestToken) {
                            this.roadSyntaxPoolInitRunning = false;
                            return false;
                        }
                        const elapsed = Date.now() - startedAt;
                        const remaining = totalBudgetMs - elapsed;
                        if (remaining <= 0) {
                            partial = true;
                            break;
                        }
                        const ok = await this.waitRoadSyntaxLayerReady(keys[i], remaining);
                        if (!ok) {
                            partial = true;
                            break;
                        }
                        this.roadSyntaxPoolInitDone = i + 1;
                        if (this.roadSyntaxUseLegacyPoolStatus()) {
                            this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层预加载中', this.roadSyntaxPoolInitDone, this.roadSyntaxPoolInitTotal));
                        }
                    }
                    this.roadSyntaxPoolInitRunning = false;
                    const readyMap = this.refreshRoadSyntaxLayerReadyMap();
                    const readyCount = Object.values(readyMap).filter((v) => !!v).length;
                    const allReady = readyCount >= keys.length;
                    this.roadSyntaxPoolReady = allReady;
                    this.roadSyntaxPoolDegraded = !allReady;
                    if (allReady) {
                        if (this.roadSyntaxUseLegacyPoolStatus()) {
                            this.roadSyntaxSetStatus(this.roadSyntaxFormatReadyStatus('图层预加载完成', readyCount, keys.length));
                        }
                        if (this.roadSyntaxEnableHeavyPrewarm) {
                            const prewarmToken = this.roadSyntaxPrewarmToken + 1;
                            this.roadSyntaxPrewarmToken = prewarmToken;
                            window.setTimeout(async () => {
                                if (prewarmToken !== this.roadSyntaxPrewarmToken) return;
                                if (requestToken !== this.roadSyntaxRequestToken) return;
                                try {
                                    await this.prewarmRoadSyntaxLayerVisibility(requestToken, activeLayerKey || keys[0] || '');
                                    await this.prewarmRoadSyntaxSwitchPath(requestToken, activeLayerKey || keys[0] || '');
                                } catch (_) { }
                            }, 0);
                        }
                    }
                    if (!allReady && partial) {
                        if (this.roadSyntaxUseLegacyPoolStatus()) {
                            this.roadSyntaxSetStatus(`图层预加载超时，进入降级模式：${readyCount}/${keys.length}`);
                        }
                    }
                    return allReady;
                },
                renderRoadSyntaxOverlays(roadsFeatureCollection, options = {}) {
                    if (this.roadSyntaxStrictWebglOnly) {
                        this.roadSyntaxSetStatus('ArcGIS-WebGL 模式已启用，旧版图层渲染已禁用');
                        return;
                    }
                    if (!this.roadSyntaxMap() || !window.AMap) return;
                    if (typeof this.clearRoadSyntaxArcgisWebgl === 'function') {
                        this.clearRoadSyntaxArcgisWebgl({ dispose: false });
                    }
                    const forceRebuild = Boolean(options && options.forceRebuild);
                    const displayActive = !(options && options.displayActive === false);
                    const features = ((roadsFeatureCollection || {}).features || []);
                    this.roadSyntaxRoadFeatures = Array.isArray(features) ? features : [];
                    if (!this.roadSyntaxRoadFeatures.length) {
                        this.clearRoadSyntaxOverlays();
                        return;
                    }
                    const renderItems = this.buildRoadSyntaxRenderItems(this.roadSyntaxRoadFeatures);
                    if (!renderItems.length) {
                        this.clearRoadSyntaxOverlays();
                        return;
                    }
                    const fingerprint = this.buildRoadSyntaxRenderFingerprint(renderItems);
                    const shouldRebuildPool = forceRebuild
                        || !this.roadSyntaxSourceFingerprint
                        || this.roadSyntaxSourceFingerprint !== fingerprint
                        || !Object.keys(this.roadSyntaxLayerPool || {}).length;
                    if (shouldRebuildPool) {
                        this.roadSyntaxPoolWarmToken += 1;
                        this.roadSyntaxLayerBuildToken += 1;
                        this.roadSyntaxLayerSwitchToken += 1;
                        this.clearRoadSyntaxLayerPool();
                        this.roadSyntaxPolylineItems = renderItems;
                        this.roadSyntaxSourceFingerprint = fingerprint;
                        this.roadSyntaxPoolRadiusLabel = String(this.roadSyntaxRadiusLabel || 'global');
                        this.roadSyntaxPoolReady = false;
                        this.roadSyntaxPoolDegraded = false;
                        this.rebuildRoadSyntaxBasePolylines();
                    }
                    this.roadSyntaxResetVisibleIndexCache();
                    this.roadSyntaxResetLodScoreCache();
                    const activeMetric = this.resolveRoadSyntaxActiveMetric();
                    const activeLayerKey = this.resolveRoadSyntaxLayerKey(activeMetric);
                    if (displayActive) {
                        if (this.isRoadSyntaxLayerReady(activeLayerKey)) {
                            const desiredVariant = this.roadSyntaxResolveDesiredLayerVariant();
                            const forceSwitch = this.roadSyntaxDisplaySuspended
                                || !this.roadSyntaxGetLayer(activeLayerKey);
                            this.switchRoadSyntaxLayerByKey(activeLayerKey, {
                                force: forceSwitch,
                                preferVariant: desiredVariant,
                            });
                        } else {
                            this.enqueueRoadSyntaxLayerBuild(activeLayerKey, { priority: true, switchOnReady: true });
                            const counts = this.roadSyntaxLayerReadyCounts();
                            if (this.roadSyntaxUseLegacyPoolStatus()) {
                                this.roadSyntaxSetStatus(`图层预处理中：${counts.ready}/${counts.total || 0}`);
                            }
                        }
                        this.roadSyntaxLogOverlayHealth('render-road-syntax');
                    }
                    this.warmRoadSyntaxLayerPool(activeLayerKey);
                    this.refreshRoadSyntaxLayerReadyMap();
                    this.roadSyntaxPolylineItems = renderItems;
                },
                buildRoadSyntaxRequestPayload(polygon, edgeCap) {
                    const activeMetric = this.resolveRoadSyntaxActiveMetric();
                    const metricField = this.resolveRoadSyntaxMetricField(activeMetric);
                    const useArcgisWebgl = this.roadSyntaxStrictWebglOnly ? true : !!this.roadSyntaxUseArcgisWebgl;
                    const shouldBypassCap = activeMetric === 'control' || activeMetric === 'depth' || activeMetric === 'connectivity' || activeMetric === 'intelligibility';
                    return {
                        polygon: polygon,
                        coord_type: 'gcj02',
                        mode: this.roadSyntaxMode || this.transportMode || 'walking',
                        include_geojson: true,
                        max_edge_features: shouldBypassCap ? null : edgeCap,
                        merge_geojson_edges: true,
                        merge_bucket_step: 0.025,
                        radii_m: [800, 2000],
                        metric: this.resolveRoadSyntaxRequestMetric(),
                        use_arcgis_webgl: useArcgisWebgl,
                        arcgis_timeout_sec: 20,
                        arcgis_metric_field: metricField,
                    };
                },
                applyRoadSyntaxResponseData(data, preferredMetricTab = 'connectivity') {
                    this.roadSyntaxRoadFeatures = Array.isArray((data && data.roads && data.roads.features) || [])
                        ? data.roads.features
                        : [];
                    this.roadSyntaxNodes = Array.isArray((data && data.nodes && data.nodes.features) || [])
                        ? data.nodes.features
                        : [];
                    this.roadSyntaxDiagnostics = (data && data.diagnostics) ? data.diagnostics : null;
                    this.roadSyntaxScatterPointsCache = this.normalizeRoadSyntaxScatterPoints(
                        this.roadSyntaxDiagnostics && this.roadSyntaxDiagnostics.intelligibility_scatter
                    );
                    this.roadSyntaxSummary = data && data.summary ? data.summary : null;
                    this.roadSyntaxWebglPayload = (data && data.webgl && typeof data.webgl === 'object')
                        ? data.webgl
                        : null;
                    this.roadSyntaxWebglStatus = String((this.roadSyntaxWebglPayload && this.roadSyntaxWebglPayload.status) || '');
                    this.roadSyntaxSkeletonOnly = false;
                    if (!this.roadSyntaxSummary) return;
                    const validMetrics = this.roadSyntaxMetricTabs().map((item) => item.value);
                    const preferred = validMetrics.includes(preferredMetricTab)
                        ? preferredMetricTab
                        : this.roadSyntaxDefaultMetric();
                    const targetMetric = preferred;
                    this.roadSyntaxMetric = targetMetric;
                    this.roadSyntaxLastMetricTab = targetMetric;
                    const radiusOptions = this.roadSyntaxRadiusOptions();
                    const candidateRadius = String(this.roadSyntaxSummary.default_radius_label || 'global');
                    const hasCandidate = radiusOptions.some((opt) => opt.value === candidateRadius);
                    if (this.roadSyntaxMetricUsesRadius(targetMetric)) {
                        this.roadSyntaxRadiusLabel = hasCandidate ? candidateRadius : 'global';
                    } else {
                        this.roadSyntaxRadiusLabel = 'global';
                    }
                },
                buildRoadSyntaxCompletionStatus(poolReady) {
                    if (!this.roadSyntaxSummary) return '完成：未返回有效汇总数据';
                    const engine = this.roadSyntaxSummary.analysis_engine || 'depthmapxcli';
                    const base = `完成：${this.roadSyntaxSummary.node_count || 0} 节点，${this.roadSyntaxSummary.edge_count || 0} 边段（${engine}`;
                    const controlValid = Number(this.roadSyntaxSummary.control_valid_count || 0);
                    const depthValid = Number(this.roadSyntaxSummary.depth_valid_count || 0);
                    const controlCol = String(this.roadSyntaxSummary.control_source_column || '');
                    const depthCol = String(this.roadSyntaxSummary.depth_source_column || '');
                    let metricHint = '';
                    if (controlValid <= 0 || depthValid <= 0) {
                        metricHint = `；control=${controlValid}${controlCol ? `(${controlCol})` : ''}, depth=${depthValid}${depthCol ? `(${depthCol})` : ''}`;
                    }
                    const webglPayloadReady = (
                        this.roadSyntaxUseArcgisWebgl
                        && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                        && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                    );
                    const webglActive = (typeof this.roadSyntaxIsArcgisWebglActive === 'function')
                        ? this.roadSyntaxIsArcgisWebglActive()
                        : (webglPayloadReady && !!this.roadSyntaxWebglActive);
                    if (
                        webglActive
                    ) {
                        return `${base}，ArcGIS-WebGL 已就绪${metricHint}）`;
                    }
                    if (webglPayloadReady) {
                        return `${base}，ArcGIS 数据已返回，但 WebGL 渲染未激活${metricHint}）`;
                    }
                    return `${base}，ArcGIS-WebGL 未就绪（已禁用旧版回退${metricHint}）`;
                },
                async computeRoadSyntax() {
                    if (!this.lastIsochroneGeoJSON || this.isComputingRoadSyntax) return;
                    if (this.roadSyntaxMainTab !== 'params') {
                        this.setRoadSyntaxMainTab('params', { refresh: false, syncMetric: false });
                    }
                    if (this.roadSyntaxStrictWebglOnly) {
                        this.roadSyntaxUseArcgisWebgl = true;
                    }
                    this.isComputingRoadSyntax = true;
                    this.roadSyntaxStatusCopyHint = '';
                    this.roadSyntaxSetStatus('正在请求路网并计算空间句法指标...');
                    const requestToken = this.roadSyntaxRequestToken + 1;
                    this.roadSyntaxRequestToken = requestToken;
                    const preferredMetricTab = this.roadSyntaxLastMetricTab || this.roadSyntaxMetric || this.roadSyntaxDefaultMetric();

                    try {
                        const polygon = this.getIsochronePolygonPoints();
                        if (!polygon.length) {
                            throw new Error('等时圈范围无效');
                        }
                        this.invalidateRoadSyntaxCache('recompute-road-syntax', { resetData: false, resetPerf: true });
                        this.roadSyntaxSummary = null;
                        this.roadSyntaxRoadFeatures = [];
                        this.roadSyntaxNodes = [];
                        this.roadSyntaxDiagnostics = null;
                        this.roadSyntaxLegendModel = null;
                        const edgeCap = this.resolveRoadSyntaxEdgeCap();
                        const payload = this.buildRoadSyntaxRequestPayload(polygon, edgeCap);

                        const res = await fetch('/api/v1/analysis/road-syntax', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                detail = await res.text();
                            } catch (_) { }
                            throw new Error(detail || '路网分析失败');
                        }
                        const data = await res.json();
                        if (requestToken !== this.roadSyntaxRequestToken) {
                            return;
                        }
                        this.applyRoadSyntaxResponseData(data, preferredMetricTab);
                        const webglPayloadReady = (
                            this.roadSyntaxUseArcgisWebgl
                            && typeof this.roadSyntaxCanUseArcgisWebglPayload === 'function'
                            && this.roadSyntaxCanUseArcgisWebglPayload(this.roadSyntaxWebglPayload)
                        );
                        if (!webglPayloadReady) {
                            throw new Error('ArcGIS-WebGL 数据未就绪（已禁用旧版回退）');
                        }

                        let webglRendered = false;
                        try {
                            if (typeof this.renderRoadSyntaxArcgisWebgl !== 'function') {
                                throw new Error('ArcGIS-WebGL 渲染器不可用');
                            }
                            webglRendered = await this.renderRoadSyntaxArcgisWebgl(this.roadSyntaxWebglPayload, {
                                hideWhenSuspended: true,
                            });
                        } catch (err) {
                            console.warn('[road-syntax] arcgis webgl initial render failed', err);
                            webglRendered = false;
                        }
                        if (!webglRendered) {
                            const webglReason = String(this.roadSyntaxWebglStatus || '').trim();
                            throw new Error(
                                webglReason
                                    ? `ArcGIS-WebGL 渲染失败（已禁用旧版回退）: ${webglReason}`
                                    : 'ArcGIS-WebGL 渲染失败（已禁用旧版回退）'
                            );
                        }
                        this.roadSyntaxPoolReady = true;
                        this.roadSyntaxPoolDegraded = false;
                        this.roadSyntaxPoolInitRunning = false;
                        this.roadSyntaxPoolInitTotal = 1;
                        this.roadSyntaxPoolInitDone = 1;

                        const poolReady = true;
                        if (this.roadSyntaxSummary) {
                            this.setRoadSyntaxMainTab(this.roadSyntaxLastMetricTab || this.roadSyntaxDefaultMetric(), {
                                refresh: false,
                                syncMetric: true,
                            });
                            if (this.activeStep3Panel === 'syntax') {
                                await this.renderRoadSyntaxByMetric(this.roadSyntaxLastMetricTab || this.roadSyntaxMetric || this.roadSyntaxDefaultMetric());
                            }
                        }
                        this.roadSyntaxSetStatus(this.buildRoadSyntaxCompletionStatus(poolReady));
                    } catch (e) {
                        if (requestToken !== this.roadSyntaxRequestToken) {
                            return;
                        }
                        console.error(e);
                        this.roadSyntaxSetStatus('失败: ' + (e && e.message ? e.message : String(e)));
                    } finally {
                        this.isComputingRoadSyntax = false;
                    }
                },
                clearAoiMarkers() {
                    if (!Array.isArray(this.aoiMarkers)) {
                        this.aoiMarkers = [];
                        return;
                    }
                    const markers = this.aoiMarkers.slice();
                    this.aoiMarkers = [];
                    if (!markers.length) return;
                    markers.forEach((marker) => this.safeMapSet(marker, null));
                },
                renderAois(aois) {
                    this.clearAoiMarkers();
                    if (!this.mapCore || !this.mapCore.map || !window.AMap) return;
                    const list = Array.isArray(aois) ? aois : [];
                    const markers = [];
                    let invalidCount = 0;
                    const invalidSamples = [];
                    list.forEach((aoi) => {
                        const loc = this.normalizeLngLat(aoi && aoi.location, 'aoi.render.location');
                        if (!loc) {
                            invalidCount += 1;
                            if (invalidSamples.length < 5) {
                                invalidSamples.push({
                                    id: (aoi && aoi.id) || '',
                                    name: (aoi && aoi.name) || '',
                                    location: this.roadSyntaxSummarizeCoordInput(aoi && aoi.location)
                                });
                            }
                            return;
                        }
                        const marker = new AMap.CircleMarker({
                            center: loc,
                            radius: 5,
                            strokeColor: '#ffffff',
                            strokeWeight: 1,
                            fillColor: '#16a34a',
                            fillOpacity: 0.9,
                            zIndex: 110,
                            bubble: true,
                            cursor: 'pointer',
                        });
                        marker.on('click', () => {
                            const name = (aoi && aoi.name) ? String(aoi.name) : String((aoi && aoi.id) || 'AOI');
                            const area = Number(aoi && aoi.area);
                            const areaText = Number.isFinite(area) ? `${(area / 1000000).toFixed(3)} km²` : '-';
                            const insideHits = Number(aoi && aoi.inside_hits);
                            const minDist = aoi && aoi.min_distance;
                            const info = [
                                `<div style="padding:6px 8px;">`,
                                `<div style="font-weight:600;">${name}</div>`,
                                `<div style="font-size:12px;color:#666;">ID: ${(aoi && aoi.id) || '-'}</div>`,
                                `<div style="font-size:12px;color:#666;">面积: ${areaText}</div>`,
                                `<div style="font-size:12px;color:#666;">inside_hits: ${Number.isFinite(insideHits) ? insideHits : 0} ｜ min_distance: ${minDist ?? '-'}</div>`,
                                `</div>`,
                            ];
                            new AMap.InfoWindow({
                                content: info.join(""),
                                offset: new AMap.Pixel(0, -6)
                            }).open(this.mapCore.map, loc);
                        });
                        markers.push(marker);
                    });
                    if (invalidCount > 0) {
                        console.warn('[aoi-render] skipped invalid coordinates', {
                            invalid_count: invalidCount,
                            total_candidates: list.length,
                            samples: invalidSamples
                        });
                    }
                    this.aoiMarkers = markers;
                    this.enqueueAoiMapWrite(() => {
                        const targetMap = (this.mapCore && this.mapCore.map) ? this.mapCore.map : null;
                        markers.forEach((marker) => this.safeMapSet(marker, targetMap));
                        return {
                            ok: true,
                            marker_count: markers.length,
                            visible: !!targetMap
                        };
                    }, {
                        key: 'render_markers',
                        replaceExisting: true,
                        meta: {
                            reason: 'aoi_render_markers',
                            marker_count: markers.length
                        }
                    });
                },
                async fetchAois() {
                    if (!this.lastIsochroneGeoJSON) return;
                    this.isFetchingAois = true;
                    this.fetchProgress = 0;
                    this.aoiStatus = '准备抓取...';
                    this.poiStatus = '';
                    this.resetFetchSubtypeProgress();

                    this.clearPoiOverlayLayers({
                        reason: 'fetch_aois_start',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        resetFilterPanel: true
                    });

                    this.clearAoiMarkers();
                    this.allPoisDetails = [];
                    this.allAoisDetails = [];
                    this.aoiSamplePoints = 0;
                    this.aoiTotalCalls = 0;
                    this.resetRoadSyntaxState();

                    try {
                        const polygon = this.getIsochronePolygonPoints();
                        if (!polygon.length) {
                            throw new Error('等时圈范围无效');
                        }

                        this.abortController = new AbortController();
                        this.fetchProgress = 30;

                        const payload = {
                            polygon: polygon,
                            h3_resolution: this.aoiH3Resolution,
                            max_points: this.aoiMaxPoints,
                            regeo_radius: this.aoiRegeoRadius,
                            spacing_m: 250,
                        };

                        const res = await fetch('/api/v1/analysis/aois', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            signal: this.abortController.signal,
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                detail = await res.text();
                            } catch (_) { }
                            throw new Error(detail || 'AOI 抓取失败');
                        }
                        this.fetchProgress = 85;
                        const data = await res.json();
                        const aois = Array.isArray(data && data.aois) ? data.aois : [];
                        this.allAoisDetails = aois;
                        this.aoiSamplePoints = Number(data && data.sample_points) || 0;
                        this.aoiTotalCalls = Number(data && data.total_calls) || 0;

                        this.renderAois(aois);
                        this.fetchProgress = 100;
                        this.aoiStatus = `完成！共 ${aois.length} 个 AOI（采样点 ${this.aoiSamplePoints}，请求 ${this.aoiTotalCalls}）`;
                        setTimeout(() => {
                            this.step = 3;
                            this.activeStep3Panel = 'aoi';
                        }, 120);
                    } catch (e) {
                        if (e.name !== 'AbortError') {
                            console.error(e);
                            this.aoiStatus = '失败: ' + e.message;
                        } else {
                            this.aoiStatus = '任务已取消';
                        }
                    } finally {
                        this.isFetchingAois = false;
                        this.abortController = null;
                    }
                },
                renderPois(pois) {
                    this.updateLegacySystem(Array.isArray(pois) ? pois : []);
                },
                toggleCategory() {
                    this.updateLegacySystem(Array.isArray(this.allPoisDetails) ? this.allPoisDetails : []);
                },
                renderResult(geojson) {
                    if (!geojson || !geojson.geometry) {
                        this.errorMessage = "未获取到有效数据";
                        return;
                    }
                    const coords = geojson.geometry.coordinates;
                    const type = geojson.geometry.type;
                    let paths = [];
                    if (type === 'Polygon') {
                        paths.push(coords[0]);
                    } else if (type === 'MultiPolygon') {
                        coords.forEach(poly => paths.push(poly[0]));
                    }
                    this.mapCore.setCustomPolygons(paths);
                },
                async loadHistoryList(options = {}) {
                    const force = !!(options && options.force);
                    const background = !!(options && options.background);
                    const keepExisting = options && Object.prototype.hasOwnProperty.call(options, 'keepExisting')
                        ? !!options.keepExisting
                        : (this.historyHasLoadedOnce && this.historyList.length > 0);
                    if (!force && this.historyHasLoadedOnce) {
                        return;
                    }
                    if (this.historyLoading && !force) {
                        return;
                    }
                    this.cancelHistoryLoading();
                    const sessionId = this.historyRenderSessionId;
                    this.historyLoading = true;
                    if (!keepExisting && !background) {
                        this.historyListRaw = [];
                        this.historyList = [];
                        this.historyLoadedCount = 0;
                    }
                    this.historyFetchAbortController = new AbortController();

                    try {
                        console.log("Loading history list...");
                        const res = await fetch('/api/v1/analysis/history', {
                            signal: this.historyFetchAbortController.signal
                        });
                        if (!res.ok) {
                            throw new Error(`历史记录请求失败(${res.status})`);
                        }
                        const data = await res.json();
                        console.log("History list loaded:", data);
                        if (sessionId !== this.historyRenderSessionId) return;
                        const normalized = Array.isArray(data)
                            ? data.map((item) => this.normalizeHistoryRecord(item))
                            : [];
                        this.historyListRaw = normalized;
                        this.historyList = normalized.slice();
                        this.historyLoadedCount = normalized.length;
                        this.historyLoading = false;
                        this.historyRenderRafId = null;
                        this.historyHasLoadedOnce = true;
                    } catch (e) {
                        if (e && e.name === 'AbortError') return;
                        console.error("History Load Error:", e);
                        if (sessionId !== this.historyRenderSessionId) return;
                        this.historyLoading = false;
                        if (!keepExisting && !background) {
                            this.historyListRaw = [];
                            this.historyList = [];
                            this.historyLoadedCount = 0;
                        }
                    } finally {
                        if (sessionId === this.historyRenderSessionId) {
                            this.historyFetchAbortController = null;
                        }
                    }
                },
                toggleSelectionMode(active) {
                    this.isSelectionMode = active;
                    this.selectedHistoryIds = [];
                },
                handleHistoryItemClick(item) {
                    if (this.isSelectionMode) {
                        const idx = this.selectedHistoryIds.indexOf(item.id);
                        if (idx > -1) {
                            this.selectedHistoryIds.splice(idx, 1);
                        } else {
                            this.selectedHistoryIds.push(item.id);
                        }
                    } else {
                        this.loadHistoryDetail(item.id);
                    }
                },
                async deleteSelectedHistory() {
                    const count = this.selectedHistoryIds.length;
                    if (count === 0) return;

                    if (!confirm(`确定要删除选中的 ${count} 条记录吗？`)) return;

                    try {
                        // Parallel delete (simple implementation)
                        // Ideally backend should support bulk delete
                        const deletePromises = this.selectedHistoryIds.map(id =>
                            fetch(`/api/v1/analysis/history/${id}`, { method: 'DELETE' })
                        );

                        await Promise.all(deletePromises);

                        const removedIds = new Set(this.selectedHistoryIds);
                        this.historyList = this.historyList.filter(item => !removedIds.has(item.id));
                        this.historyListRaw = this.historyListRaw.filter(item => !removedIds.has(item.id));
                        this.historyLoadedCount = this.historyList.length;
                        this.selectedHistoryIds = [];
                        this.isSelectionMode = false;

                    } catch (e) {
                        console.error("Batch delete failed", e);
                        alert("批量删除失败");
                    }
                },
                async deleteHistory(id) {
                    if (!confirm('确定要删除这条记录吗？')) return;
                    try {
                        await fetch(`/api/v1/analysis/history/${id}`, { method: 'DELETE' });
                        this.historyList = this.historyList.filter(item => item.id !== id);
                        this.historyListRaw = this.historyListRaw.filter(item => item.id !== id);
                        this.historyLoadedCount = this.historyList.length;
                    } catch (e) { console.error(e); }
                },
                async loadHistoryDetail(id) {
                    try {
                        this.cancelHistoryLoading();
                        if (!this.mapCore || !this.mapCore.map) {
                            this.errorMessage = '地图尚未初始化，请稍后重试';
                            return;
                        }

                        const res = await fetch(`/api/v1/analysis/history/${id}`);
                        const data = await res.json();
                        if (!data) return;

                        // Cleanup previous state
                        this.clearH3Grid();
                        this.clearPoiOverlayLayers({
                            reason: 'load_history_detail',
                            clearManager: true,
                            clearSimpleMarkers: true,
                            clearCenterMarker: true,
                            resetFilterPanel: true
                        });
                        this.mapCore.clearCustomPolygons();
                        this.clearAoiMarkers();
                        this.allAoisDetails = [];
                        this.aoiSamplePoints = 0;
                        this.aoiTotalCalls = 0;
                        this.aoiStatus = '';
                        this.resetRoadSyntaxState();

                        if (data.params && data.params.center) {
                            this.selectedPoint = { lng: data.params.center[0], lat: data.params.center[1] };
                            this.mapCore.map.setCenter(data.params.center);
                            this.mapCore.center = { lng: data.params.center[0], lat: data.params.center[1] }; // Sync MapCore center
                            this.mapCore.setRadius(0); // Reset radius to avoid ghost circle at old location
                            // Restore time horizon if available
                            if (data.params.time_min) this.timeHorizon = data.params.time_min;
                        }

                        if (data.polygon) {
                            this.mapCore.setCustomPolygons([data.polygon]);
                            this.lastIsochroneGeoJSON = { geometry: { type: 'Polygon', coordinates: [data.polygon] } };
                        }

                        // Switch to Results Step before building panels
                        this.step = 3;
                        this.sidebarView = 'wizard'; // Return to wizard
                        this.captureTarget = 'poi';
                        this.activeStep3Panel = 'poi';
                        this.poiStatus = '正在加载历史点位...';
                        await this.$nextTick();
                        await new Promise((resolve) => window.requestAnimationFrame(resolve));

                        if (data.pois) {
                            this.allPoisDetails = data.pois;
                            // Integration with Legacy Filter Panel
                            this.updateLegacySystem(data.pois);
                            this.poiStatus = `已加载历史: ${data.pois.length} 条`;
                        }
                        setTimeout(() => this.resizePoiChart(), 0);

                    } catch (e) {
                        console.error(e);
                        alert("加载失败");
                    }
                },
                formatHistoryTitle(desc) {
                    if (!desc) return '无标题分析';
                    // Remove "15min Analysis - " prefix if present to avoid redundancy with tags
                    return desc.replace(/^\d+min Analysis - /, '');
                },
                resetAnalysis() {
                    this.destroyPlaceSearch();
                    this.step = 1;
                    this.sidebarView = 'wizard';
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    if (this.marker) {
                        this.safeMapSet(this.marker, null);
                        this.marker = null;
                    }
                    this.clearAnalysisLayers();
                    if (this.mapCore && this.mapCore.map) {
                        this.mapCore.map.setFitView();
                    }
                },
                async triggerSearch() {
                    const input = document.getElementById('keyword');
                    const keyword = input && input.value ? String(input.value).trim() : '';
                    if (!keyword) return;
                    this.errorMessage = '';

                    if (this.step !== 1) {
                        this.errorMessage = '搜索仅在 Step1 可用';
                        return;
                    }
                    const ready = await this.ensurePlaceSearchReady();
                    if (!ready || !ready.ok) {
                        this.errorMessage = '搜索服务加载失败，请稍后重试';
                        return;
                    }
                    if (!this.placeSearch || typeof this.placeSearch.search !== 'function') {
                        this.errorMessage = '搜索服务未就绪，请稍后重试';
                        return;
                    }

                    const focusPoi = (poi) => {
                        if (!poi || !poi.location) return false;
                        if (this.mapCore && this.mapCore.map) {
                            this.mapCore.map.setZoomAndCenter(15, poi.location);
                        }
                        this.setSelectedPoint(poi.location);
                        return true;
                    };

                    const result = await this.runPlaceSearch(keyword);
                    if (result.pois.length > 0 && focusPoi(result.pois[0])) {
                        return;
                    }

                    if (result.serviceError) {
                        if (result.errorInfo && result.errorInfo.indexOf('OVER_LIMIT') >= 0) {
                            this.errorMessage = '高德搜索当日额度已用完（OVER_LIMIT），请更换 JS Key 或次日重试';
                        } else {
                            this.errorMessage = "搜索服务异常，请稍后重试";
                        }
                        return;
                    }
                    this.errorMessage = `未找到“${keyword}”相关地点，请尝试更具体关键词`;
                },
                saveAndRestart() {
                    this.destroyPlaceSearch();
                    this.step = 1;
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    this.poiStatus = '';
                    this.h3ExportMenuOpen = false;
                    this.h3ExportTasksOpen = false;
                    if (this.h3ToastTimer) {
                        clearTimeout(this.h3ToastTimer);
                        this.h3ToastTimer = null;
                    }
                    this.h3Toast = { message: '', type: 'info' };
                    this.clearPoiOverlayLayers({
                        reason: 'save_and_restart',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        clearCenterMarker: true,
                        resetFilterPanel: true
                    });
                    this.clearH3Grid();
                    if (this.mapCore && this.mapCore.clearCustomPolygons) {
                        this.mapCore.clearCustomPolygons();
                    }
                    this.disposePoiChart();
                },
                initPoiChart() {
                    const el = document.getElementById('poiChart');
                    if (!el || !window.echarts || el.clientWidth === 0) return null;

                    let chart = echarts.getInstanceByDom(el);
                    if (!chart) {
                        chart = echarts.init(el);
                        if (!this.poiChartResizeHandler) {
                            this.poiChartResizeHandler = () => this.resizePoiChart();
                            window.addEventListener('resize', this.poiChartResizeHandler);
                        }
                    }
                    this.poiChart = chart;
                    return chart;
                },
                resizePoiChart() {
                    if (this.poiChart) this.poiChart.resize();
                },
                disposePoiChart() {
                    if (this.poiChart) {
                        this.poiChart.dispose();
                        this.poiChart = null;
                    }
                    if (this.poiChartResizeHandler) {
                        window.removeEventListener('resize', this.poiChartResizeHandler);
                        this.poiChartResizeHandler = null;
                    }
                },
                disposeH3Charts() {
                    if (this.h3CategoryChart) {
                        this.h3CategoryChart.dispose();
                        this.h3CategoryChart = null;
                    }
                    if (this.h3DensityChart) {
                        this.h3DensityChart.dispose();
                        this.h3DensityChart = null;
                    }
                    if (this.h3LqChart) {
                        this.h3LqChart.dispose();
                        this.h3LqChart = null;
                    }
                    if (this.h3GapChart) {
                        this.h3GapChart.dispose();
                        this.h3GapChart = null;
                    }
                    if (this.h3StructureChart) {
                        this.h3StructureChart.dispose();
                        this.h3StructureChart = null;
                    }
                    if (this.h3ChartsResizeHandler) {
                        window.removeEventListener('resize', this.h3ChartsResizeHandler);
                        this.h3ChartsResizeHandler = null;
                    }
                },
                _resolveCategoryColors(labels) {
                    const colorByName = {};
                    (this.poiCategories || []).forEach((item) => {
                        colorByName[item.name] = item.color || '#888';
                    });
                    return (labels || []).map(label => colorByName[label] || '#5b8ff9');
                },
                _buildHistogram(values, metricKey, binCount = 8) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v));
                    if (!valid.length) {
                        return { bins: [], counts: [] };
                    }
                    const minV = Math.min(...valid);
                    const maxV = Math.max(...valid);
                    if (Math.abs(maxV - minV) < 1e-12) {
                        const label = `${this._formatLegendValue(minV, metricKey)} ~ ${this._formatLegendValue(maxV, metricKey)}`;
                        return { bins: [label], counts: [valid.length] };
                    }

                    const bins = [];
                    const counts = new Array(binCount).fill(0);
                    const span = maxV - minV;
                    const step = span / binCount;
                    for (let i = 0; i < binCount; i += 1) {
                        const start = minV + step * i;
                        const end = i === binCount - 1 ? maxV : (minV + step * (i + 1));
                        bins.push(`${this._formatLegendValue(start, metricKey)} ~ ${this._formatLegendValue(end, metricKey)}`);
                    }
                    for (const v of valid) {
                        let idx = Math.floor((v - minV) / step);
                        if (!Number.isFinite(idx)) idx = 0;
                        if (idx < 0) idx = 0;
                        if (idx >= binCount) idx = binCount - 1;
                        counts[idx] += 1;
                    }
                    return { bins, counts };
                },
                _resolveMetricHistogram(metricKey) {
                    const source = this.h3AnalysisGridFeatures || [];
                    const values = source.map((feature) => {
                        const props = (feature && feature.properties) || {};
                        const datum = this._getH3MetricValue(props, metricKey);
                        return datum.noData ? null : datum.value;
                    }).filter(v => Number.isFinite(v));

                    if (metricKey === 'entropy') {
                        const hist = this._buildHistogram(values, 'entropy', 10);
                        return {
                            title: '局部熵分布（0~1）',
                            xAxisName: '熵区间',
                            bins: hist.bins,
                            counts: hist.counts,
                            color: '#4cae63',
                            subtext: '仅统计样本数足够的网格',
                        };
                    }
                    if (metricKey === 'neighbor_delta') {
                        const hist = this._buildHistogram(values, 'neighbor_delta', 8);
                        return {
                            title: '邻域差值分布（POI/km²）',
                            xAxisName: '差值区间（本格-邻域）',
                            bins: hist.bins,
                            counts: hist.counts,
                            color: '#3f7fd8',
                            subtext: '正值表示高于邻域，负值表示低于邻域',
                        };
                    }

                    const densityData = this.h3AnalysisCharts && this.h3AnalysisCharts.density_histogram
                        ? this.h3AnalysisCharts.density_histogram
                        : null;
                    if (densityData && Array.isArray(densityData.bins) && Array.isArray(densityData.counts)) {
                        return {
                            title: '密度分布（POI/km²）',
                            xAxisName: '密度区间 (POI/km²)',
                            bins: densityData.bins,
                            counts: densityData.counts.map(v => this._toNumber(v, 0)),
                            color: '#4c8bf5',
                            subtext: '',
                        };
                    }

                    const hist = this._buildHistogram(values, 'density', 8);
                    return {
                        title: '密度分布（POI/km²）',
                        xAxisName: '密度区间 (POI/km²)',
                        bins: hist.bins,
                        counts: hist.counts,
                        color: '#4c8bf5',
                        subtext: '',
                    };
                },
                updateH3Charts() {
                    if (!window.echarts || !this.h3AnalysisCharts) return;
                    const categoryEl = document.getElementById('h3CategoryChart');
                    const densityEl = document.getElementById('h3DensityChart');
                    if (!categoryEl || !densityEl) return;
                    if (categoryEl.clientWidth === 0 || densityEl.clientWidth === 0) return;

                    if (!this.h3ChartsResizeHandler) {
                        this.h3ChartsResizeHandler = () => {
                            if (this.h3CategoryChart) this.h3CategoryChart.resize();
                            if (this.h3DensityChart) this.h3DensityChart.resize();
                            if (this.h3LqChart) this.h3LqChart.resize();
                            if (this.h3GapChart) this.h3GapChart.resize();
                            if (this.h3StructureChart) this.h3StructureChart.resize();
                        };
                        window.addEventListener('resize', this.h3ChartsResizeHandler);
                    }

                    let categoryChart = echarts.getInstanceByDom(categoryEl);
                    if (!categoryChart) categoryChart = echarts.init(categoryEl);
                    this.h3CategoryChart = categoryChart;

                    let densityChart = echarts.getInstanceByDom(densityEl);
                    if (!densityChart) densityChart = echarts.init(densityEl);
                    this.h3DensityChart = densityChart;

                    const categoryData = this.h3AnalysisCharts.category_distribution || {};
                    const categoryLabels = categoryData.labels || [];
                    const categoryValues = (categoryData.values || []).map(v => this._toNumber(v, 0));
                    const categoryColors = this._resolveCategoryColors(categoryLabels);
                    categoryChart.setOption(
                        {
                            animationDuration: 240,
                            grid: { left: 48, right: 12, top: 22, bottom: 20, containLabel: true },
                            xAxis: {
                                type: 'value',
                                axisLine: { show: false },
                                axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eceff3' } },
                                minInterval: 1,
                            },
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: categoryLabels,
                                axisLine: { show: false },
                                axisTick: { show: false },
                            },
                            series: [{
                                type: 'bar',
                                data: categoryValues,
                                barWidth: 12,
                                itemStyle: { color: (params) => categoryColors[params.dataIndex] || '#5b8ff9' },
                                label: {
                                    show: true,
                                    position: 'right',
                                    formatter: '{c}',
                                    color: '#555',
                                    fontSize: 11
                                }
                            }]
                        },
                        true
                    );

                    const metricHist = this._resolveMetricHistogram(this.h3MetricView || 'density');
                    const bins = metricHist.bins || [];
                    const counts = (metricHist.counts || []).map(v => this._toNumber(v, 0));
                    const densitySubtext = metricHist.subtext || '';
                    densityChart.setOption(
                        {
                            title: {
                                text: metricHist.title || '指标分布',
                                subtext: densitySubtext,
                                left: 'center',
                                top: 0,
                                textStyle: { fontSize: 12, fontWeight: 600, color: '#374151' },
                                subtextStyle: { fontSize: 10, color: '#6b7280' }
                            },
                            animationDuration: 240,
                            grid: { left: 44, right: 16, top: densitySubtext ? 52 : 36, bottom: 40, containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: bins,
                                name: metricHist.xAxisName || '区间',
                                nameLocation: 'middle',
                                nameGap: 28,
                                nameTextStyle: { color: '#6b7280', fontSize: 10 },
                                axisLabel: {
                                    color: '#6b7280',
                                    fontSize: 10,
                                    interval: 0,
                                    rotate: bins.length > 6 ? 35 : 0,
                                },
                                axisLine: { lineStyle: { color: '#d7dce3' } }
                            },
                            yAxis: {
                                type: 'value',
                                minInterval: 1,
                                name: '网格数',
                                nameLocation: 'middle',
                                nameGap: 34,
                                nameTextStyle: { color: '#6b7280', fontSize: 10 },
                                axisLine: { show: false },
                                axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            series: [{
                                type: 'bar',
                                data: counts,
                                barMaxWidth: 20,
                                itemStyle: { color: metricHist.color || '#4c8bf5' }
                            }]
                        },
                        true
                    );
                },
                computePoiStats(points) {
                    const labels = this.poiCategories.map(c => c.name);
                    const colors = this.poiCategories.map(c => c.color || '#888');
                    const values = this.poiCategories.map(() => 0);
                    const indexMap = {};
                    this.poiCategories.forEach((c, idx) => {
                        indexMap[c.id] = idx;
                    });
                    (points || []).forEach(p => {
                        const cid = this.resolvePoiCategoryId(p && p.type);
                        if (!cid) return;
                        const idx = indexMap[cid];
                        if (Number.isInteger(idx) && idx >= 0) values[idx] += 1;
                    });
                    return { labels, colors, values };
                },
                updatePoiCharts() {
                    if (!this.markerManager || !this.markerManager.getVisiblePoints) return;

                    const el = document.getElementById('poiChart');
                    if (!el || !window.echarts) return;

                    // If chart already exists and is visible, update immediately for smooth animation (restores transition)
                    const existingChart = echarts.getInstanceByDom(el);
                    if (existingChart && el.clientWidth > 0) {
                        this.poiChart = existingChart;
                        const points = this.markerManager.getVisiblePoints();
                        const stats = this.computePoiStats(points);
                        const safeValues = stats.values.map(v => (Number.isFinite(v) ? v : 0));

                        const option = {
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: stats.labels
                            },
                            series: [{
                                data: safeValues,
                                itemStyle: {
                                    color: (params) => stats.colors[params.dataIndex] || '#888'
                                }
                            }]
                        };
                        existingChart.setOption(option, false); // Merge for animation
                        return;
                    }

                    // Otherwise, delay slightly for initial rendering (Step 3 panels use v-show)
                    setTimeout(() => {
                        const chart = this.initPoiChart();
                        if (!chart) return;

                        const points = this.markerManager.getVisiblePoints();
                        const stats = this.computePoiStats(points);
                        const safeValues = stats.values.map(v => (Number.isFinite(v) ? v : 0));

                        const option = {
                            grid: { left: 50, right: 20, top: 10, bottom: 10, containLabel: true },
                            xAxis: {
                                type: 'value',
                                axisLine: { show: false }, axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eee' } }
                            },
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: stats.labels,
                                axisLine: { show: false }, axisTick: { show: false }
                            },
                            series: [{
                                type: 'bar',
                                data: safeValues,
                                barWidth: 12,
                                itemStyle: {
                                    color: (params) => stats.colors[params.dataIndex] || '#888'
                                }
                            }]
                        };
                        try {
                            chart.setOption(option, true);
                            chart.resize();
                        } catch (err) {
                            console.error("ECharts setOption error:", err);
                        }
                    }, 100);
                },
                updateLegacySystem(pois) {
                    this.clearPoiOverlayLayers({
                        reason: 'update_legacy_system_rebuild',
                        clearManager: true,
                        clearSimpleMarkers: true,
                        resetFilterPanel: true
                    });

                    const defaultTypeId = (() => {
                        for (const group of (this.typeMapGroups || [])) {
                            const firstItem = (group.items || [])[0];
                            if (firstItem && firstItem.id) return firstItem.id;
                        }
                        return (this.poiCategories[0] && this.poiCategories[0].id) ? this.poiCategories[0].id : 'default';
                    })();
                    let invalidPointCount = 0;
                    const invalidPointSamples = [];
                    const points = (Array.isArray(pois) ? pois : []).map((p, idx) => {
                        const loc = this.normalizeLngLat(p && p.location, 'legacy.poi.location');
                        if (!loc) {
                            invalidPointCount += 1;
                            if (invalidPointSamples.length < 5) {
                                invalidPointSamples.push({
                                    idx: idx,
                                    id: (p && p.id) || '',
                                    name: (p && p.name) || '',
                                    location: this.roadSyntaxSummarizeCoordInput(p && p.location)
                                });
                            }
                            return null;
                        }
                        const lng = Number(loc[0]);
                        const lat = Number(loc[1]);
                        const matchedType = this.resolvePoiTypeId(p && p.type) || defaultTypeId;
                        return {
                            lng: lng,
                            lat: lat,
                            name: p && p.name ? p.name : '',
                            type: matchedType,
                            address: p && p.address ? p.address : '',
                            lines: p && Array.isArray(p.lines) ? p.lines : [],
                            _pid: (p && p.id) || ('p-' + idx)
                        };
                    }).filter((p) => !!p);
                    if (invalidPointCount > 0) {
                        console.warn('[legacy-poi] skipped invalid coordinates', {
                            invalid_count: invalidPointCount,
                            total_candidates: Array.isArray(pois) ? pois.length : 0,
                            samples: invalidPointSamples
                        });
                    }

                    const mapTypeConfig = {
                        groups: (this.typeMapGroups || []).map((group, index) => ({
                            id: String(group.id || `group-${index + 1}`),
                            title: String(group.title || group.id || `分类${index + 1}`),
                            toggleId: String(group.toggleId || `toggle-group-${index + 1}`),
                            filtersId: String(group.filtersId || `filters-group-${index + 1}`),
                            items: (group.items || []).map((item) => ({
                                id: String(item.id || ''),
                                label: String(item.label || item.id || ''),
                                color: item.color || '#888',
                                defaultChecked: this.poiSubSelectionState[item.id] !== false
                            })).filter(item => item.id)
                        })).filter(group => group.id && group.items.length > 0)
                    };
                    if (!mapTypeConfig.groups.length) {
                        mapTypeConfig.groups = [{
                            id: 'poi_group',
                            title: 'POI 分类',
                            toggleId: 'toggle_poi_group',
                            filtersId: 'filters-poi-group',
                            items: this.poiCategories.map((cat) => ({
                                id: String(cat.id || ''),
                                label: String(cat.name || cat.id || ''),
                                color: cat.color || '#888',
                                defaultChecked: cat.checked !== false
                            })).filter(item => item.id)
                        }];
                    }

                    const centerObj = this.selectedPoint ? {
                        lng: this.selectedPoint.lng,
                        lat: this.selectedPoint.lat,
                        name: '中心点',
                        type: 'center'
                    } : null;

                    const markRaw = (window.Vue && typeof window.Vue.markRaw === 'function')
                        ? window.Vue.markRaw
                        : (value) => value;
                    const managerGeneration = Number(this.poiMapWriteGeneration || 0);
                    const managerId = Number(this.poiManagerSerial || 0) + 1;
                    this.poiManagerSerial = managerId;
                    let managerRef = null;
                    const isWriteAllowed = () => {
                        return !!managerRef
                            && this.markerManager === managerRef
                            && Number(this.poiMapWriteGeneration || 0) === managerGeneration;
                    };
                    managerRef = markRaw(new MarkerManager(this.mapCore, {
                        mapData: { points: points, center: centerObj },
                        mapTypeConfig: mapTypeConfig,
                        enqueueMapWrite: this.enqueuePoiMapWrite.bind(this),
                        isWriteAllowed: isWriteAllowed
                    }));
                    this.markerManager = managerRef;
                    this.poiActiveManagerId = managerId;
                    this.markerManager.init();
                    this.markerManager.renderMarkers();

                    // Filter Panel
                    this.filterPanel = markRaw(new FilterPanel(this.markerManager, {
                        mapData: { points: points },
                        mapTypeConfig: mapTypeConfig,
                        flatMode: false,
                        autoFitView: !!this.poiAutoFitViewEnabled
                    }));
                    this.filterPanel.onFiltersChange = () => this.updatePoiCharts();
                    this.filterPanel.init();
                    this.applySimplifyPointVisibility();
                    this.updatePoiCharts();
                }
            }
        }).mount('#app');
    
    </script>
</body>

</html>
