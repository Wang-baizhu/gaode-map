<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>高德地图空间分析</title>
    <link rel="stylesheet" href="/static/css/map-common.css?v={{ static_version }}">
    <link rel="stylesheet" href="/static/css/filter-panel.css?v={{ static_version }}">
    <link rel="stylesheet" href="/static/css/analysis-page.css?v={{ static_version }}">
</head>

<body>
    <!-- 立即显示的全局加载状态 -->
    <div id="loading-overlay" class="page-loading-global">
        <div class="spinner"></div>
    </div>

    <!-- Vue App 挂载点 -->
    <div id="app" style="display: flex; width: 100%; height: 100%;" v-cloak>

        <!-- Left Sidebar: Wizard Dashboard -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div v-if="sidebarView === 'wizard'" class="step-header-nav" style="margin:0; width:100%;">
                    <button v-if="step === 1" class="btn-text-back" @click="backToHome">← 返回主页</button>
                </div>

                <div v-if="sidebarView === 'history'" class="step-header-nav history-header-nav">
                    <div class="history-header-slot left">
                        <button class="btn-text-back"
                            @click="isSelectionMode ? toggleSelectionMode(false) : backToHome()" style="margin:0;">
                            {% raw %}{{ isSelectionMode ? '取消' : '← 返回主页' }}{% endraw %}
                        </button>
                    </div>
                    <h3 class="history-header-title">历史记录</h3>
                    <div class="history-header-slot right" style="display:flex; align-items:center; justify-content:flex-end; gap:8px;">
                        <button v-if="!isSelectionMode" class="btn-text-back history-icon-btn"
                            :class="{ 'is-loading': historyLoading }"
                            @click="refreshHistoryList" :disabled="historyLoading" style="margin:0;"
                            title="刷新历史记录" aria-label="刷新历史记录">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M20 5v5h-5"></path>
                                <path d="M4 19v-5h5"></path>
                                <path d="M6.2 8.2A8 8 0 0 1 18 10"></path>
                                <path d="M17.8 15.8A8 8 0 0 1 6 14"></path>
                            </svg>
                        </button>
                        <button class="btn-text-back" @click="toggleSelectionMode(!isSelectionMode)" style="margin:0;">
                            {% raw %}{{ isSelectionMode ? '完成' : '管理' }}{% endraw %}
                        </button>
                    </div>
                </div>
            </div>

            <div class="sidebar-content">

                <!-- Start Screen -->
                <div v-show="sidebarView === 'start'" class="home-menu">
                    <div class="home-card" @click="confirmNavigation(() => resetAnalysis())">
                        <div class="home-icon">
                            <img src="/static/images/search.svg" alt="探索">
                        </div>
                        <div class="home-text">
                            <h3>实时探索</h3>
                            <p>Real-time Explore</p>
                            <p style="margin-top:4px; color:#999;">基于高德实时数据分析</p>
                        </div>
                    </div>

                    <div class="home-card"
                        @click="confirmNavigation(() => openHistoryView())">
                        <div class="home-icon">
                            <img src="/static/images/history.svg" alt="档案">
                        </div>
                        <div class="home-text">
                            <h3>本地档案</h3>
                            <p>Local Archives</p>
                            <p style="margin-top:4px; color:#999;">查看往期分析记录</p>
                        </div>
                    </div>
                </div>

                <!-- History View -->
                <div v-show="sidebarView === 'history'" class="history-list" style="padding-bottom: 80px;">
                    <div v-if="historyLoading && historyList.length === 0">
                        <div v-for="n in historySkeletonCount" :key="'history-skeleton-' + n" class="history-card history-skeleton-card">
                            <div style="flex:1;">
                                <div class="skeleton-line skeleton-line-title"></div>
                                <div class="skeleton-line skeleton-line-meta"></div>
                            </div>
                        </div>
                    </div>

                    <div v-for="item in historyList" :key="item.id" class="history-card"
                        @click="handleHistoryItemClick(item)"
                        :class="{'selection-mode': isSelectionMode, 'selected': selectedHistoryIds.includes(item.id)}">

                        <!-- Checkbox for Selection Mode -->
                        <div v-if="isSelectionMode" class="checkbox-wrapper">
                            <div class="custom-checkbox" :class="{checked: selectedHistoryIds.includes(item.id)}">
                                <svg v-if="selectedHistoryIds.includes(item.id)" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>

                        <div style="flex:1;">
                            <div class="card-header">
                                <span class="card-title">{% raw %}{{ formatHistoryTitle(item.description) }}{% endraw
                                    %}</span>
                            </div>
                            <div class="card-meta">
                                <div class="meta-row">
                                    <span class="meta-tag mode-tag">
                                        <span v-if="item.params && item.params.mode === 'driving'">
                                            <img src="/static/images/driving.svg"> 驾车
                                        </span>
                                        <span v-else-if="item.params && item.params.mode === 'bicycling'">
                                            <img src="/static/images/cycling.svg"> 骑行
                                        </span>
                                        <span v-else>
                                            <img src="/static/images/walking.svg"> 步行
                                        </span>
                                    </span>
                                    <span v-if="item.params && item.params.time_min" class="meta-tag time-tag">
                                        <img src="/static/images/time.svg"> {% raw %}{{ item.params.time_min }}{% endraw
                                        %}分
                                    </span>
                                </div>
                                <span class="meta-date">
                                    {% raw %}{{ item._createdDateText || item.created_at }}{% endraw %}
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Batch Delete Footer -->
                    <div v-if="isSelectionMode"
                        style="position:fixed; bottom:0; left:0; width:var(--sidebar-width); background:#fff; padding:15px; border-top:1px solid #eee; box-shadow:0 -2px 10px rgba(0,0,0,0.05); z-index:100; box-sizing:border-box; display:flex; gap:10px;">
                        <button class="btn-black" :disabled="selectedHistoryIds.length === 0"
                            @click="deleteSelectedHistory" style="background: #ff4d4f; border:none; width:100%;">
                            删除选中 ({% raw %}{{ selectedHistoryIds.length }}{% endraw %})
                        </button>
                    </div>

                    <div v-if="!historyLoading && historyList.length === 0"
                        style="text-align:center; padding:40px 20px; color:#999; display:flex; flex-direction:column; align-items:center;">
                        <img src="/static/images/empty.svg"
                            style="width:48px; height:48px; opacity:0.3; margin-bottom:10px;">
                        <span>暂无历史记录</span>
                    </div>
                </div>

                <!-- Wizard View Wrapper -->
                <div v-show="sidebarView === 'wizard'" style="display:contents;">

                    <!-- Step 1: Location & Analysis -->
                    <div v-show="step === 1" class="wizard-step">
                        <div class="step-title">
                            <h3>1. 地点与范围</h3>
                        </div>

                        <div class="form-group search-group">
                            <input type="text" id="keyword" class="minimal-input" placeholder="搜索地点..."
                                @keyup.enter="triggerSearch">
                            <button class="btn-icon" @click="triggerSearch">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                </svg>
                            </button>
                        </div>

                        <div class="form-group">
                            <div v-if="selectedPoint" class="status-badge success">
                                已选: {% raw %}{{ selectedPoint.lng.toFixed(4) }}, {{ selectedPoint.lat.toFixed(4) }}{%
                                endraw
                                %}
                            </div>
                            <div v-else class="status-badge warning">请在地图上点击或搜索选择起点</div>
                        </div>

                        <div class="form-group">
                            <label>出行方式</label>
                            <div class="mode-select">
                                <div class="mode-select">
                                    <div class="mode-option" :class="{active: transportMode==='walking'}"
                                        @click="transportMode='walking'">步行 <img src="/static/images/walking.svg"></div>
                                    <div class="mode-option" :class="{active: transportMode==='bicycling'}"
                                        @click="transportMode='bicycling'">骑行 <img src="/static/images/cycling.svg">
                                    </div>
                                    <div class="mode-option" :class="{active: transportMode==='driving'}"
                                        @click="transportMode='driving'">驾车 <img src="/static/images/driving.svg"></div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>时间范围: {% raw %}{{ timeHorizon }}{% endraw %} 分钟</label>
                            <input type="range" v-model.number="timeHorizon" class="minimal-range" min="5" max="60"
                                step="5">
                        </div>
                        <div class="form-group" style="display:flex; align-items:center; gap:8px;">
                            <label style="margin:0;">底图源</label>
                            <select v-model="basemapSource" @change="onBasemapSourceChange"
                                class="minimal-input" style="padding:4px 8px; max-width:180px;">
                                <option value="tianditu">天地图（国内科研）</option>
                                <option value="osm">OpenStreetMap（科研）</option>
                                <option value="amap">高德（业务）</option>
                            </select>
                        </div>


                        <button class="btn-black" :disabled="!selectedPoint || isCalculating" @click="startAnalysis">
                            {% raw %}{{ isCalculating ? '计算中...' : '下一步: 生成等时圈' }}{% endraw %}
                        </button>
                        <div v-if="errorMessage" class="error-msg">{% raw %}{{ errorMessage }}{% endraw %}</div>
                        <div v-if="basemapSource === 'tianditu' && tdtDiag && tdtDiag.ok === false"
                            style="margin-top:10px; padding:10px; border:1px solid #f1b0b7; border-radius:8px; background:#fff7f7;">
                            <div style="font-size:12px; font-weight:600; color:#9f1239; margin-bottom:6px;">天地图诊断信息</div>
                            <div style="font-size:11px; color:#6b7280; line-height:1.5; margin-bottom:6px;">
                                {% raw %}阶段={{ tdtDiag.phase || '-' }}；状态={{ tdtDiag.status === null || tdtDiag.status === undefined ? '-' : tdtDiag.status }}；内容类型={{ tdtDiag.contentType || '-' }}{% endraw %}
                            </div>
                            <pre
                                style="margin:0; max-height:120px; overflow:auto; white-space:pre-wrap; word-break:break-all; font-size:11px; line-height:1.45; color:#4b5563; background:#fff; border:1px solid #e5e7eb; border-radius:6px; padding:8px;">{% raw %}{{ buildTdtDiagText() }}{% endraw %}</pre>
                            <div style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <button type="button" class="btn-outline" style="margin-top:0; padding:6px 12px; width:auto;"
                                    @click="copyTdtDiag">
                                    复制诊断
                                </button>
                                <span style="font-size:11px; color:#6b7280;">{% raw %}{{ tdtDiagCopyStatus }}{% endraw %}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: POI Categories -->
                    <div v-show="step === 2" class="wizard-step">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(1)">← 返回</button>
                            <h3>2. 选择业态</h3>
                        </div>
                        <p class="step-desc">选择需要在等时圈内抓取的设施类型</p>

                        <div class="category-grid">
                            <div v-for="cat in poiCategories" :key="cat.id" class="cat-card" :class="{checked: cat.checked}">
                                <div class="cat-color" :style="{background: cat.color}"></div>
                                <div class="cat-texts">
                                    <div class="cat-header-row">
                                        <label class="cat-check" @click.stop>
                                            <input type="checkbox" :checked="cat.checked"
                                                @change="togglePoiCategory(cat, $event.target.checked)">
                                            <span class="cat-name">{% raw %}{{ cat.name }}{% endraw %}</span>
                                        </label>
                                        <button v-if="getPoiSubItems(cat.id).length" type="button" class="cat-expand-btn"
                                            @click.stop="togglePoiCategoryExpand(cat.id)">
                                            {% raw %}{{ expandedPoiCategoryId === cat.id ? '收起' : '展开' }}{% endraw %}
                                        </button>
                                    </div>
                                    <div class="cat-subtypes" v-if="getPoiSubItems(cat.id).length">
                                        已选 {% raw %}{{ getPoiSubSelectedCount(cat.id) }}{% endraw %}/{% raw %}{{ getPoiSubItems(cat.id).length }}{% endraw %} 个小类
                                    </div>
                                    <div class="cat-subitem-list" v-show="expandedPoiCategoryId === cat.id"
                                        v-if="getPoiSubItems(cat.id).length">
                                        <label v-for="item in getPoiSubItems(cat.id)" :key="`step2-sub-${cat.id}-${item.id}`"
                                            class="cat-subitem" @click.stop>
                                            <input type="checkbox" :checked="isPoiSubItemChecked(item.id)"
                                                @change="onPoiSubItemToggle(cat, item, $event.target.checked)">
                                            <span>{% raw %}{{ item.label }}{% endraw %}</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <button class="btn-black" :disabled="isFetchingPois" @click="fetchPois">
                            {% raw %}{{ isFetchingPois ? '数据抓取中 ' + fetchProgress + '%' : '下一步: 抓取数据' }}{% endraw %}
                        </button>

                        <div v-if="isFetchingPois"
                            style="margin-top:10px; background:#f0f0f0; height:6px; border-radius:3px; overflow:hidden;">
                            <div
                                :style="{width: fetchProgress + '%', background:'#000', height:'100%', transition:'width 0.3s ease'}">
                            </div>
                        </div>
                        <div v-if="isFetchingPois && fetchSubtypeProgress.categoryName" class="fetch-subtype-progress">
                            <div class="line">
                                <span class="label">当前大类：</span>
                                <span>{% raw %}{{ fetchSubtypeProgress.categoryName }}{% endraw %}</span>
                            </div>
                            <div class="line">
                                <span class="label">已命中小类：</span>
                                <template v-if="fetchSubtypeProgress.typeNamesPreview.length">
                                    <span>{% raw %}{{ fetchSubtypeProgress.typeNamesPreview.join('、') }}{% endraw %}</span>
                                    <span v-if="fetchSubtypeProgress.hiddenTypeCount > 0">
                                        {% raw %} 等{{ fetchSubtypeProgress.typeNamesFullCount }}个小类{% endraw %}
                                    </span>
                                </template>
                                <template v-else>
                                    <span>暂无</span>
                                </template>
                            </div>
                        </div>

                        <div v-if="poiStatus" class="status-text">{% raw %}{{ poiStatus }}{% endraw %}</div>
                    </div>

                    <!-- Step 3: Results & Filter -->
                    <div v-show="step === 3" class="wizard-step">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(2)">← 返回</button>
                            <h3>3. 结果分析</h3>
                        </div>

                        <div class="step3-layout">
                            <div class="nav-rail">
                                <div v-for="(item, index) in step3NavItems" :key="item.id" class="nav-item" :class="{
                                        active: activeStep3Panel === item.id,
                                        dragging: dragIndex === index,
                                        'insert-before': isDraggingNav && dragOverIndex === index && dragInsertPosition === 'before',
                                        'insert-after': isDraggingNav && dragOverIndex === index && dragInsertPosition === 'after'
                                    }" :title="item.title" draggable="true" @click="selectStep3Panel(item.id)"
                                    @dragstart="onStep3DragStart(index, $event)"
                                    @dragover="onStep3DragOver(index, $event)" @drop="onStep3Drop(index)"
                                    @dragend="onStep3DragEnd">
                                    {% raw %}{{ item.label }}{% endraw %}
                                </div>
                            </div>

                            <div class="panel-area">
                                <div class="panel poi-panel" v-show="activeStep3Panel === 'poi'">
                                    <div class="poi-panel-header">
                                        <h4>POI 分类</h4>
                                        <div class="poi-panel-actions">
                                            <span id="poiTotalCount" class="count-badge">总数 0</span>
                                            <button id="toggleAllPoi" type="button"
                                                class="btn-outline btn-compact">全部隐藏</button>
                                            <button id="toggleExpandAll" class="btn-outline btn-compact">全部展开</button>
                                        </div>
                                    </div>
                                    <div id="filtersContainer" class="legacy-filters-wrapper"></div>
                                    <div id="poiChart" class="poi-chart"></div>
                                </div>

                                <div class="panel" v-show="activeStep3Panel === 'h3'">
                                    <div class="h3-subtabs h3-stage-tabs">
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'params' }"
                                            @click="onH3MainStageChange('params')">参数</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'analysis' }"
                                            @click="onH3MainStageChange('analysis')">分析</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'diagnosis' }"
                                            @click="onH3MainStageChange('diagnosis')">诊断</button>
                                        <button type="button" class="h3-subtab-pill h3-stage-pill"
                                            :class="{ active: h3MainStage === 'evaluate' }"
                                            @click="onH3MainStageChange('evaluate')">评估</button>
                                    </div>
                                    <div v-if="h3MainStage === 'params'" class="h3-params-card">
                                        <div class="h3-params-grid">
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">网格级别</span>
                                                <select v-model.number="h3GridResolution" @change="onH3ResolutionChange" class="h3-params-select">
                                                    <option :value="8">8</option>
                                                    <option :value="9">9</option>
                                                    <option :value="10">10</option>
                                                    <option :value="11">11</option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field">
                                                <span class="h3-params-label">邻域圈层</span>
                                                <select v-model.number="h3NeighborRing" class="h3-params-select">
                                                    <option :value="1">ring=1</option>
                                                    <option :value="2">ring=2</option>
                                                    <option :value="3">ring=3</option>
                                                </select>
                                            </label>
                                            <label class="h3-params-field h3-params-field-wide">
                                                <span class="h3-params-label">包含模式</span>
                                                <select v-model="h3GridIncludeMode" @change="onH3GridSettingsChange" class="h3-params-select">
                                                    <option value="intersects">相交优先（边缘保留）</option>
                                                    <option value="inside">完全包含（严格）</option>
                                                </select>
                                            </label>
                                            <div class="h3-params-field h3-params-field-wide">
                                                <span class="h3-params-label">最小重叠比例</span>
                                                <div class="h3-params-range-row">
                                                    <input type="range" min="0" max="0.9" step="0.05"
                                                        v-model.number="h3GridMinOverlapRatio" @change="onH3GridSettingsChange"
                                                        class="minimal-range h3-params-range">
                                                    <span class="range-value">{% raw %}{{ h3GridMinOverlapRatio.toFixed(2) }}{% endraw %}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="h3-params-chips">
                                            <label class="h3-check-chip h3-check-chip-compact">
                                                <input type="checkbox" v-model="h3UseArcgis">
                                                ArcGIS引擎
                                            </label>
                                            <span class="count-badge">网格数 {% raw %}{{ h3GridCount }}{% endraw %}</span>
                                        </div>
                                        <div class="h3-params-actions">
                                            <button class="h3-btn h3-btn-ghost"
                                                :disabled="h3GridCount === 0" @click="clearH3Grid">
                                                清空网络
                                            </button>
                                            <button class="h3-btn h3-btn-primary h3-params-compute-btn"
                                                :disabled="isComputingH3Analysis || !lastIsochroneGeoJSON"
                                                @click="computeH3Analysis">
                                                {% raw %}{{ isComputingH3Analysis ? '分析中...' : '计算分析' }}{% endraw %}
                                            </button>
                                        </div>
                                    </div>
                                    <div class="h3-subtabs"
                                        v-if="h3MainStage !== 'params' && h3AnalysisGridFeatures.length > 0 && getH3CurrentStageTabs().length > 1"
                                        style="margin-top:6px; grid-template-columns: repeat(2, minmax(0, 1fr));">
                                        <button type="button" class="h3-subtab-pill"
                                            v-for="tab in getH3CurrentStageTabs()"
                                            :key="`h3-subtab-${tab}`"
                                            :class="{ active: h3SubTab === tab }"
                                            @click="onH3SubTabChange(tab)">
                                            {% raw %}{{ h3SubTabLabels[tab] || tab }}{% endraw %}
                                        </button>
                                    </div>
                                    <div class="filter-section"
                                        v-if="h3AnalysisGridFeatures.length > 0 && h3MainStage === 'analysis' && h3SubTab === 'metric_map'"
                                        style="margin-top:8px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            地图指标
                                            <select v-model="h3MetricView" @change="onH3MetricViewChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option value="density">密度</option>
                                                <option value="entropy">局部熵</option>
                                                <option value="neighbor_delta">邻域差值（本格-邻域）</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="filter-section"
                                        v-if="h3AnalysisGridFeatures.length > 0 && h3MainStage === 'analysis' && h3SubTab === 'structure_map'"
                                        style="margin-top:8px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            结构图层
                                            <select v-model="h3StructureFillMode" @change="onH3StructureFillModeChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option value="gi_z">Gi*（Z-score 连续）</option>
                                                <option value="lisa_i">LISA（LMiIndex 连续）</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="filter-section h3-control-row h3-control-row-tight"
                                        v-if="h3AnalysisGridFeatures.length > 0 && (h3MainStage === 'diagnosis' || h3MainStage === 'evaluate')"
                                        style="margin-top:8px;">
                                        <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            TopN
                                            <input type="number" min="3" max="30" step="1"
                                                v-model.number="h3DecisionTopN" @change="onH3DecisionSettingsChange"
                                                style="width:68px; padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                        </label>
                                        <label v-if="h3SubTab === 'lq' || h3SubTab === 'gap'"
                                            style="display:flex; align-items:center; gap:6px; font-size:12px; color:#666;">
                                            目标业态
                                            <select v-model="h3TargetCategory" @change="onH3DecisionSettingsChange"
                                                style="padding:4px 6px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                                <option v-for="item in h3CategoryMeta" :key="`target-${item.key}`" :value="item.key">
                                                    {% raw %}{{ item.label }}{% endraw %}
                                                </option>
                                            </select>
                                        </label>
                                        <label class="h3-check-chip h3-check-chip-compact">
                                            <input type="checkbox" v-model="h3OnlySignificant" @change="onH3DecisionSettingsChange">
                                            仅结构网格
                                        </label>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary"
                                        style="margin-top:10px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                        <div class="count-badge">POI总数 {% raw %}{{ h3AnalysisSummary.poi_count }}{% endraw %}</div>
                                        <div class="count-badge">平均密度 {% raw %}{{ h3AnalysisSummary.avg_density_poi_per_km2.toFixed(2) }}{% endraw %}</div>
                                        <div class="count-badge">平均熵 {% raw %}{{ h3AnalysisSummary.avg_local_entropy.toFixed(3) }}{% endraw %}</div>
                                        <div class="count-badge">网格数 {% raw %}{{ h3AnalysisSummary.grid_count ?? h3GridCount }}{% endraw %}</div>
                                        <div class="count-badge">Gi*有效格 {% raw %}{{ (h3AnalysisSummary.gi_z_stats && h3AnalysisSummary.gi_z_stats.count) ?? 0 }}{% endraw %}</div>
                                        <div class="count-badge">LISA有效格 {% raw %}{{ (h3AnalysisSummary.lisa_i_stats && h3AnalysisSummary.lisa_i_stats.count) ?? 0 }}{% endraw %}</div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary" class="h3-analysis-hint">
                                        看密度、混合度和邻域差值，优先找“高密且邻域为正”的连续片区。
                                    </div>
                                    <div v-if="h3MainStage !== 'params' && h3Legend && h3Legend.items && h3Legend.items.length"
                                        style="margin-top:10px; border:1px solid #eef1f4; border-radius:8px; padding:8px 10px; background:#fafbfc;">
                                        <div style="font-size:12px; color:#374151; font-weight:600; margin-bottom:6px;">
                                            {% raw %}{{ h3Legend.title }}{% endraw %}
                                            <span style="color:#6b7280; font-weight:400;">
                                                {% raw %}{{ h3Legend.unit ? `（${h3Legend.unit}）` : '' }}{% endraw %}
                                            </span>
                                        </div>
                                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px 10px;">
                                            <div v-for="(item, idx) in h3Legend.items" :key="`legend-${idx}`"
                                                style="display:flex; align-items:center; gap:6px; font-size:11px; color:#4b5563;">
                                                <span :style="{display:'inline-block', width:'12px', height:'12px', borderRadius:'2px', background:item.color, border:'1px solid #d1d5db'}"></span>
                                                <span>{% raw %}{{ item.label }}{% endraw %}</span>
                                            </div>
                                        </div>
                                        <div v-if="h3Legend.noDataLabel"
                                            style="margin-top:6px; font-size:11px; color:#6b7280; display:flex; align-items:center; gap:6px;">
                                            <span :style="{display:'inline-block', width:'12px', height:'12px', borderRadius:'2px', background:h3Legend.noDataColor || '#d1d5db', border:'1px solid #d1d5db'}"></span>
                                            <span>{% raw %}{{ h3Legend.noDataLabel }}{% endraw %}</span>
                                        </div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'metric_map' && h3AnalysisSummary" style="margin-top:10px;">
                                        <div id="h3CategoryChart" style="height:180px;"></div>
                                        <div id="h3DensityChart" style="height:180px; margin-top:8px;"></div>
                                    </div>
                                    <div v-if="h3MainStage === 'analysis' && h3SubTab === 'structure_map' && h3DerivedStats.structureSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            结构图口径：仅使用 ArcGIS 连续字段。Gi* 使用 GiZScore；LISA 使用 LMiIndex；网格边框统一蓝色。
                                        </div>
                                        <div v-if="h3AnalysisSummary"
                                            style="margin-top:10px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                            <div class="count-badge">莫兰指数 {% raw %}{{ h3AnalysisSummary.global_moran_i_density ?? 'N/A' }}{% endraw %}</div>
                                            <div class="count-badge">莫兰z值 {% raw %}{{ h3AnalysisSummary.global_moran_z_score ?? 'N/A' }}{% endraw %}</div>
                                            <div class="count-badge">Gi*有效格 {% raw %}{{ (h3AnalysisSummary.gi_z_stats && h3AnalysisSummary.gi_z_stats.count) ?? 0 }}{% endraw %}</div>
                                            <div class="count-badge">LISA有效格 {% raw %}{{ (h3AnalysisSummary.lisa_i_stats && h3AnalysisSummary.lisa_i_stats.count) ?? 0 }}{% endraw %}</div>
                                            <div class="count-badge">引擎 {% raw %}{{ (h3AnalysisSummary.analysis_engine || 'pysal').toUpperCase() }}{% endraw %}</div>
                                        </div>
                                        <div v-if="h3DerivedStats.structureSummary.lisaRenderMeta && h3DerivedStats.structureSummary.lisaRenderMeta.degraded"
                                            class="h3-analysis-hint" style="margin-top:8px;">
                                            {% raw %}{{ h3DerivedStats.structureSummary.lisaRenderMeta.message || 'LMiIndex方差不足' }}{% endraw %}
                                        </div>
                                        <div v-if="h3AnalysisSummary && h3AnalysisSummary.arcgis_status"
                                            class="h3-analysis-hint" style="margin-top:8px;">
                                            {% raw %}{{ h3AnalysisSummary.arcgis_status }}{% endraw %}
                                        </div>
                                        <div v-if="h3AnalysisSummary && getArcgisSnapshotUrl()"
                                            style="margin-top:10px; border:1px solid #eef1f4; border-radius:10px; padding:8px; background:#fafbfc;">
                                            <div style="font-size:12px; color:#374151; font-weight:600; margin-bottom:6px;">
                                                {% raw %}{{ getArcgisSnapshotTitle() }}{% endraw %}
                                            </div>
                                            <img :src="`${getArcgisSnapshotUrl()}?v=${h3ArcgisImageVersion}`"
                                                alt="ArcGIS结构图"
                                                style="width:100%; border-radius:8px; border:1px solid #dbe2ea;" />
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">Gi* 均值</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.giZStats.mean === null ? '-' : h3DerivedStats.structureSummary.giZStats.mean.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">Gi* 中位数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.giZStats.p50 === null ? '-' : h3DerivedStats.structureSummary.giZStats.p50.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">LISA 正值占比</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.lisaPositivePct === null ? '-' : `${(h3DerivedStats.structureSummary.lisaPositivePct * 100).toFixed(1)}%` }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">LISA 负值占比</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.structureSummary.lisaNegativePct === null ? '-' : `${(h3DerivedStats.structureSummary.lisaNegativePct * 100).toFixed(1)}%` }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div id="h3StructureChart" style="height:180px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>Gi*z</th><th>LISA I</th><th>结构信号</th><th>密度</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.structureSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`structure-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.gi_star_z_score === null ? '-' : row.gi_star_z_score.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.lisa_i === null ? '-' : row.lisa_i.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Number.isFinite(row.structure_signal) ? row.structure_signal.toFixed(2) : '-' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density === null ? '-' : row.density.toFixed(2) }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'diagnosis' && h3SubTab === 'typing' && h3DerivedStats.typingSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            看四象限结构：高密高混合偏成熟，高密低混合偏单核，低密高混合偏潜力，低密低混合偏薄弱；同时参考可信度。
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">机会网格数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.typingSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高密度</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.typingSummary.maxDensity.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议动作</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.typingSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <table class="h3-mini-table">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>POI</th><th>密度</th><th>熵</th><th>可信度</th><th>分型</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.typingSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`typing-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.poi_count }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.entropy_norm === null ? '-' : row.entropy_norm.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.type_label }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'diagnosis' && h3SubTab === 'lq' && h3DerivedStats.lqSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            看目标业态相对本分析区是否更强：大于1偏强，小于1偏弱；已做小样本平滑。
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">优势网格数</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.lqSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高优势值</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.lqSummary.maxLq.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议业态</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.lqSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div id="h3LqChart" style="height:180px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>POI</th><th>密度</th><th>熵</th><th>可信度</th><th>结构参考</th><th>优势值</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.lqSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`lq-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ row.poi_count }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.density.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.entropy_norm === null ? '-' : row.entropy_norm.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Number.isFinite(row.structure_signal) ? row.structure_signal.toFixed(2) : '-' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.lq_target === null ? '-' : row.lq_target.toFixed(2) }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3MainStage === 'evaluate' && h3SubTab === 'gap' && h3DerivedStats.gapSummary" style="margin-top:10px;">
                                        <div class="h3-analysis-hint">
                                            先看“需求分位”和“供给分位”，再看两者差值；需求高且供给低的网格优先补位。
                                        </div>
                                        <div v-if="h3DerivedStats.gapSummary.mappingWarning" class="panel-placeholder"
                                            style="margin-top:8px; border-color:#fde68a; background:#fffbeb; color:#92400e;">
                                            {% raw %}{{ h3DerivedStats.gapSummary.mappingWarning }}{% endraw %}
                                        </div>
                                        <div class="h3-decision-cards">
                                            <div class="h3-decision-card">
                                                <div class="label">高缺口网格</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.gapSummary.opportunityCount }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">最高缺口分</div>
                                                <div class="value">{% raw %}{{ h3DerivedStats.gapSummary.maxGap.toFixed(2) }}{% endraw %}</div>
                                            </div>
                                            <div class="h3-decision-card">
                                                <div class="label">建议优先区</div>
                                                <div class="value small">{% raw %}{{ h3DerivedStats.gapSummary.recommendation }}{% endraw %}</div>
                                            </div>
                                        </div>
                                        <div class="panel-placeholder" style="margin-top:8px;">
                                            {% raw %}{{ h3DerivedStats.gapSummary.insight || '缺口分 = 需求百分位 - 目标业态供给百分位（越高越可能供给偏弱）' }}{% endraw %}
                                        </div>
                                        <div id="h3GapChart" style="height:180px; margin-top:8px;"></div>
                                        <table class="h3-mini-table" style="margin-top:8px;">
                                            <thead>
                                                <tr>
                                                    <th>H3</th><th>需求分位</th><th>供给分位</th><th>缺口分</th><th>可信度</th><th>结论</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in h3DerivedStats.gapSummary.rows.slice(0, h3DecisionTopN)"
                                                    :key="`gap-${row.h3_id}`"
                                                    :class="{ 'h3-row-active': row.h3_id === selectedH3Id }">
                                                    <td>
                                                        <button type="button" class="h3-id-btn" :title="row.h3_id"
                                                            @click="focusGridByH3Id(row.h3_id)">
                                                            {% raw %}{{ shortH3Id(row.h3_id) }}{% endraw %}
                                                        </button>
                                                    </td>
                                                    <td>{% raw %}{{ Math.round((row.demand_pct || 0) * 100) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ Math.round((row.supply_pct || 0) * 100) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.gap_score === null ? '-' : row.gap_score.toFixed(2) }}{% endraw %}</td>
                                                    <td>{% raw %}{{ (row.confidence && row.confidence.label) || '低' }}{% endraw %}</td>
                                                    <td>{% raw %}{{ row.gap_zone_label || '-' }}{% endraw %}</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div v-if="h3GridStatus" class="status-text"
                                        style="margin-top:10px; display:flex; align-items:center; gap:8px; justify-content:flex-start;">
                                        <span>{% raw %}{{ h3GridStatus }}{% endraw %}</span>
                                        <button v-if="selectedH3Id" type="button"
                                            style="border:1px solid #d9dee7; background:#fff; color:#4b5563; border-radius:999px; padding:2px 8px; font-size:11px; cursor:pointer;"
                                            @click="clearGridLock">
                                            取消锁定
                                        </button>
                                    </div>
                                </div>

                                <div class="panel" v-show="activeStep3Panel === 'aoi'">
                                    <h4>AOI 面数据分析</h4>
                                    <div class="panel-placeholder" style="margin-top:10px;">AOI 面数据分析（待开发）</div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div> <!-- End Wizard View Wrapper -->

            </div> <!-- End of sidebar-content -->

            <!-- Fixed History Footer -->
            <!-- Sidebar Footer (Only in Wizard Mode) -->
            <div v-if="sidebarView === 'wizard'" class="sidebar-footer"
                style="padding: 20px; border-top: 1px solid #f0f0f0; background: #fff; display: flex; flex-direction: column; gap: 10px;">
                <button v-if="step === 3" class="btn-black" @click="saveAndRestart">
                    保存并开启新分析
                </button>
                <button class="btn-outline"
                    style="margin-top:0; border:1px solid #eee; display:flex; justify-content:center; align-items:center;"
                    @click="openHistoryView()">
                    <img src="/static/images/history.svg" class="icon-svg-small" style="margin-right:8px;"> 查看历史记录 ({%
                    raw %}{{
                    historyList.length }}{% endraw %})
                </button>
            </div>
        </aside>

        <!-- Middle: Map -->
        <main class="main-content">
            <div id="tianditu-container" aria-hidden="true"></div>
            <div id="container"></div>
            <button v-if="sidebarView === 'wizard' && step === 3 && activeStep3Panel === 'h3'" type="button"
                class="h3-map-simplify-btn" :class="{ active: h3BasemapMuted }" @click="toggleH3BasemapMuted">
                {% raw %}{{ h3BasemapMuted ? '简化：开' : '简化：关' }}{% endraw %}
            </button>
            <div v-if="basemapSource === 'osm'" style="position:absolute; right:8px; bottom:6px; z-index:2; background:rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius:6px; padding:2px 6px; font-size:10px; color:#4b5563;">
                © OpenStreetMap contributors
            </div>
            <div v-else-if="basemapSource === 'tianditu'" style="position:absolute; right:8px; bottom:6px; z-index:2; background:rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius:6px; padding:2px 6px; font-size:10px; color:#4b5563;">
                © 天地图
            </div>
        </main>
    </div>

    <!-- 依赖库 -->
    <!-- 引入 Vue 3 (CDN) -->
    <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="/static/js/map-utils.js?v={{ static_version }}"></script>
    <script src="/static/js/map-core.js?v={{ static_version }}"></script>
    <script src="/static/js/map-markers.js?v={{ static_version }}"></script>
    <script src="/static/js/map-filters.js?v={{ static_version }}"></script>
    <!-- 引入 analysis.js 也可以，但我们大部分逻辑移入 Vue methods 更好，这里依然引入以兼容 MapCore 依赖 -->

    <script>
        const { createApp } = Vue;
        const INJECTED_TYPE_MAP_CONFIG = {{ map_type_config_json | safe }} || { groups: [] };

        createApp({
            data() {
                return {
                    loadingConfig: true,
                    config: null,

                    // State
                    step: 1, // Wizard Step
                    sidebarView: 'start', // 'start', 'wizard', 'history'
                    selectedPoint: null, // {lng, lat}
                    transportMode: 'walking',
                    timeHorizon: 15,
                    isCalculating: false,
                    errorMessage: '',
                    basemapSource: 'amap',
                    tdtDiag: null,
                    tdtDiagCopyStatus: '',

                    // POI Data
                    poiKeywords: '', // Not used if using categories, but kept for custom
                    typeMapConfig: INJECTED_TYPE_MAP_CONFIG,
                    typeMapGroups: [],
                    typeCodeToCategoryId: {},
                    typePrefixToCategoryId: {},
                    typeCodeToTypeId: {},
                    typePrefixToTypeId: {},
                    typeIdToGroupId: {},
                    typeIdToLabel: {},
                    categoryById: {},
                    poiCategories: [],
                    poiSubSelectionState: {},
                    expandedPoiCategoryId: null,
                    step3NavItems: [
                        { id: 'poi', label: 'POI', title: 'POI 点数据分析' },
                        { id: 'h3', label: '网格', title: '网格分析' },
                        { id: 'aoi', label: 'AOI', title: 'AOI 面数据分析' }
                    ],
                    activeStep3Panel: 'poi',
                    dragIndex: null,
                    dragOverIndex: null,
                    dragInsertPosition: null,
                    isDraggingNav: false,
                    isFetchingPois: false,
                    fetchProgress: 0,
                    poiStatus: '',
                    fetchSubtypeHitMap: {},
                    fetchSubtypeProgress: {
                        categoryId: '',
                        categoryName: '',
                        typeNamesPreview: [],
                        typeNamesFullCount: 0,
                        hiddenTypeCount: 0,
                    },
                    lastIsochroneGeoJSON: null,
                    poiMarkers: [],
                    allPoisDetails: [], // Store full fetched data for client-side filtering
                    poiChart: null,
                    poiChartResizeHandler: null,

                    // Instances

                    // History
                    historyListRaw: [],
                    historyList: [],
                    historyLoading: false,
                    historyLoadedCount: 0,
                    historySkeletonCount: 5,
                    historyHasLoadedOnce: false,
                    historyRenderSessionId: 0,
                    historyRenderRafId: null,
                    historyFetchAbortController: null,
                    isSelectionMode: false,
                    selectedHistoryIds: [],

                    // Control
                    abortController: null,

                    // H3 Grid
                    isGeneratingGrid: false,
                    h3GridStatus: '',
                    h3GridCount: 0,
                    h3GridResolution: 10,
                    h3GridIncludeMode: 'intersects',
                    h3NeighborRing: 1,
                    h3GridMinOverlapRatio: 0.15,
                    h3UseArcgis: true,
                    h3ArcgisPythonPath: 'C:\\Python27\\ArcGIS10.7\\python.exe',
                    h3ArcgisImageVersion: 0,
                    h3BasemapMuted: false,
                    h3GridFeatures: [],
                    selectedH3Id: null,
                    isComputingH3Analysis: false,
                    h3AnalysisSummary: null,
                    h3AnalysisCharts: null,
                    h3AnalysisGridFeatures: [],
                    h3MainStage: 'params',
                    h3MainStageLabels: {
                        params: '参数',
                        analysis: '分析',
                        diagnosis: '诊断',
                        evaluate: '评估',
                    },
                    h3MainStageTabs: {
                        params: [],
                        analysis: ['metric_map', 'structure_map'],
                        diagnosis: ['typing', 'lq'],
                        evaluate: ['gap'],
                    },
                    h3SubTabLabels: {
                        metric_map: '密度场',
                        structure_map: '结构图',
                        typing: '功能混合度',
                        lq: '区位商优势（LQ）',
                        gap: '缺口优先区',
                    },
                    h3MetricView: 'density',
                    h3StructureFillMode: 'gi_z',
                    h3Legend: null,
                    h3StructureRenderStats: null,
                    h3EntropyMinPoi: 3,
                    h3SubTab: 'metric_map',
                    h3TargetCategory: '',
                    h3DecisionTopN: 10,
                    h3OnlySignificant: false,
                    h3LqSmoothingAlpha: 0.5,
                    h3CategoryMeta: [],
                    h3GapWeights: { transport: 0.4, life: 0.25, education: 0.2, medical: 0.15 },
                    h3DerivedStats: {
                        structureSummary: null,
                        typingSummary: null,
                        lqSummary: null,
                        gapSummary: null,
                        topCells: {},
                    },
                    h3CategoryChart: null,
                    h3DensityChart: null,
                    h3LqChart: null,
                    h3GapChart: null,
                    h3StructureChart: null,
                    h3ChartsResizeHandler: null,

                }
            },
            async mounted() {
                try {
                    // 1. Initialize config from server-injected variables directly to save an RTT
                    this.config = {
                        amap_js_api_key: "{{ amap_js_api_key }}",
                        amap_js_security_code: "{{ amap_js_security_code }}",
                        tianditu_key: "{{ tianditu_key }}"
                    };
                    this.initializePoiCategoriesFromTypeMap();
                    if (this.basemapSource === 'tianditu') {
                        const tileReady = await this.validateTiandituSource();
                        if (!tileReady) {
                            this.tdtDiagCopyStatus = '';
                        }
                    }

                    // 2. AMap load with timeout to avoid long blocking
                    const amapTimeoutMs = 8000;
                    await Promise.race([
                        this.loadAMapScript(this.config.amap_js_api_key, this.config.amap_js_security_code),
                        new Promise((_, reject) => setTimeout(() => reject(new Error("AMap 加载超时，请检查网络或 Key")), amapTimeoutMs))
                    ]);

                    // 3. Initialize Map after script is ready
                    this.initMap();
                } catch (e) {
                    console.error("Initialization Failed:", e);
                    this.errorMessage = "系统初始化失败: " + e.message;
                } finally {
                    this.loadingConfig = false;
                    const overlay = document.getElementById('loading-overlay');
                    if (overlay) overlay.style.display = 'none';
                }
            },
            beforeUnmount() {
                this.cancelHistoryLoading();
                this.disposePoiChart();
                this.disposeH3Charts();
            },
            watch: {
                sidebarView(newView) {
                    if (newView !== 'history') {
                        this.cancelHistoryLoading();
                    }
                }
            },
            methods: {
                cancelHistoryLoading() {
                    if (this.historyFetchAbortController) {
                        try {
                            this.historyFetchAbortController.abort();
                        } catch (e) {
                            console.warn('history abort failed', e);
                        }
                        this.historyFetchAbortController = null;
                    }
                    if (this.historyRenderRafId !== null) {
                        window.cancelAnimationFrame(this.historyRenderRafId);
                        this.historyRenderRafId = null;
                    }
                    this.historyRenderSessionId += 1;
                },
                normalizeHistoryRecord(item) {
                    const record = Object.assign({}, item || {});
                    const rawDate = record.created_at;
                    let dateText = String(rawDate || '');
                    if (rawDate) {
                        const d = new Date(rawDate);
                        if (!Number.isNaN(d.getTime())) {
                            dateText = d.toLocaleDateString();
                        }
                    }
                    record._createdDateText = dateText;
                    return record;
                },
                progressiveRenderHistory(sessionId) {
                    if (sessionId !== this.historyRenderSessionId) return;
                    if (!Array.isArray(this.historyListRaw)) {
                        this.historyLoading = false;
                        this.historyRenderRafId = null;
                        return;
                    }
                    if (this.historyLoadedCount >= this.historyListRaw.length) {
                        this.historyLoading = false;
                        this.historyRenderRafId = null;
                        return;
                    }

                    const nextItem = this.historyListRaw[this.historyLoadedCount];
                    this.historyList.push(nextItem);
                    this.historyLoadedCount += 1;

                    this.historyRenderRafId = window.requestAnimationFrame(() => {
                        this.progressiveRenderHistory(sessionId);
                    });
                },
                openHistoryView() {
                    this.sidebarView = 'history';
                    const firstLoad = !this.historyHasLoadedOnce && this.historyList.length === 0;
                    this.loadHistoryList({ force: firstLoad, keepExisting: !firstLoad }).catch((err) => {
                        console.warn('History load failed', err);
                    });
                },
                refreshHistoryList() {
                    this.loadHistoryList({ force: true, keepExisting: true }).catch((err) => {
                        console.warn('History refresh failed', err);
                    });
                },
                normalizeTypeCode(value) {
                    const digits = String(value || '').replace(/\D/g, '');
                    return digits.length >= 6 ? digits.slice(0, 6) : digits;
                },
                _normalizeCategoryTitle(value) {
                    return String(value || '').replace(/\s+/g, '').trim();
                },
                _buildDefaultH3CategoryMeta() {
                    const fromTypeMap = (this.typeMapGroups || []).map((group) => ({
                        key: String(group.id || ''),
                        label: String(group.title || group.id || ''),
                    })).filter(item => item.key && item.label);
                    if (fromTypeMap.length) return fromTypeMap;
                    return [
                        { key: 'group-7', label: '餐饮' },
                        { key: 'group-6', label: '购物' },
                        { key: 'group-4', label: '商务住宅' },
                        { key: 'group-3', label: '交通' },
                        { key: 'group-2', label: '旅游' },
                        { key: 'group-13', label: '科教文化' },
                        { key: 'group-10', label: '医疗' },
                    ];
                },
                _resolveDefaultH3TargetCategory() {
                    const categories = Array.isArray(this.h3CategoryMeta) ? this.h3CategoryMeta : [];
                    if (!categories.length) return '';
                    const dining = categories.find(item => this._normalizeCategoryTitle(item.label) === '餐饮');
                    if (dining && dining.key) return dining.key;
                    return String((categories[0] && categories[0].key) || '');
                },
                _ensureH3CategoryState() {
                    if (!Array.isArray(this.h3CategoryMeta) || !this.h3CategoryMeta.length) {
                        this.h3CategoryMeta = this._buildDefaultH3CategoryMeta();
                    }
                    const hasCurrentTarget = (this.h3CategoryMeta || []).some(item => String(item.key) === String(this.h3TargetCategory));
                    if (!hasCurrentTarget) {
                        this.h3TargetCategory = this._resolveDefaultH3TargetCategory();
                    }
                },
                _resolveGapDemandCategoryMap() {
                    const aliases = {
                        transport: '交通',
                        life: '商务住宅',
                        education: '科教文化',
                        medical: '医疗',
                    };
                    const labelToKey = {};
                    (this.h3CategoryMeta || []).forEach((item) => {
                        const normalized = this._normalizeCategoryTitle(item.label);
                        if (!normalized || !item.key || labelToKey[normalized]) return;
                        labelToKey[normalized] = String(item.key);
                    });
                    const mapping = {};
                    const missingTitles = [];
                    Object.entries(aliases).forEach(([weightKey, title]) => {
                        const normalized = this._normalizeCategoryTitle(title);
                        const key = labelToKey[normalized];
                        if (key) {
                            mapping[weightKey] = key;
                        } else {
                            missingTitles.push(title);
                        }
                    });
                    return { mapping, missingTitles };
                },
                initializePoiCategoriesFromTypeMap() {
                    const raw = (this.typeMapConfig && Array.isArray(this.typeMapConfig.groups))
                        ? this.typeMapConfig
                        : { groups: [] };
                    this.typeCodeToCategoryId = {};
                    this.typePrefixToCategoryId = {};
                    this.typeCodeToTypeId = {};
                    this.typePrefixToTypeId = {};
                    this.typeIdToGroupId = {};
                    this.typeIdToLabel = {};
                    const groups = (raw.groups || []).map((group, gi) => {
                        const itemList = Array.isArray(group.items) ? group.items : [];
                        const mergedCodes = [];
                        const seenCodes = new Set();
                        let cardColor = '#888';
                        itemList.forEach((item) => {
                            if (!item || !item.id) return;
                            if (item.color && cardColor === '#888') {
                                cardColor = item.color;
                            }
                            String(item.types || '').split('|').forEach((rawCode) => {
                                const code = this.normalizeTypeCode(rawCode);
                                if (!code || seenCodes.has(code)) return;
                                seenCodes.add(code);
                                mergedCodes.push(code);
                                this.typeCodeToCategoryId[code] = String(group.id || '');
                                this.typeCodeToTypeId[code] = String(item.id || '');
                                if (code.length >= 2 && !this.typePrefixToCategoryId[code.slice(0, 2)]) {
                                    this.typePrefixToCategoryId[code.slice(0, 2)] = String(group.id || '');
                                }
                                if (code.length >= 2 && !this.typePrefixToTypeId[code.slice(0, 2)]) {
                                    this.typePrefixToTypeId[code.slice(0, 2)] = String(item.id || '');
                                }
                            });
                            this.typeIdToGroupId[String(item.id || '')] = String(group.id || '');
                            this.typeIdToLabel[String(item.id || '')] = String(item.label || item.id || '');
                        });

                        return {
                            id: String(group.id || `group-${gi}`),
                            name: String(group.title || group.id || `分类${gi + 1}`),
                            checked: true,
                            color: cardColor,
                            types: mergedCodes.join('|'),
                        };
                    }).filter(g => g.id && g.types);

                    this.typeMapGroups = (raw.groups || []).map((group) => ({
                        ...group,
                        id: String(group.id || ''),
                        title: String(group.title || group.id || ''),
                        items: Array.isArray(group.items) ? group.items.map((item) => ({
                            ...item,
                            id: String(item.id || ''),
                            label: String(item.label || item.id || ''),
                        })) : []
                    })).filter(g => g.id);
                    this.h3CategoryMeta = this._buildDefaultH3CategoryMeta();
                    this.h3TargetCategory = this._resolveDefaultH3TargetCategory();

                    this.poiCategories = groups;
                    if (!this.poiCategories.length) {
                        this.poiCategories = [
                            { id: 'dining', name: '餐饮', checked: true, color: '#f44336', types: '050000' },
                            { id: 'shopping', name: '购物', checked: true, color: '#2196f3', types: '060000' },
                            { id: 'life', name: '生活', checked: true, color: '#ff9800', types: '070000' },
                            { id: 'transport', name: '交通', checked: true, color: '#4caf50', types: '150000' },
                            { id: 'scenic', name: '风景', checked: true, color: '#9c27b0', types: '110000' },
                            { id: 'education', name: '科教', checked: true, color: '#00bcd4', types: '140000' },
                            { id: 'medical', name: '医疗', checked: true, color: '#e91e63', types: '090000' },
                        ];
                        this.poiCategories.forEach((cat) => {
                            this.typeCodeToCategoryId[String(cat.types)] = cat.id;
                            this.typePrefixToCategoryId[String(cat.types).slice(0, 2)] = cat.id;
                            this.typeCodeToTypeId[String(cat.types)] = cat.id;
                            this.typePrefixToTypeId[String(cat.types).slice(0, 2)] = cat.id;
                            this.typeIdToGroupId[cat.id] = cat.id;
                            this.typeIdToLabel[cat.id] = cat.name;
                        });
                    }
                    this.categoryById = {};
                    this.poiCategories.forEach((cat) => {
                        this.categoryById[cat.id] = cat;
                    });
                    this.poiSubSelectionState = {};
                    this.typeMapGroups.forEach((group) => {
                        (group.items || []).forEach((item) => {
                            this.poiSubSelectionState[item.id] = true;
                        });
                    });
                    this.poiCategories.forEach((cat) => this.syncPoiCategorySelection(cat));
                    this.expandedPoiCategoryId = null;
                    this.resetFetchSubtypeProgress();
                },
                resetFetchSubtypeProgress() {
                    this.fetchSubtypeHitMap = {};
                    this.fetchSubtypeProgress = {
                        categoryId: '',
                        categoryName: '',
                        typeNamesPreview: [],
                        typeNamesFullCount: 0,
                        hiddenTypeCount: 0,
                    };
                },
                getPoiTypeLabel(typeId) {
                    const key = String(typeId || '');
                    if (!key) return '';
                    return this.typeIdToLabel[key] || key;
                },
                updateFetchSubtypeProgressDisplay(cat) {
                    const categoryId = String((cat && cat.id) || '');
                    if (!categoryId) return;
                    const typeIds = Object.keys(this.fetchSubtypeHitMap[categoryId] || {});
                    const typeNames = typeIds.map((typeId) => this.getPoiTypeLabel(typeId)).filter(Boolean);
                    const previewLimit = 6;
                    this.fetchSubtypeProgress = {
                        categoryId: categoryId,
                        categoryName: String((cat && cat.name) || categoryId),
                        typeNamesPreview: typeNames.slice(0, previewLimit),
                        typeNamesFullCount: typeNames.length,
                        hiddenTypeCount: Math.max(0, typeNames.length - previewLimit),
                    };
                },
                accumulateFetchSubtypeHits(cat, poiList) {
                    const categoryId = String((cat && cat.id) || '');
                    if (!categoryId) return;
                    if (!this.fetchSubtypeHitMap[categoryId]) {
                        this.fetchSubtypeHitMap[categoryId] = {};
                    }
                    const bucket = this.fetchSubtypeHitMap[categoryId];
                    (poiList || []).forEach((poi) => {
                        const typeId = this.resolvePoiTypeId(poi && poi.type);
                        if (!typeId) return;
                        bucket[String(typeId)] = true;
                    });
                    this.updateFetchSubtypeProgressDisplay(cat);
                },
                getPoiSubItems(categoryId) {
                    const group = (this.typeMapGroups || []).find(g => String(g.id) === String(categoryId));
                    return group && Array.isArray(group.items) ? group.items : [];
                },
                isPoiSubItemChecked(itemId) {
                    return !!this.poiSubSelectionState[itemId];
                },
                getPoiSubSelectedCount(categoryId) {
                    const items = this.getPoiSubItems(categoryId);
                    if (!items.length) return 0;
                    return items.filter(item => !!this.poiSubSelectionState[item.id]).length;
                },
                togglePoiCategoryExpand(categoryId) {
                    this.expandedPoiCategoryId = this.expandedPoiCategoryId === categoryId ? null : categoryId;
                },
                syncPoiCategorySelection(cat) {
                    const items = this.getPoiSubItems(cat.id);
                    if (!items.length) return;
                    const selectedItems = items.filter(item => !!this.poiSubSelectionState[item.id]);
                    cat.checked = selectedItems.length > 0;
                    const seen = new Set();
                    const merged = [];
                    selectedItems.forEach((item) => {
                        String(item.types || '').split('|').forEach((rawCode) => {
                            const code = this.normalizeTypeCode(rawCode);
                            if (!code || seen.has(code)) return;
                            seen.add(code);
                            merged.push(code);
                        });
                    });
                    cat.types = merged.join('|');
                },
                togglePoiCategory(cat, checked) {
                    const items = this.getPoiSubItems(cat.id);
                    if (!items.length) {
                        cat.checked = !!checked;
                        return;
                    }
                    items.forEach((item) => {
                        this.poiSubSelectionState[item.id] = !!checked;
                    });
                    this.syncPoiCategorySelection(cat);
                },
                onPoiSubItemToggle(cat, item, checked) {
                    this.poiSubSelectionState[item.id] = !!checked;
                    this.syncPoiCategorySelection(cat);
                },
                buildSelectedCategoryBuckets() {
                    const buckets = [];
                    (this.poiCategories || []).forEach((cat) => {
                        this.syncPoiCategorySelection(cat);
                        if (!cat.checked || !cat.types) return;
                        buckets.push({
                            id: cat.id,
                            name: cat.name,
                            types: String(cat.types || ''),
                        });
                    });
                    return buckets;
                },
                resolvePoiCategoryId(typeText) {
                    const raw = String(typeText || '');
                    if (raw && this.typeIdToGroupId[raw]) {
                        return this.typeIdToGroupId[raw];
                    }
                    const code = this.normalizeTypeCode(typeText);
                    if (code && this.typeCodeToCategoryId[code]) {
                        return this.typeCodeToCategoryId[code];
                    }
                    if (code.length >= 2 && this.typePrefixToCategoryId[code.slice(0, 2)]) {
                        return this.typePrefixToCategoryId[code.slice(0, 2)];
                    }
                    return '';
                },
                resolvePoiTypeId(typeText) {
                    const raw = String(typeText || '');
                    if (raw && this.typeIdToGroupId[raw]) {
                        return raw;
                    }
                    const code = this.normalizeTypeCode(typeText);
                    if (code && this.typeCodeToTypeId[code]) {
                        return this.typeCodeToTypeId[code];
                    }
                    if (code.length >= 2 && this.typePrefixToTypeId[code.slice(0, 2)]) {
                        return this.typePrefixToTypeId[code.slice(0, 2)];
                    }
                    return '';
                },
                resolvePoiCategory(typeText) {
                    const id = this.resolvePoiCategoryId(typeText);
                    return id ? this.categoryById[id] : null;
                },
                saveAnalysisHistoryAsync(polygon, selectedCats, pois) {
                    if (!this.selectedPoint || !Array.isArray(pois) || pois.length === 0) return;
                    const typesLabel = (selectedCats || []).map(c => c.name).join(',');
                    const compactPois = pois.map((p) => ({
                        id: p && p.id ? String(p.id) : '',
                        name: p && p.name ? String(p.name) : '未命名',
                        location: Array.isArray(p && p.location) ? [p.location[0], p.location[1]] : null,
                        address: p && p.address ? String(p.address) : '',
                        type: p && p.type ? String(p.type) : '',
                        adname: p && p.adname ? String(p.adname) : '',
                        lines: Array.isArray(p && p.lines) ? p.lines : []
                    })).filter((p) => Array.isArray(p.location) && p.location.length === 2);
                    const payload = {
                        center: [this.selectedPoint.lng, this.selectedPoint.lat],
                        polygon: polygon,
                        pois: compactPois,
                        keywords: typesLabel,
                        location_name: this.selectedPoint.lng.toFixed(4) + "," + this.selectedPoint.lat.toFixed(4),
                        mode: this.transportMode,
                        time_min: parseInt(this.timeHorizon),
                    };
                    setTimeout(() => {
                        fetch('/api/v1/analysis/history/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        })
                            .then(async (res) => {
                                if (!res.ok) {
                                    let detail = '';
                                    try {
                                        detail = (await res.text()) || '';
                                    } catch (_) { }
                                    throw new Error(`HTTP ${res.status}${detail ? `: ${detail.slice(0, 200)}` : ''}`);
                                }
                                return res.json().catch(() => ({}));
                            })
                            .then(() => {})
                            .catch((err) => {
                                console.warn('Failed to save history', err);
                                this.poiStatus = `抓取完成，但历史保存失败：${err && err.message ? err.message : String(err)}`;
                            });
                    }, 0);
                },
                clearAnalysisLayers() {
                    if (this.abortController) {
                        this.abortController.abort();
                        this.abortController = null;
                    }
                    this.isFetchingPois = false;
                    this.fetchProgress = 0;
                    this.poiStatus = '';
                    this.resetFetchSubtypeProgress();
                    this.allPoisDetails = [];
                    this.lastIsochroneGeoJSON = null;
                    this.h3GridStatus = '';
                    this.h3GridCount = 0;
                    this.h3GridFeatures = [];
                    this.isGeneratingGrid = false;
                    this.resetH3AnalysisState();

                    if (this.markerManager) {
                        if (this.markerManager.markers) {
                            this.markerManager.markers.forEach(m => m.setMap(null));
                        }
                        if (this.markerManager.destroyClusterers) {
                            this.markerManager.destroyClusterers();
                        }
                        this.markerManager = null;
                    }
                    if (this.poiMarkers) {
                        this.poiMarkers.forEach(m => m.setMap(null));
                        this.poiMarkers = [];
                    }

                    const filterContainer = document.getElementById('filtersContainer');
                    if (filterContainer) filterContainer.innerHTML = '';

                    if (this.mapCore) {
                        if (this.mapCore.clearGridPolygons) {
                            this.mapCore.clearGridPolygons();
                        }
                        this.mapCore.clearCustomPolygons();
                        this.mapCore.setRadius(0);
                    }
                    this.disposePoiChart();
                },
                resetH3AnalysisState() {
                    this.isComputingH3Analysis = false;
                    this.h3AnalysisSummary = null;
                    this.h3AnalysisCharts = null;
                    this.h3AnalysisGridFeatures = [];
                    this.selectedH3Id = null;
                    this.h3MainStage = 'params';
                    this.h3MetricView = 'density';
                    this.h3StructureFillMode = 'gi_z';
                    this.h3SubTab = 'metric_map';
                    this._ensureH3CategoryState();
                    this.h3TargetCategory = this._resolveDefaultH3TargetCategory();
                    this.h3DecisionTopN = 10;
                    this.h3OnlySignificant = false;
                    this.h3Legend = null;
                    this.h3DerivedStats = {
                        structureSummary: null,
                        typingSummary: null,
                        lqSummary: null,
                        gapSummary: null,
                        topCells: {},
                    };
                    this.disposeH3Charts();
                },
                getIsochronePolygonRing() {
                    if (!this.lastIsochroneGeoJSON || !this.lastIsochroneGeoJSON.geometry) return null;
                    const geometry = this.lastIsochroneGeoJSON.geometry;
                    if (geometry.type === 'Polygon') {
                        return geometry.coordinates[0] || null;
                    }
                    if (geometry.type === 'MultiPolygon') {
                        return geometry.coordinates[0] ? geometry.coordinates[0][0] : null;
                    }
                    return null;
                },
                clearH3Grid() {
                    this.h3GridFeatures = [];
                    this.h3GridCount = 0;
                    this.h3GridStatus = '';
                    this.resetH3AnalysisState();
                    if (this.mapCore && this.mapCore.clearGridPolygons) {
                        this.mapCore.clearGridPolygons();
                    }
                },
                async onH3ResolutionChange() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing) {
                        this.clearH3Grid();
                        this.h3GridStatus = '请先完成范围分析后再生成网格';
                        return;
                    }
                    if (this.isComputingH3Analysis) {
                        this.h3GridStatus = '正在计算网格分析，请稍后再调整网格级别';
                        return;
                    }
                    this.h3GridStatus = `网格级别已切换为 res=${this.h3GridResolution}，正在自动刷新网格...`;
                    await this.generateH3Grid();
                },
                onH3GridSettingsChange() {
                    this.clearH3Grid();
                    if (this.h3GridIncludeMode === 'inside') {
                        this.h3GridStatus = `已切换到“完全包含（严格）”，请点击“计算分析”`;
                    } else {
                        this.h3GridStatus = `已切换到“相交优先（边缘保留）”，最小重叠比例=${this.h3GridMinOverlapRatio.toFixed(2)}，请点击“计算分析”`;
                    }
                },
                toggleH3BasemapMuted() {
                    this.h3BasemapMuted = !this.h3BasemapMuted;
                    this.onH3BasemapStyleChange();
                },
                onH3BasemapStyleChange() {
                    if (!this.mapCore || !this.mapCore.setBasemapMuted) return;
                    this.mapCore.setBasemapMuted(!!this.h3BasemapMuted);
                    this.applySimplifyPointVisibility();
                },
                applySimplifyPointVisibility() {
                    const hide = !!this.h3BasemapMuted;

                    if (this.markerManager && typeof this.markerManager.setHideAllPoints === 'function') {
                        this.markerManager.setHideAllPoints(hide);
                        this.markerManager.applyFilters();
                    }

                    if (this.marker) {
                        if (hide) {
                            this.marker.setMap(null);
                        } else if (this.selectedPoint && this.mapCore && this.mapCore.map) {
                            this.marker.setMap(this.mapCore.map);
                        }
                    }

                    if (!this.markerManager && Array.isArray(this.poiMarkers)) {
                        if (hide) {
                            this.poiMarkers.forEach(m => m && m.setMap && m.setMap(null));
                        } else if (this.allPoisDetails && this.allPoisDetails.length > 0) {
                            this.toggleCategory();
                        }
                    }
                },
                async onBasemapSourceChange() {
                    const allowedSources = ['amap', 'osm', 'tianditu'];
                    let source = allowedSources.includes(this.basemapSource) ? this.basemapSource : 'amap';
                    if (source === 'tianditu') {
                        const tileReady = await this.validateTiandituSource();
                        if (!tileReady) {
                            this.tdtDiagCopyStatus = '';
                        }
                    } else {
                        this.tdtDiag = null;
                        this.tdtDiagCopyStatus = '';
                        if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                            this.errorMessage = '';
                        }
                    }
                    this.basemapSource = source;
                    if (this.mapCore && this.mapCore.setBasemapSource) {
                        const applyResult = this.mapCore.setBasemapSource(source);
                        if (source === 'tianditu' && applyResult && applyResult.ok === false) {
                            this.tdtDiag = {
                                ok: false,
                                phase: 'map-init',
                                status: null,
                                contentType: '',
                                bodySnippet: applyResult.message || '',
                                reason: applyResult.code || 'wmts-layer-init-failed',
                            };
                            this.errorMessage = '天地图 WMTS 图层初始化失败，请检查：Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                        } else if (source === 'tianditu' && applyResult && applyResult.ok === true) {
                            if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                                this.errorMessage = '';
                            }
                        }
                    }
                    if (this.mapCore && this.mapCore.setBasemapMuted) {
                        this.mapCore.setBasemapMuted(!!this.h3BasemapMuted);
                    }
                    this.applySimplifyPointVisibility();
                },
                async generateH3Grid() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing || this.isGeneratingGrid || this.isComputingH3Analysis) return;

                    this.isGeneratingGrid = true;
                    this.resetH3AnalysisState();
                    this.h3GridStatus = '正在生成网络...';
                    try {
                        const polygon = rawRing.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        }).filter(pt => Array.isArray(pt) && pt.length >= 2);

                        const res = await fetch('/api/v1/analysis/h3-grid', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                polygon: polygon,
                                resolution: this.h3GridResolution,
                                coord_type: 'gcj02',
                                include_mode: this.h3GridIncludeMode,
                                min_overlap_ratio: this.h3GridIncludeMode === 'intersects'
                                    ? this.h3GridMinOverlapRatio
                                    : 0
                            })
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                detail = await res.text();
                            } catch (_) { }
                            throw new Error(detail || '网络生成失败');
                        }

                        const data = await res.json();
                        this.h3GridFeatures = data.features || [];
                        this.h3GridCount = Number.isFinite(data.count) ? data.count : this.h3GridFeatures.length;

                        if (this.mapCore && this.mapCore.setGridFeatures) {
                            this.mapCore.setGridFeatures(this.h3GridFeatures, {
                                strokeColor: '#2c6ecb',
                                strokeWeight: 1.1,
                                fillOpacity: 0,
                            });
                        }
                        this.h3GridStatus = this.h3GridCount > 0
                            ? `已生成 ${this.h3GridCount} 个 H3 网格`
                            : '已生成网络，但当前范围无可用网格';
                    } catch (e) {
                        console.error(e);
                        this.h3GridStatus = '网络生成失败: ' + e.message;
                    } finally {
                        this.isGeneratingGrid = false;
                    }
                },
                async ensureH3GridOnEnter() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing) {
                        this.h3GridStatus = '请先完成范围分析后再生成网格';
                        return;
                    }
                    if (this.isGeneratingGrid || this.isComputingH3Analysis) return;
                    await this.generateH3Grid();
                },
                _toNumber(value, fallback = 0) {
                    const n = Number(value);
                    return Number.isFinite(n) ? n : fallback;
                },
                shortH3Id(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id) return '-';
                    if (id.length <= 12) return id;
                    return `${id.slice(0, 5)}...${id.slice(-4)}`;
                },
                focusGridByH3Id(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id || !this.mapCore || !this.mapCore.focusGridCellById) return;
                    this.selectedH3Id = id;
                    const found = this.mapCore.focusGridCellById(id, {
                        fitView: true,
                        zoomMin: 16,
                        animate: true,
                        strokeColor: '#22d3ee',
                        pulseColor: '#ecfeff'
                    });
                    if (!found) {
                        this.h3GridStatus = `未找到对应网格：${id}`;
                        return;
                    }
                    const row = this._findH3RowById(id);
                    if (row) {
                        this.h3GridStatus = this._buildH3StructureStatusText(row);
                    } else {
                        this.h3GridStatus = `已定位网格：${id}`;
                    }
                },
                onH3GridFeatureClick(payload) {
                    const id = payload && payload.h3_id ? String(payload.h3_id) : '';
                    if (!id) return;
                    this.focusGridByH3Id(id);
                },
                _findH3RowById(h3Id) {
                    const id = h3Id ? String(h3Id) : '';
                    if (!id) return null;
                    const rows = (this.h3DerivedStats && this.h3DerivedStats.structureSummary && this.h3DerivedStats.structureSummary.rows) || [];
                    const found = rows.find((row) => String(row.h3_id || '') === id);
                    if (found) return found;
                    const feature = (this.h3AnalysisGridFeatures || []).find((f) => String((f.properties || {}).h3_id || '') === id);
                    if (!feature) return null;
                    const props = feature.properties || {};
                    const giZ = Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null;
                    const lisaI = Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null;
                    const fallbackSignal = Math.max(
                        Number.isFinite(giZ) ? Math.abs(giZ) : 0,
                        Number.isFinite(lisaI) ? Math.abs(lisaI) : 0
                    );
                    return {
                        h3_id: id,
                        gi_star_z_score: giZ,
                        lisa_i: lisaI,
                        structure_signal: Number.isFinite(Number(props.structure_signal)) ? Number(props.structure_signal) : fallbackSignal,
                        density: this._toNumber(props.density_poi_per_km2, 0),
                    };
                },
                _buildH3StructureStatusText(row) {
                    const giText = row && Number.isFinite(this._toNumber(row.gi_star_z_score, NaN))
                        ? this._toNumber(row.gi_star_z_score, 0).toFixed(2)
                        : '-';
                    const lisaText = row && Number.isFinite(this._toNumber(row.lisa_i, NaN))
                        ? this._toNumber(row.lisa_i, 0).toFixed(2)
                        : '-';
                    const signalText = row && Number.isFinite(this._toNumber(row.structure_signal, NaN))
                        ? this._toNumber(row.structure_signal, 0).toFixed(2)
                        : '-';
                    const densityText = row && Number.isFinite(this._toNumber(row.density, NaN))
                        ? this._toNumber(row.density, 0).toFixed(2)
                        : '-';
                    return `Gi*z=${giText} | LISA I=${lisaText} | 结构信号=${signalText} | 密度=${densityText}`;
                },
                getArcgisSnapshotUrl() {
                    const summary = this.h3AnalysisSummary || {};
                    const giUrl = summary.arcgis_image_url_gi || null;
                    const lisaUrl = summary.arcgis_image_url_lisa || null;
                    const legacyUrl = summary.arcgis_image_url || null;
                    if (this.h3SubTab === 'structure_map') {
                        if (this.h3StructureFillMode === 'lisa_i') {
                            return lisaUrl || legacyUrl || giUrl || null;
                        }
                        return giUrl || legacyUrl || lisaUrl || null;
                    }
                    return legacyUrl || giUrl || lisaUrl || null;
                },
                getArcgisSnapshotTitle() {
                    if (this.h3SubTab === 'structure_map') {
                        if (this.h3StructureFillMode === 'lisa_i') {
                            return 'ArcGIS 结构快照（LISA / LMiIndex）';
                        }
                        return 'ArcGIS 结构快照（Gi* / Z-score）';
                    }
                    return 'ArcGIS 结构快照';
                },
                clearGridLock() {
                    if (this.mapCore && this.mapCore.clearGridFocus) {
                        this.mapCore.clearGridFocus({ restoreView: true });
                    }
                    this.selectedH3Id = null;
                    this.h3GridStatus = '';
                },
                tryRefocusSelectedGrid() {
                    if (!this.selectedH3Id || !this.mapCore || !this.mapCore.focusGridCellById) return;
                    this.mapCore.focusGridCellById(this.selectedH3Id, { panTo: false, animate: false });
                },
                _quantile(sortedValues, q) {
                    if (!Array.isArray(sortedValues) || sortedValues.length === 0) return 0;
                    if (sortedValues.length === 1) return sortedValues[0];
                    const qq = Math.max(0, Math.min(1, q));
                    const pos = qq * (sortedValues.length - 1);
                    const lower = Math.floor(pos);
                    const upper = Math.min(sortedValues.length - 1, lower + 1);
                    const ratio = pos - lower;
                    return sortedValues[lower] + (sortedValues[upper] - sortedValues[lower]) * ratio;
                },
                _calcContinuousStats(values) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!valid.length) {
                        return {
                            count: 0,
                            mean: null,
                            std: null,
                            min: null,
                            max: null,
                            p10: null,
                            p50: null,
                            p90: null,
                        };
                    }
                    const count = valid.length;
                    const mean = valid.reduce((sum, v) => sum + v, 0) / count;
                    const variance = valid.reduce((sum, v) => sum + (v - mean) * (v - mean), 0) / count;
                    return {
                        count: count,
                        mean: mean,
                        std: Math.sqrt(Math.max(0, variance)),
                        min: valid[0],
                        max: valid[valid.length - 1],
                        p10: this._quantile(valid, 0.1),
                        p50: this._quantile(valid, 0.5),
                        p90: this._quantile(valid, 0.9),
                    };
                },
                _normalizeContinuousStats(stats, fallback) {
                    const source = (stats && typeof stats === 'object') ? stats : (fallback || {});
                    const toMetric = (value) => Number.isFinite(this._toNumber(value, NaN))
                        ? this._toNumber(value, 0)
                        : null;
                    return {
                        count: Math.max(0, Math.round(this._toNumber(source.count, 0))),
                        mean: toMetric(source.mean),
                        std: toMetric(source.std),
                        min: toMetric(source.min),
                        max: toMetric(source.max),
                        p10: toMetric(source.p10),
                        p50: toMetric(source.p50),
                        p90: toMetric(source.p90),
                    };
                },
                _normalizeGiRenderMeta(meta) {
                    const source = (meta && typeof meta === 'object') ? meta : {};
                    const min = Number.isFinite(this._toNumber(source.min, NaN)) ? this._toNumber(source.min, -3) : -3;
                    const max = Number.isFinite(this._toNumber(source.max, NaN)) ? this._toNumber(source.max, 3) : 3;
                    const center = Number.isFinite(this._toNumber(source.center, NaN)) ? this._toNumber(source.center, 0) : 0;
                    return {
                        mode: 'fixed_z',
                        min: Math.min(min, max),
                        max: Math.max(min, max),
                        center: Math.max(Math.min(center, Math.max(min, max)), Math.min(min, max)),
                    };
                },
                _normalizeLisaRenderMeta(meta, lisaIStats) {
                    const stats = lisaIStats || {};
                    const mean = Number.isFinite(this._toNumber(stats.mean, NaN)) ? this._toNumber(stats.mean, 0) : 0;
                    const std = Number.isFinite(this._toNumber(stats.std, NaN)) ? this._toNumber(stats.std, 0) : 0;
                    const p10 = Number.isFinite(this._toNumber(stats.p10, NaN)) ? this._toNumber(stats.p10, NaN) : null;
                    const p90 = Number.isFinite(this._toNumber(stats.p90, NaN)) ? this._toNumber(stats.p90, NaN) : null;
                    const minV = Number.isFinite(this._toNumber(stats.min, NaN)) ? this._toNumber(stats.min, NaN) : null;
                    const maxV = Number.isFinite(this._toNumber(stats.max, NaN)) ? this._toNumber(stats.max, NaN) : null;
                    const source = (meta && typeof meta === 'object') ? meta : {};
                    const clipMinRaw = Number.isFinite(this._toNumber(source.clip_min, NaN))
                        ? this._toNumber(source.clip_min, NaN)
                        : Math.max(
                            Number.isFinite(this._toNumber(mean - 2 * std, NaN)) ? this._toNumber(mean - 2 * std, NaN) : -Infinity,
                            Number.isFinite(this._toNumber(p10, NaN)) ? this._toNumber(p10, NaN) : -Infinity,
                            Number.isFinite(this._toNumber(minV, NaN)) ? this._toNumber(minV, NaN) : -Infinity
                        );
                    const clipMaxRaw = Number.isFinite(this._toNumber(source.clip_max, NaN))
                        ? this._toNumber(source.clip_max, NaN)
                        : Math.min(
                            Number.isFinite(this._toNumber(mean + 2 * std, NaN)) ? this._toNumber(mean + 2 * std, NaN) : Infinity,
                            Number.isFinite(this._toNumber(p90, NaN)) ? this._toNumber(p90, NaN) : Infinity,
                            Number.isFinite(this._toNumber(maxV, NaN)) ? this._toNumber(maxV, NaN) : Infinity
                        );
                    const clipMin = Number.isFinite(clipMinRaw) ? clipMinRaw : mean;
                    const clipMax = Number.isFinite(clipMaxRaw) ? clipMaxRaw : mean;
                    const fallbackDegraded = !(Number.isFinite(std) && std > 0 && Number.isFinite(clipMin) && Number.isFinite(clipMax) && clipMax > clipMin);
                    return {
                        mode: 'stddev',
                        mean: Number.isFinite(this._toNumber(source.mean, NaN)) ? this._toNumber(source.mean, mean) : mean,
                        std: Number.isFinite(this._toNumber(source.std, NaN)) ? this._toNumber(source.std, std) : std,
                        min: Number.isFinite(this._toNumber(source.min, NaN)) ? this._toNumber(source.min, NaN) : stats.min,
                        max: Number.isFinite(this._toNumber(source.max, NaN)) ? this._toNumber(source.max, NaN) : stats.max,
                        clip_min: Math.min(clipMin, clipMax),
                        clip_max: Math.max(clipMin, clipMax),
                        degraded: source.degraded === true || fallbackDegraded,
                        message: source.message || (fallbackDegraded ? 'LMiIndex方差不足' : null),
                    };
                },
                _buildQuantileBreaks(values, binCount = 5) {
                    const sorted = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!sorted.length || sorted[0] === sorted[sorted.length - 1]) {
                        return [];
                    }
                    const breaks = [];
                    for (let i = 1; i < binCount; i += 1) {
                        breaks.push(this._quantile(sorted, i / binCount));
                    }
                    for (let i = 1; i < breaks.length; i += 1) {
                        if (breaks[i] < breaks[i - 1]) {
                            breaks[i] = breaks[i - 1];
                        }
                    }
                    const deduped = [];
                    const eps = 1e-9;
                    for (const value of breaks) {
                        if (!deduped.length || Math.abs(value - deduped[deduped.length - 1]) > eps) {
                            deduped.push(value);
                        }
                    }
                    return deduped;
                },
                _buildDivergingBreaks(values) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v))
                        .sort((a, b) => a - b);
                    if (!valid.length) return [];
                    const negatives = valid.filter(v => v < 0);
                    const positives = valid.filter(v => v > 0);
                    if (!negatives.length || !positives.length) {
                        return this._buildQuantileBreaks(valid, 5);
                    }
                    const breaks = [
                        this._quantile(negatives, 1 / 3),
                        this._quantile(negatives, 2 / 3),
                        this._quantile(positives, 1 / 3),
                        this._quantile(positives, 2 / 3),
                    ];
                    for (let i = 1; i < breaks.length; i += 1) {
                        if (breaks[i] < breaks[i - 1]) {
                            breaks[i] = breaks[i - 1];
                        }
                    }
                    const deduped = [];
                    const eps = 1e-9;
                    for (const value of breaks) {
                        if (!deduped.length || Math.abs(value - deduped[deduped.length - 1]) > eps) {
                            deduped.push(value);
                        }
                    }
                    return deduped;
                },
                _getMetricSpec(metricKey) {
                    if (metricKey === 'entropy') {
                        return {
                            key: 'entropy',
                            label: '局部熵（归一化）',
                            unit: '0~1',
                            diverging: false,
                            palette: ['#f4fbe8', '#d6efbe', '#a5d88a', '#6bb65d', '#2f7e39'],
                            noDataColor: '#d1d5db',
                            noDataOpacity: 0.10,
                            fillOpacity: 0.24,
                            noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                        };
                    }
                    if (metricKey === 'neighbor_delta') {
                        return {
                            key: 'neighbor_delta',
                            label: '邻域差值（本格-邻域）',
                            unit: 'POI/km²',
                            diverging: true,
                            palette: ['#2b6cb0', '#90cdf4', '#f7f7f7', '#f6ad55', '#c53030'],
                            noDataColor: '#d1d5db',
                            noDataOpacity: 0.10,
                            fillOpacity: 0.24,
                            noDataLabel: '',
                        };
                    }
                    return {
                        key: 'density',
                        label: '密度',
                        unit: 'POI/km²',
                        diverging: false,
                        palette: ['#e8f1ff', '#b7d2ff', '#7eaef9', '#3f82e0', '#1f4f9a'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: '',
                    };
                },
                _getH3MetricValue(props, metricKey) {
                    if (!props) return { value: null, noData: true };
                    const density = this._toNumber(props.density_poi_per_km2, 0);
                    if (metricKey === 'entropy') {
                        const poiCount = this._toNumber(props.poi_count, 0);
                        if (poiCount < this.h3EntropyMinPoi) {
                            return { value: null, noData: true };
                        }
                        const rawEntropy = this._toNumber(props.local_entropy, 0);
                        const normalized = rawEntropy / Math.log(7);
                        const bounded = Math.max(0, Math.min(1, normalized));
                        return { value: bounded, noData: false };
                    }
                    if (metricKey === 'neighbor_delta') {
                        const neighbor = this._toNumber(props.neighbor_mean_density, 0);
                        return { value: density - neighbor, noData: false };
                    }
                    return { value: density, noData: false };
                },
                _colorByBreaks(value, breaks, palette) {
                    if (!Number.isFinite(value)) return '#d1d5db';
                    if (!Array.isArray(breaks) || !breaks.length) {
                        return palette[Math.max(0, Math.floor((palette.length - 1) / 2))] || '#dbe9ff';
                    }
                    let idx = breaks.findIndex(bound => value <= bound);
                    if (idx < 0) idx = palette.length - 1;
                    return palette[Math.max(0, Math.min(idx, palette.length - 1))] || '#dbe9ff';
                },
                _formatLegendValue(value, metricKey) {
                    if (!Number.isFinite(value)) return '-';
                    if (metricKey === 'entropy') return value.toFixed(2);
                    const abs = Math.abs(value);
                    if (abs >= 100) return value.toFixed(0);
                    if (abs >= 10) return value.toFixed(1);
                    return value.toFixed(2);
                },
                _buildLegend(metricSpec, breaks, validValues) {
                    const palette = metricSpec.palette || [];
                    const legend = {
                        title: metricSpec.label,
                        unit: metricSpec.unit,
                        items: [],
                        noDataLabel: metricSpec.noDataLabel || '',
                        noDataColor: metricSpec.noDataColor || '#d1d5db',
                    };
                    if (!palette.length) return legend;
                    if (!Array.isArray(validValues) || !validValues.length) {
                        legend.items = [{ color: palette[0], label: '无有效数据' }];
                        return legend;
                    }
                    if (!breaks.length) {
                        const minV = Math.min(...validValues);
                        const maxV = Math.max(...validValues);
                        legend.items = [{
                            color: palette[palette.length - 1],
                            label: `${this._formatLegendValue(minV, metricSpec.key)} ~ ${this._formatLegendValue(maxV, metricSpec.key)}`
                        }];
                        return legend;
                    }
                    const classCount = Math.min(palette.length, breaks.length + 1);
                    for (let i = 0; i < classCount; i += 1) {
                        let label = '';
                        if (i === 0) {
                            label = `≤ ${this._formatLegendValue(breaks[0], metricSpec.key)}`;
                        } else if (i === classCount - 1) {
                            label = `> ${this._formatLegendValue(breaks[breaks.length - 1], metricSpec.key)}`;
                        } else {
                            label = `${this._formatLegendValue(breaks[i - 1], metricSpec.key)} ~ ${this._formatLegendValue(breaks[i], metricSpec.key)}`;
                        }
                        legend.items.push({ color: palette[i], label: label });
                    }
                    return legend;
                },
                _percentileFromSorted(sortedValues, value) {
                    if (!Array.isArray(sortedValues) || !sortedValues.length || !Number.isFinite(value)) return 0;
                    const n = sortedValues.length;
                    if (n === 1) return 0.5;
                    let lower = 0;
                    while (lower < n && sortedValues[lower] < value) lower += 1;
                    let upper = lower;
                    while (upper < n && sortedValues[upper] <= value) upper += 1;
                    const midRank = (lower + upper - 1) / 2;
                    return Math.max(0, Math.min(1, midRank / (n - 1)));
                },
                _getConfidenceInfo(poiCount) {
                    const count = this._toNumber(poiCount, 0);
                    if (count >= 10) return { score: 2, label: '高' };
                    if (count >= 5) return { score: 1, label: '中' };
                    return { score: 0, label: '低' };
                },
                _getH3CategoryLabel(key) {
                    const hit = (this.h3CategoryMeta || []).find(item => item.key === key);
                    return hit ? hit.label : key;
                },
                classifyGridType(featureProps, thresholds = {}) {
                    const density = this._toNumber(featureProps.density, 0);
                    const entropyNorm = Number.isFinite(featureProps.entropy_norm) ? featureProps.entropy_norm : null;
                    const neighborDelta = this._toNumber(featureProps.neighbor_delta, 0);
                    if (entropyNorm === null) {
                        return {
                            type_key: 'no_data',
                            type_label: '样本不足',
                            is_opportunity: false,
                        };
                    }
                    const highDensity = density >= this._toNumber(thresholds.densityP70, 0);
                    const highEntropy = entropyNorm >= this._toNumber(thresholds.entropyP70, 0);
                    let typeKey = 'low_density_low_mix';
                    let typeLabel = '低密-低混合';
                    if (highDensity && highEntropy) {
                        typeKey = 'high_density_high_mix';
                        typeLabel = '高密-高混合';
                    } else if (highDensity && !highEntropy) {
                        typeKey = 'high_density_low_mix';
                        typeLabel = '高密-低混合';
                    } else if (!highDensity && highEntropy) {
                        typeKey = 'low_density_high_mix';
                        typeLabel = '低密-高混合';
                    }
                    const isOpportunity = typeKey === 'high_density_high_mix' && neighborDelta > 0;
                    return {
                        type_key: typeKey,
                        type_label: typeLabel,
                        is_opportunity: isOpportunity,
                    };
                },
                computeCellLQ(featureProps, globalCategoryCounts, globalTotal) {
                    const poiCount = this._toNumber(featureProps.poi_count, 0);
                    if (poiCount < this.h3EntropyMinPoi) return null;
                    const categoryCounts = featureProps.category_counts || {};
                    const categorySize = Math.max(1, (this.h3CategoryMeta || []).length);
                    const alpha = Math.max(0, this._toNumber(this.h3LqSmoothingAlpha, 0.5));
                    const result = {};
                    (this.h3CategoryMeta || []).forEach(item => {
                        const key = item.key;
                        const gCount = this._toNumber(globalCategoryCounts[key], 0);
                        const cCount = this._toNumber(categoryCounts[key], 0);
                        const gShare = (gCount + alpha) / (Math.max(0, globalTotal) + alpha * categorySize);
                        const cShare = (cCount + alpha) / (Math.max(0, poiCount) + alpha * categorySize);
                        result[key] = gShare > 0 ? (cShare / gShare) : null;
                    });
                    return result;
                },
                computeGapScore(featureProps, targetCategory, gapDemandMapping = null) {
                    const density = this._toNumber(featureProps.density, 0);
                    const poiCount = this._toNumber(featureProps.poi_count, 0);
                    const categoryCounts = featureProps.category_counts || {};
                    const densityByCategory = {};
                    (this.h3CategoryMeta || []).forEach(item => {
                        const count = this._toNumber(categoryCounts[item.key], 0);
                        densityByCategory[item.key] = poiCount > 0 ? density * (count / poiCount) : 0;
                    });
                    const weights = this.h3GapWeights || {};
                    const mapping = gapDemandMapping || {};
                    const demandProxy =
                        this._toNumber(weights.transport, 0) * this._toNumber(densityByCategory[mapping.transport], 0) +
                        this._toNumber(weights.life, 0) * this._toNumber(densityByCategory[mapping.life], 0) +
                        this._toNumber(weights.education, 0) * this._toNumber(densityByCategory[mapping.education], 0) +
                        this._toNumber(weights.medical, 0) * this._toNumber(densityByCategory[mapping.medical], 0);
                    const supplyTargetDensity = this._toNumber(densityByCategory[targetCategory], 0);
                    return {
                        demand_proxy: demandProxy,
                        supply_target_density: supplyTargetDensity,
                    };
                },
                classifyGapZone(demandPct, supplyPct, gapScore) {
                    const demand = this._toNumber(demandPct, 0);
                    const supply = this._toNumber(supplyPct, 0);
                    const gap = this._toNumber(gapScore, 0);
                    if (demand >= 0.6 && supply < 0.4) return '补位机会区';
                    if (demand >= 0.6 && supply >= 0.6) return '高需求高供给（竞争区）';
                    if (demand < 0.4 && supply >= 0.6) return '低需求高供给（偏饱和）';
                    if (demand < 0.4 && supply < 0.4) return '低需求低供给（观察区）';
                    if (gap >= 0.15) return '偏机会区';
                    if (gap <= -0.15) return '偏饱和区';
                    return '相对平衡区';
                },
                computeH3DerivedStats() {
                    this._ensureH3CategoryState();
                    const features = this.h3AnalysisGridFeatures || [];
                    const topN = Math.max(3, Math.min(30, Math.round(this._toNumber(this.h3DecisionTopN, 10))));
                    this.h3DecisionTopN = topN;
                    if (!features.length) {
                        this.h3DerivedStats = {
                            structureSummary: null,
                            typingSummary: null,
                            lqSummary: null,
                            gapSummary: null,
                            topCells: {},
                        };
                        return;
                    }

                    const rowsBase = features.map((feature) => {
                        const props = feature.properties || {};
                        const entropyRaw = this._getH3MetricValue(props, 'entropy');
                        const density = this._toNumber(props.density_poi_per_km2, 0);
                        const neighborDensity = this._toNumber(props.neighbor_mean_density, 0);
                        return {
                            h3_id: props.h3_id || '',
                            poi_count: this._toNumber(props.poi_count, 0),
                            density: density,
                            entropy_norm: entropyRaw.noData ? null : entropyRaw.value,
                            neighbor_delta: density - neighborDensity,
                            category_counts: Object.assign({}, props.category_counts || {}),
                            confidence: this._getConfidenceInfo(props.poi_count),
                            lisa_i: Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null,
                            gi_star_z_score: Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null,
                        };
                    });
                    const rowsEnriched = rowsBase;

                    const densitySorted = rowsEnriched.map(r => r.density).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                    const entropySorted = rowsEnriched.map(r => r.entropy_norm).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                    const densityP70 = densitySorted.length ? this._quantile(densitySorted, 0.7) : 0;
                    const entropyP70 = entropySorted.length ? this._quantile(entropySorted, 0.7) : 0;

                    const typingRows = rowsEnriched.map((row) => {
                        const typed = this.classifyGridType(row, { densityP70, entropyP70 });
                        return Object.assign({}, row, typed);
                    }).sort((a, b) => {
                        if ((b.is_opportunity ? 1 : 0) !== (a.is_opportunity ? 1 : 0)) {
                            return (b.is_opportunity ? 1 : 0) - (a.is_opportunity ? 1 : 0);
                        }
                        if (b.density !== a.density) return b.density - a.density;
                        const confidenceDiff = this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                        if (confidenceDiff !== 0) return confidenceDiff;
                        return this._toNumber(b.entropy_norm, -1) - this._toNumber(a.entropy_norm, -1);
                    });
                    const typingCountByType = {};
                    typingRows.forEach(row => {
                        const key = row.type_key || 'unknown';
                        typingCountByType[key] = (typingCountByType[key] || 0) + 1;
                    });
                    const typingOpportunityCount = typingRows.filter(r => r.is_opportunity).length;
                    const typingMaxDensity = typingRows.length ? Math.max(...typingRows.map(r => this._toNumber(r.density, 0))) : 0;

                    const baseGiStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_z_stats,
                        this._calcContinuousStats(rowsEnriched.map(r => r.gi_star_z_score))
                    );
                    const baseLisaStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_i_stats,
                        this._calcContinuousStats(rowsEnriched.map(r => r.lisa_i))
                    );
                    const lisaMean = this._toNumber(baseLisaStats.mean, 0);
                    const lisaStd = this._toNumber(baseLisaStats.std, 0);
                    const structureRowsBase = rowsEnriched.map((row) => {
                        const giSignal = Number.isFinite(row.gi_star_z_score)
                            ? Math.abs(this._toNumber(row.gi_star_z_score, 0))
                            : 0;
                        let lisaSignal = 0;
                        if (Number.isFinite(row.lisa_i)) {
                            if (lisaStd > 0) {
                                lisaSignal = Math.abs((this._toNumber(row.lisa_i, 0) - lisaMean) / lisaStd);
                            } else {
                                lisaSignal = Math.abs(this._toNumber(row.lisa_i, 0) - lisaMean) > 0 ? 1 : 0;
                            }
                        }
                        const structureSignal = Math.max(giSignal, lisaSignal);
                        const hasStructureMetric = Number.isFinite(row.gi_star_z_score) || Number.isFinite(row.lisa_i);
                        return Object.assign({}, row, {
                            structure_signal: structureSignal,
                            structure_rank: structureSignal,
                            is_structure_signal: hasStructureMetric && structureSignal >= 1.0,
                        });
                    });
                    const structureRows = (this.h3OnlySignificant
                        ? structureRowsBase.filter(r => r.is_structure_signal)
                        : structureRowsBase
                    ).sort((a, b) => {
                        const rankDiff = this._toNumber(b.structure_rank, 0) - this._toNumber(a.structure_rank, 0);
                        if (rankDiff !== 0) return rankDiff;
                        const giDiff = Math.abs(this._toNumber(b.gi_star_z_score, 0)) - Math.abs(this._toNumber(a.gi_star_z_score, 0));
                        if (giDiff !== 0) return giDiff;
                        if (b.density !== a.density) return b.density - a.density;
                        return this._toNumber(b.poi_count, 0) - this._toNumber(a.poi_count, 0);
                    });
                    const giZStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_z_stats,
                        this._calcContinuousStats(structureRowsBase.map(r => r.gi_star_z_score))
                    );
                    const lisaIStats = this._normalizeContinuousStats(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_i_stats,
                        this._calcContinuousStats(structureRowsBase.map(r => r.lisa_i))
                    );
                    const giRenderMeta = this._normalizeGiRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.gi_render_meta
                    );
                    const lisaRenderMeta = this._normalizeLisaRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_render_meta,
                        lisaIStats
                    );
                    const lisaValidCount = Math.max(0, this._toNumber(lisaIStats.count, 0));
                    const lisaPositiveCount = structureRowsBase.filter(r => Number.isFinite(r.lisa_i) && this._toNumber(r.lisa_i, 0) > 0).length;
                    const lisaNegativeCount = structureRowsBase.filter(r => Number.isFinite(r.lisa_i) && this._toNumber(r.lisa_i, 0) < 0).length;
                    const lisaPositivePct = lisaValidCount > 0 ? (lisaPositiveCount / lisaValidCount) : null;
                    const lisaNegativePct = lisaValidCount > 0 ? (lisaNegativeCount / lisaValidCount) : null;

                    const rowsWithSignal = structureRowsBase;
                    const globalCategoryCounts = {};
                    (this.h3CategoryMeta || []).forEach(item => { globalCategoryCounts[item.key] = 0; });
                    rowsWithSignal.forEach(row => {
                        (this.h3CategoryMeta || []).forEach(item => {
                            globalCategoryCounts[item.key] += this._toNumber(row.category_counts[item.key], 0);
                        });
                    });
                    const globalTotal = Object.values(globalCategoryCounts).reduce((s, v) => s + this._toNumber(v, 0), 0);
                    const lqRowsAll = rowsWithSignal.map(row => {
                        const lqMap = this.computeCellLQ(row, globalCategoryCounts, globalTotal);
                        let dominantKey = null;
                        let dominantValue = null;
                        if (lqMap) {
                            (this.h3CategoryMeta || []).forEach(item => {
                                const v = lqMap[item.key];
                                if (!Number.isFinite(v)) return;
                                if (!Number.isFinite(dominantValue) || v > dominantValue) {
                                    dominantValue = v;
                                    dominantKey = item.key;
                                }
                            });
                        }
                        return Object.assign({}, row, {
                            lq_map: lqMap,
                            lq_target: lqMap ? lqMap[this.h3TargetCategory] : null,
                            dominant_key: dominantKey,
                            dominant_value: dominantValue,
                        });
                    }).sort((a, b) => {
                        const lqDiff = this._toNumber(b.lq_target, -1) - this._toNumber(a.lq_target, -1);
                        if (lqDiff !== 0) return lqDiff;
                        return this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                    });
                    const lqRows = this.h3OnlySignificant
                        ? lqRowsAll.filter(r => r.is_structure_signal)
                        : lqRowsAll;
                    const lqOpportunityCount = lqRows.filter(r => Number.isFinite(r.lq_target) && r.lq_target >= 1.2).length;
                    const lqMax = lqRows.length ? Math.max(...lqRows.map(r => this._toNumber(r.lq_target, 0))) : 0;
                    const dominantCounts = {};
                    (this.h3CategoryMeta || []).forEach(item => { dominantCounts[item.key] = 0; });
                    lqRowsAll.forEach(row => {
                        if (row.dominant_key && Number.isFinite(row.dominant_value) && row.dominant_value > 1) {
                            dominantCounts[row.dominant_key] += 1;
                        }
                    });

                    const gapDemandCategory = this._resolveGapDemandCategoryMap();
                    const missingMapTitles = gapDemandCategory.missingTitles || [];
                    const gapMappingWarning = missingMapTitles.length
                        ? `Gap映射缺失：未找到“${missingMapTitles.join('、')}”，对应权重按0处理`
                        : '';
                    const gapRowsRaw = rowsWithSignal.map(row => Object.assign({}, row, this.computeGapScore(
                        row,
                        this.h3TargetCategory,
                        gapDemandCategory.mapping || {}
                    )));
                    const demandValues = gapRowsRaw.map(r => r.demand_proxy).filter(v => Number.isFinite(v));
                    const supplyValues = gapRowsRaw.map(r => r.supply_target_density).filter(v => Number.isFinite(v));
                    const demandSorted = demandValues.slice().sort((a, b) => a - b);
                    const supplySorted = supplyValues.slice().sort((a, b) => a - b);
                    const gapRowsAll = gapRowsRaw.map(row => {
                        const demandPct = this._percentileFromSorted(demandSorted, row.demand_proxy);
                        const supplyPct = this._percentileFromSorted(supplySorted, row.supply_target_density);
                        const gapScore = demandPct - supplyPct;
                        return Object.assign({}, row, {
                            demand_pct: demandPct,
                            supply_pct: supplyPct,
                            gap_score: gapScore,
                            gap_zone_label: this.classifyGapZone(demandPct, supplyPct, gapScore),
                        });
                    }).sort((a, b) => {
                        const gapDiff = this._toNumber(b.gap_score, -999) - this._toNumber(a.gap_score, -999);
                        if (gapDiff !== 0) return gapDiff;
                        return this._toNumber(b.confidence && b.confidence.score, 0)
                            - this._toNumber(a.confidence && a.confidence.score, 0);
                    });
                    const gapRows = this.h3OnlySignificant
                        ? gapRowsAll.filter(r => r.is_structure_signal)
                        : gapRowsAll;
                    const gapOpportunityCount = gapRows.filter(r => this._toNumber(r.gap_score, 0) > 0.25 && this._toNumber(r.demand_pct, 0) >= 0.6).length;
                    const gapMax = gapRows.length ? Math.max(...gapRows.map(r => this._toNumber(r.gap_score, 0))) : 0;
                    const topGap = gapRows.length ? gapRows[0] : null;
                    const gapInsightBase = topGap
                        ? `Top1 网格需求分位 ${Math.round(this._toNumber(topGap.demand_pct, 0) * 100)}，供给分位 ${Math.round(this._toNumber(topGap.supply_pct, 0) * 100)}，结论：${topGap.gap_zone_label}`
                        : '当前缺口结果为空，请调整范围或业态后重算';
                    const gapInsight = gapMappingWarning
                        ? `${gapMappingWarning}。${gapInsightBase}`
                        : gapInsightBase;

                    this.h3DerivedStats = {
                        structureSummary: {
                            rows: structureRows,
                            giZStats: giZStats,
                            lisaIStats: lisaIStats,
                            lisaPositivePct: lisaPositivePct,
                            lisaNegativePct: lisaNegativePct,
                            giRenderMeta: giRenderMeta,
                            lisaRenderMeta: lisaRenderMeta,
                            recommendation: structureRows.length > 0
                                ? '优先观察Gi*与LMiIndex连续梯度，再结合LQ/缺口结果做落位'
                                : '当前结构梯度较弱，可扩大范围或切换圈层复核',
                        },
                        typingSummary: {
                            counts: typingCountByType,
                            rows: typingRows,
                            densityP70: densityP70,
                            entropyP70: entropyP70,
                            opportunityCount: typingOpportunityCount,
                            maxDensity: typingMaxDensity,
                            recommendation: typingOpportunityCount > 0
                                ? '优先排查高密-高混合且邻域为正的网格'
                                : '当前高密高混合机会有限，可结合区位商优势与缺口优先区复核',
                        },
                        lqSummary: {
                            rows: lqRows,
                            dominantCounts: dominantCounts,
                            opportunityCount: lqOpportunityCount,
                            maxLq: lqMax,
                            recommendation: `${this._getH3CategoryLabel(this.h3TargetCategory)}区位商优势格可优先巩固`,
                        },
                        gapSummary: {
                            rows: gapRows,
                            opportunityCount: gapOpportunityCount,
                            maxGap: gapMax,
                            mappingWarning: gapMappingWarning,
                            recommendation: topGap
                                ? `${this._getH3CategoryLabel(this.h3TargetCategory)}优先关注${topGap.gap_zone_label}`
                                : `${this._getH3CategoryLabel(this.h3TargetCategory)}当前无明显缺口优先区`,
                            insight: gapInsight,
                        },
                        topCells: {
                            structure: structureRows.slice(0, topN),
                            typing: typingRows.slice(0, topN),
                            lq: lqRows.slice(0, topN),
                            gap: gapRows.slice(0, topN),
                        },
                    };
                },
                _renderTypingMap() {
                    const typing = this.h3DerivedStats && this.h3DerivedStats.typingSummary;
                    if (!typing || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const colorByType = {
                        high_density_high_mix: '#0f766e',
                        high_density_low_mix: '#b45309',
                        low_density_high_mix: '#2563eb',
                        low_density_low_mix: '#64748b',
                        no_data: '#d1d5db',
                    };
                    const rowMap = {};
                    (typing.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const typeKey = row.type_key || 'no_data';
                        props.fillColor = colorByType[typeKey] || '#d1d5db';
                        props.fillOpacity = typeKey === 'no_data' ? 0.10 : 0.24;
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.h3Legend = {
                        title: '功能混合度',
                        unit: '分类',
                        items: [
                            { color: colorByType.high_density_high_mix, label: '高密-高混合' },
                            { color: colorByType.high_density_low_mix, label: '高密-低混合' },
                            { color: colorByType.low_density_high_mix, label: '低密-高混合' },
                            { color: colorByType.low_density_low_mix, label: '低密-低混合' },
                        ],
                        noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                        noDataColor: '#d1d5db',
                    };
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2 });
                    this.tryRefocusSelectedGrid();
                },
                _interpolateHexColor(fromHex, toHex, t) {
                    const from = String(fromHex || '#000000').replace('#', '');
                    const to = String(toHex || '#000000').replace('#', '');
                    if (from.length !== 6 || to.length !== 6) return fromHex || '#000000';
                    const ratio = Math.max(0, Math.min(1, this._toNumber(t, 0)));
                    const fr = parseInt(from.slice(0, 2), 16);
                    const fg = parseInt(from.slice(2, 4), 16);
                    const fb = parseInt(from.slice(4, 6), 16);
                    const tr = parseInt(to.slice(0, 2), 16);
                    const tg = parseInt(to.slice(2, 4), 16);
                    const tb = parseInt(to.slice(4, 6), 16);
                    const rr = Math.round(fr + (tr - fr) * ratio);
                    const rg = Math.round(fg + (tg - fg) * ratio);
                    const rb = Math.round(fb + (tb - fb) * ratio);
                    return '#' + [rr, rg, rb].map((v) => {
                        const s = v.toString(16);
                        return s.length === 1 ? `0${s}` : s;
                    }).join('');
                },
                _resolveContinuousDivergingStyle(value, min, center, max, options = {}) {
                    if (!Number.isFinite(value)) return { fillColor: '#000000', fillOpacity: 0 };
                    const low = Number.isFinite(this._toNumber(min, NaN)) ? this._toNumber(min, -1) : -1;
                    const high = Number.isFinite(this._toNumber(max, NaN)) ? this._toNumber(max, 1) : 1;
                    if (!(high > low)) {
                        return {
                            fillColor: options.midColor || '#f8fafc',
                            fillOpacity: options.minOpacity || 0.08,
                        };
                    }
                    const mid = Number.isFinite(this._toNumber(center, NaN))
                        ? this._toNumber(center, 0)
                        : (low + high) / 2;
                    const clamp = (v) => Math.min(high, Math.max(low, v));
                    const vv = clamp(value);
                    const safeMid = Math.min(high, Math.max(low, mid));
                    const minOpacity = Number.isFinite(this._toNumber(options.minOpacity, NaN))
                        ? this._toNumber(options.minOpacity, 0.08)
                        : 0.08;
                    const maxOpacity = Number.isFinite(this._toNumber(options.maxOpacity, NaN))
                        ? this._toNumber(options.maxOpacity, 0.48)
                        : 0.48;
                    const threshold = Number.isFinite(this._toNumber(options.thresholdAbs, NaN))
                        ? Math.max(0, this._toNumber(options.thresholdAbs, 0))
                        : 0;
                    const lowColor = options.lowColor || '#1d4ed8';
                    const midColor = options.midColor || '#f8fafc';
                    const highColor = options.highColor || '#b91c1c';
                    let ratio = 0;
                    let color = midColor;
                    if (vv >= safeMid) {
                        const span = Math.max(1e-9, high - safeMid);
                        ratio = (vv - safeMid) / span;
                        color = this._interpolateHexColor(midColor, highColor, ratio);
                    } else {
                        const span = Math.max(1e-9, safeMid - low);
                        ratio = (safeMid - vv) / span;
                        color = this._interpolateHexColor(midColor, lowColor, ratio);
                    }
                    if (Math.abs(vv - safeMid) < threshold) {
                        return { fillColor: color, fillOpacity: minOpacity * 0.6 };
                    }
                    const fillOpacity = minOpacity + (maxOpacity - minOpacity) * Math.max(0, Math.min(1, ratio));
                    return { fillColor: color, fillOpacity };
                },
                _resolveGiZFillStyle(zValue, giMeta) {
                    const meta = giMeta || { min: -3, max: 3, center: 0 };
                    return this._resolveContinuousDivergingStyle(
                        zValue,
                        this._toNumber(meta.min, -3),
                        this._toNumber(meta.center, 0),
                        this._toNumber(meta.max, 3),
                        {
                            lowColor: '#1d4ed8',
                            midColor: '#f8fafc',
                            highColor: '#b91c1c',
                            minOpacity: 0.06,
                            maxOpacity: 0.42,
                            thresholdAbs: 0.2,
                        }
                    );
                },
                _resolveLisaIFillStyle(lisaValue, lisaMeta) {
                    const meta = lisaMeta || {};
                    if (meta.degraded) {
                        if (!Number.isFinite(lisaValue)) return { fillColor: '#000000', fillOpacity: 0 };
                        return { fillColor: '#cbd5e1', fillOpacity: 0.06 };
                    }
                    return this._resolveContinuousDivergingStyle(
                        lisaValue,
                        this._toNumber(meta.clip_min, this._toNumber(meta.mean, 0)),
                        this._toNumber(meta.mean, 0),
                        this._toNumber(meta.clip_max, this._toNumber(meta.mean, 0)),
                        {
                            lowColor: '#0f766e',
                            midColor: '#f8fafc',
                            highColor: '#f97316',
                            minOpacity: 0.06,
                            maxOpacity: 0.38,
                            thresholdAbs: 0,
                        }
                    );
                },
                _formatStructureValue(value) {
                    if (!Number.isFinite(this._toNumber(value, NaN))) return '-';
                    return this._toNumber(value, 0).toFixed(2);
                },
                _buildGiLegend(giMeta) {
                    const meta = giMeta || { min: -3, max: 3, center: 0 };
                    const min = this._toNumber(meta.min, -3);
                    const max = this._toNumber(meta.max, 3);
                    const marks = [min, -2, -1, 0, 1, 2, max];
                    const items = [];
                    for (let i = 0; i < marks.length - 1; i += 1) {
                        const left = marks[i];
                        const right = marks[i + 1];
                        const mid = (left + right) / 2;
                        const style = this._resolveGiZFillStyle(mid, meta);
                        items.push({
                            color: style.fillColor,
                            label: `${this._formatStructureValue(left)} ~ ${this._formatStructureValue(right)}`,
                        });
                    }
                    return {
                        title: '结构图（Gi*）',
                        unit: 'GiZScore',
                        items: items,
                        noDataLabel: '|z| 近0或缺失时透明',
                        noDataColor: '#d1d5db',
                    };
                },
                _buildLisaLegend(lisaMeta) {
                    const meta = lisaMeta || {};
                    if (meta.degraded) {
                        return {
                            title: '结构图（LISA）',
                            unit: 'LMiIndex',
                            items: [{ color: '#cbd5e1', label: '方差不足（弱结构）' }],
                            noDataLabel: '无效值透明',
                            noDataColor: '#d1d5db',
                        };
                    }
                    const mean = this._toNumber(meta.mean, 0);
                    const std = Math.max(0, this._toNumber(meta.std, 0));
                    const clipMin = this._toNumber(meta.clip_min, mean - 3 * std);
                    const clipMax = this._toNumber(meta.clip_max, mean + 3 * std);
                    const marks = [clipMin, mean - 2 * std, mean - std, mean, mean + std, mean + 2 * std, clipMax];
                    const items = [];
                    for (let i = 0; i < marks.length - 1; i += 1) {
                        const left = marks[i];
                        const right = marks[i + 1];
                        const mid = (left + right) / 2;
                        const style = this._resolveLisaIFillStyle(mid, meta);
                        items.push({
                            color: style.fillColor,
                            label: `${this._formatStructureValue(left)} ~ ${this._formatStructureValue(right)}`,
                        });
                    }
                    return {
                        title: '结构图（LISA）',
                        unit: 'LMiIndex（标准差）',
                        items: items,
                        noDataLabel: '无效值透明',
                        noDataColor: '#d1d5db',
                    };
                },
                _renderStructureMapStandalone() {
                    const summary = this.h3DerivedStats && this.h3DerivedStats.structureSummary;
                    if (!summary || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    const mode = this.h3StructureFillMode === 'lisa_i' ? 'lisa_i' : 'gi_z';
                    const rowMap = {};
                    (summary.rows || []).forEach((row) => { rowMap[row.h3_id] = row; });
                    const giMeta = summary.giRenderMeta || this._normalizeGiRenderMeta(this.h3AnalysisSummary && this.h3AnalysisSummary.gi_render_meta);
                    const lisaMeta = summary.lisaRenderMeta || this._normalizeLisaRenderMeta(
                        this.h3AnalysisSummary && this.h3AnalysisSummary.lisa_render_meta,
                        summary.lisaIStats
                    );
                    const styled = (this.h3AnalysisGridFeatures || []).map((feature) => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const giZValue = Number.isFinite(Number(row.gi_star_z_score))
                            ? Number(row.gi_star_z_score)
                            : (Number.isFinite(Number(props.gi_star_z_score)) ? Number(props.gi_star_z_score) : null);
                        const lisaIValue = Number.isFinite(Number(row.lisa_i))
                            ? Number(row.lisa_i)
                            : (Number.isFinite(Number(props.lisa_i)) ? Number(props.lisa_i) : null);
                        const fillStyle = mode === 'lisa_i'
                            ? this._resolveLisaIFillStyle(lisaIValue, lisaMeta)
                            : this._resolveGiZFillStyle(giZValue, giMeta);
                        props.gi_star_z_score = giZValue;
                        props.lisa_i = lisaIValue;
                        props.fillColor = fillStyle.fillColor;
                        props.fillOpacity = fillStyle.fillOpacity;
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.h3Legend = mode === 'lisa_i' ? this._buildLisaLegend(lisaMeta) : this._buildGiLegend(giMeta);
                    this.mapCore.setGridFeatures(styled, {
                        fillOpacity: 0.22,
                        strokeWeight: 1.2,
                        structureBoundaryEdges: false,
                    });
                    this.h3StructureRenderStats = null;
                    this.tryRefocusSelectedGrid();
                },
                _renderLqMap() {
                    const lq = this.h3DerivedStats && this.h3DerivedStats.lqSummary;
                    if (!lq || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const metricSpec = {
                        key: 'lq',
                        label: `${this._getH3CategoryLabel(this.h3TargetCategory)} 区位商优势（LQ）`,
                        unit: '相对值',
                        palette: ['#edf7ed', '#c4e3c4', '#8ccb8c', '#4ea95d', '#1b6e33'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: `无数据（样本<${this.h3EntropyMinPoi}）`,
                    };
                    const rowMap = {};
                    (lq.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const validValues = (lq.rows || []).map(r => r.lq_target).filter(v => Number.isFinite(v));
                    const breaks = this._buildQuantileBreaks(validValues, 5);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const value = row.lq_target;
                        if (!Number.isFinite(value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                        } else {
                            props.fillColor = this._colorByBreaks(value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2 });
                    this.tryRefocusSelectedGrid();
                },
                _renderGapMap() {
                    const gap = this.h3DerivedStats && this.h3DerivedStats.gapSummary;
                    if (!gap || !this.mapCore || !this.mapCore.setGridFeatures) return;
                    this.h3StructureRenderStats = null;
                    const metricSpec = {
                        key: 'gap',
                        label: `${this._getH3CategoryLabel(this.h3TargetCategory)} 缺口分`,
                        unit: '百分位差值',
                        palette: ['#2b6cb0', '#90cdf4', '#f7f7f7', '#f6ad55', '#c53030'],
                        noDataColor: '#d1d5db',
                        noDataOpacity: 0.10,
                        fillOpacity: 0.24,
                        noDataLabel: '',
                    };
                    const rowMap = {};
                    (gap.rows || []).forEach(row => { rowMap[row.h3_id] = row; });
                    const validValues = (gap.rows || []).map(r => r.gap_score).filter(v => Number.isFinite(v));
                    const breaks = this._buildDivergingBreaks(validValues);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);
                    const styled = (this.h3AnalysisGridFeatures || []).map(feature => {
                        const props = Object.assign({}, feature.properties || {});
                        const row = rowMap[props.h3_id] || {};
                        const value = row.gap_score;
                        if (!Number.isFinite(value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                        } else {
                            props.fillColor = this._colorByBreaks(value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;
                        return { type: feature.type, geometry: feature.geometry, properties: props };
                    });
                    this.mapCore.setGridFeatures(styled, { fillOpacity: 0.22, strokeWeight: 1.2 });
                    this.tryRefocusSelectedGrid();
                },
                renderH3BySubTab() {
                    if (!this.h3AnalysisGridFeatures || !this.h3AnalysisGridFeatures.length) {
                        this.h3Legend = null;
                        return;
                    }
                    if (this.h3SubTab === 'structure_map') {
                        this._renderStructureMapStandalone();
                    } else if (this.h3SubTab === 'typing') {
                        this._renderTypingMap();
                    } else if (this.h3SubTab === 'lq') {
                        this._renderLqMap();
                    } else if (this.h3SubTab === 'gap') {
                        this._renderGapMap();
                    } else {
                        this.renderH3AnalysisGrid(this.h3MetricView);
                    }
                },
                updateDecisionCards() {
                    if (!window.echarts || !this.h3DerivedStats) return;
                    const lqEl = document.getElementById('h3LqChart');
                    const gapEl = document.getElementById('h3GapChart');
                    const structureEl = document.getElementById('h3StructureChart');
                    if (!this.h3ChartsResizeHandler) {
                        this.h3ChartsResizeHandler = () => {
                            if (this.h3CategoryChart) this.h3CategoryChart.resize();
                            if (this.h3DensityChart) this.h3DensityChart.resize();
                            if (this.h3LqChart) this.h3LqChart.resize();
                            if (this.h3GapChart) this.h3GapChart.resize();
                            if (this.h3StructureChart) this.h3StructureChart.resize();
                        };
                        window.addEventListener('resize', this.h3ChartsResizeHandler);
                    }

                    if (structureEl && this.h3SubTab === 'structure_map') {
                        let chart = echarts.getInstanceByDom(structureEl);
                        if (!chart) chart = echarts.init(structureEl);
                        this.h3StructureChart = chart;
                        const summary = this.h3DerivedStats.structureSummary || {};
                        const giStats = summary.giZStats || {};
                        const lisaStats = summary.lisaIStats || {};
                        const labels = ['均值', '中位数', 'P90', 'P10', '最小', '最大'];
                        const giValues = [
                            this._toNumber(giStats.mean, 0),
                            this._toNumber(giStats.p50, 0),
                            this._toNumber(giStats.p90, 0),
                            this._toNumber(giStats.p10, 0),
                            this._toNumber(giStats.min, 0),
                            this._toNumber(giStats.max, 0),
                        ];
                        const lisaValues = [
                            this._toNumber(lisaStats.mean, 0),
                            this._toNumber(lisaStats.p50, 0),
                            this._toNumber(lisaStats.p90, 0),
                            this._toNumber(lisaStats.p10, 0),
                            this._toNumber(lisaStats.min, 0),
                            this._toNumber(lisaStats.max, 0),
                        ];
                        chart.setOption({
                            title: { text: '结构连续指标概览', left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 44, right: 14, top: 28, bottom: 24, containLabel: true },
                            legend: { top: 4, right: 8, itemWidth: 10, itemHeight: 8, textStyle: { fontSize: 11 } },
                            xAxis: { type: 'value', splitLine: { lineStyle: { color: '#eceff3' } } },
                            yAxis: {
                                type: 'category',
                                data: labels,
                                axisTick: { show: false },
                                axisLine: { show: false }
                            },
                            series: [
                                {
                                    name: 'Gi* Z',
                                    type: 'bar',
                                    data: giValues,
                                    barWidth: 10,
                                    itemStyle: { color: '#b91c1c' },
                                },
                                {
                                    name: 'LISA I',
                                    type: 'bar',
                                    data: lisaValues,
                                    barWidth: 10,
                                    itemStyle: { color: '#0f766e' },
                                }
                            ]
                        }, true);
                    }

                    if (lqEl && this.h3SubTab === 'lq') {
                        let chart = echarts.getInstanceByDom(lqEl);
                        if (!chart) chart = echarts.init(lqEl);
                        this.h3LqChart = chart;
                        const summary = this.h3DerivedStats.lqSummary || {};
                        const labels = (this.h3CategoryMeta || []).map(item => item.label);
                        const values = (this.h3CategoryMeta || []).map(item => this._toNumber((summary.dominantCounts || {})[item.key], 0));
                        chart.setOption({
                            title: { text: '主导优势类别分布', left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 44, right: 14, top: 28, bottom: 24, containLabel: true },
                            xAxis: { type: 'value', minInterval: 1, splitLine: { lineStyle: { color: '#eceff3' } } },
                            yAxis: { type: 'category', data: labels, axisTick: { show: false }, axisLine: { show: false } },
                            series: [{ type: 'bar', data: values, barWidth: 12, itemStyle: { color: '#4f8ad9' } }]
                        }, true);
                    }

                    if (gapEl && this.h3SubTab === 'gap') {
                        let chart = echarts.getInstanceByDom(gapEl);
                        if (!chart) chart = echarts.init(gapEl);
                        this.h3GapChart = chart;
                        const rows = ((this.h3DerivedStats.gapSummary || {}).rows || []);
                        const data = rows.map((row) => {
                            const demandPct = Math.max(0, Math.min(1, this._toNumber(row.demand_pct, 0)));
                            const supplyPct = Math.max(0, Math.min(1, this._toNumber(row.supply_pct, 0)));
                            const gapScore = this._toNumber(row.gap_score, 0);
                            const poiCount = Math.max(0, this._toNumber(row.poi_count, 0));
                            const symbolSize = Math.max(8, Math.min(26, 8 + Math.sqrt(poiCount) * 2));
                            return {
                                h3_id: row.h3_id,
                                gap_zone_label: row.gap_zone_label || '',
                                confidence_label: (row.confidence && row.confidence.label) || '低',
                                demand_pct: demandPct,
                                supply_pct: supplyPct,
                                gap_score: gapScore,
                                poi_count: poiCount,
                                symbolSize: symbolSize,
                                value: [Math.round(supplyPct * 100), Math.round(demandPct * 100), gapScore]
                            };
                        });
                        chart.setOption({
                            title: { text: '需求-供给散点（每点=网格）', left: 'center', top: 2, textStyle: { fontSize: 12 } },
                            grid: { left: 54, right: 14, top: 28, bottom: 34, containLabel: true },
                            tooltip: {
                                trigger: 'item',
                                formatter: (params) => {
                                    const d = params.data || {};
                                    const hid = d.h3_id || '-';
                                    return [
                                        `<b>${this.shortH3Id(hid)}</b>`,
                                        `需求分位: ${d.value ? d.value[1] : 0}`,
                                        `供给分位: ${d.value ? d.value[0] : 0}`,
                                        `缺口分: ${this._toNumber(d.gap_score, 0).toFixed(2)}`,
                                        `可信度: ${d.confidence_label || '-'}`,
                                        `结论: ${d.gap_zone_label || '-'}`,
                                    ].join('<br/>');
                                }
                            },
                            xAxis: {
                                type: 'value',
                                name: '供给百分位',
                                min: 0,
                                max: 100,
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: '需求百分位',
                                min: 0,
                                max: 100,
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            series: [{
                                type: 'scatter',
                                data: data,
                                symbolSize: (item) => item.symbolSize || 10,
                                itemStyle: {
                                    color: (params) => {
                                        const gap = this._toNumber(params && params.data && params.data.gap_score, 0);
                                        if (gap >= 0.25) return '#d8573f';
                                        if (gap <= -0.25) return '#3f7fd8';
                                        return '#93a5bf';
                                    },
                                    opacity: 0.85
                                },
                                emphasis: {
                                    itemStyle: {
                                        borderColor: '#111827',
                                        borderWidth: 1
                                    }
                                },
                                markLine: {
                                    silent: true,
                                    symbol: ['none', 'none'],
                                    lineStyle: { type: 'dashed', color: '#cbd5e1' },
                                    data: [{ xAxis: 50 }, { yAxis: 50 }]
                                }
                            }]
                        }, true);
                        chart.off('click');
                        chart.on('click', (params) => {
                            const h3Id = params && params.data && params.data.h3_id;
                            if (h3Id) this.focusGridByH3Id(h3Id);
                        });
                    }
                },
                renderH3AnalysisGrid(metricKey) {
                    const source = this.h3AnalysisGridFeatures;
                    if (!Array.isArray(source) || source.length === 0 || !this.mapCore || !this.mapCore.setGridFeatures) {
                        this.h3Legend = null;
                        return;
                    }
                    this.h3StructureRenderStats = null;

                    const metricSpec = this._getMetricSpec(metricKey);
                    const measured = source.map((feature) => {
                        const datum = this._getH3MetricValue((feature && feature.properties) || {}, metricKey);
                        return {
                            feature: feature,
                            value: datum.value,
                            noData: datum.noData
                        };
                    });
                    const validValues = measured
                        .filter(item => !item.noData && Number.isFinite(item.value))
                        .map(item => item.value);
                    const breaks = metricSpec.diverging
                        ? this._buildDivergingBreaks(validValues)
                        : this._buildQuantileBreaks(validValues, 5);
                    this.h3Legend = this._buildLegend(metricSpec, breaks, validValues);

                    const styled = measured.map((item) => {
                        const feature = item.feature;
                        const props = Object.assign({}, feature.properties || {});
                        if (item.noData || !Number.isFinite(item.value)) {
                            props.fillColor = metricSpec.noDataColor;
                            props.fillOpacity = metricSpec.noDataOpacity;
                            props.metric_value = null;
                            props.metric_no_data = true;
                        } else {
                            props.fillColor = this._colorByBreaks(item.value, breaks, metricSpec.palette);
                            props.fillOpacity = metricSpec.fillOpacity;
                            props.metric_value = item.value;
                            props.metric_no_data = false;
                        }
                        props.strokeColor = '#2c6ecb';
                        props.strokeWeight = 1;

                        return {
                            type: feature.type,
                            geometry: feature.geometry,
                            properties: props
                        };
                    });

                    this.mapCore.setGridFeatures(styled, {
                        fillOpacity: 0.22,
                        strokeWeight: 1.2,
                        structureBoundaryEdges: false,
                        structureBoundaryGi: false,
                        structureBoundaryLisa: false,
                    });
                    this.tryRefocusSelectedGrid();
                },
                getH3CurrentStageTabs() {
                    const fallback = ['metric_map'];
                    const stageTabs = this.h3MainStageTabs || {};
                    const tabs = stageTabs[this.h3MainStage] || fallback;
                    return Array.isArray(tabs) && tabs.length ? tabs : fallback;
                },
                getH3DefaultSubTabByStage(stage) {
                    const stageTabs = this.h3MainStageTabs || {};
                    const tabs = stageTabs[stage];
                    if (Array.isArray(tabs) && tabs.length) return tabs[0];
                    return 'metric_map';
                },
                resolveH3MainStageBySubTab(tab) {
                    const stageTabs = this.h3MainStageTabs || {};
                    const stageOrder = ['analysis', 'diagnosis', 'evaluate'];
                    for (const stage of stageOrder) {
                        const tabs = stageTabs[stage];
                        if (Array.isArray(tabs) && tabs.includes(tab)) return stage;
                    }
                    return 'analysis';
                },
                async onH3MainStageChange(stage) {
                    if (stage !== 'params' && stage !== 'analysis' && stage !== 'diagnosis' && stage !== 'evaluate') return;
                    this.h3MainStage = stage;
                    if (stage === 'params') return;
                    const targetTab = this.getH3DefaultSubTabByStage(stage);
                    await this.onH3SubTabChange(targetTab);
                },
                onH3MetricViewChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'metric_map') return;
                    this.refreshMetricMapView();
                },
                onH3StructureFillModeChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'structure_map') return;
                    this._renderStructureMapStandalone();
                },
                async refreshMetricMapView() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    if (this.h3SubTab !== 'metric_map') return;
                    this.renderH3AnalysisGrid(this.h3MetricView);
                    await this.$nextTick();
                    this.updateH3Charts();
                },
                async onH3SubTabChange(tab) {
                    this.h3SubTab = tab;
                    this.h3MainStage = this.resolveH3MainStageBySubTab(tab);
                    if (!this.h3AnalysisGridFeatures.length) return;
                    this.computeH3DerivedStats();
                    await this.$nextTick();
                    this.renderH3BySubTab();
                    await this.$nextTick();
                    this.updateH3Charts();
                    this.updateDecisionCards();
                },
                async onH3DecisionSettingsChange() {
                    if (!this.h3AnalysisGridFeatures.length) return;
                    this.computeH3DerivedStats();
                    await this.$nextTick();
                    this.renderH3BySubTab();
                    await this.$nextTick();
                    this.updateH3Charts();
                    this.updateDecisionCards();
                },
                async computeH3Analysis() {
                    const rawRing = this.getIsochronePolygonRing();
                    if (!rawRing || this.isComputingH3Analysis) return;
                    const progressTotal = 5;
                    const startedAt = Date.now();
                    const engineName = this.h3UseArcgis ? 'ArcGIS' : 'PySAL';
                    let progressStep = 0;
                    let progressLabel = '准备中';
                    let progressTimer = null;
                    const setProgress = (step, label) => {
                        progressStep = step;
                        progressLabel = label;
                        const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
                        this.h3GridStatus = `网格分析进度 ${progressStep}/${progressTotal}：${progressLabel}（${sec}s）`;
                    };
                    this.isComputingH3Analysis = true;
                    setProgress(1, '准备分析参数');
                    progressTimer = window.setInterval(() => {
                        if (!this.isComputingH3Analysis) return;
                        const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
                        this.h3GridStatus = `网格分析进度 ${progressStep}/${progressTotal}：${progressLabel}（${sec}s）`;
                    }, 1000);
                    try {
                        const polygon = rawRing.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        }).filter(pt => Array.isArray(pt) && pt.length >= 2);
                        const neighborRing = Math.max(1, Math.min(3, Math.round(this._toNumber(this.h3NeighborRing, 1))));
                        this.h3NeighborRing = neighborRing;

                        const payload = {
                            polygon: polygon,
                            resolution: this.h3GridResolution,
                            coord_type: 'gcj02',
                            include_mode: this.h3GridIncludeMode,
                            min_overlap_ratio: this.h3GridIncludeMode === 'intersects' ? this.h3GridMinOverlapRatio : 0,
                            pois: this.allPoisDetails || [],
                            poi_coord_type: 'gcj02',
                            neighbor_ring: neighborRing,
                            use_arcgis: this.h3UseArcgis === true,
                            arcgis_python_path: this.h3UseArcgis ? this.h3ArcgisPythonPath : null,
                            arcgis_neighbor_ring: neighborRing,
                            arcgis_export_image: true,
                            arcgis_timeout_sec: 240
                        };

                        setProgress(2, `请求已发送，后端计算中（${engineName}）`);
                        const res = await fetch('/api/v1/analysis/h3-metrics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        if (!res.ok) {
                            let detail = '';
                            try {
                                const errJson = await res.json();
                                if (errJson && typeof errJson === 'object') {
                                    detail = errJson.detail || JSON.stringify(errJson);
                                } else {
                                    detail = String(errJson || '');
                                }
                            } catch (_) {
                                try { detail = await res.text(); } catch (_) { }
                            }
                            throw new Error(detail || '网格分析失败');
                        }

                        setProgress(3, '结果已返回，正在解析数据');
                        const data = await res.json();
                        const grid = data.grid || {};
                        this.h3AnalysisGridFeatures = grid.features || [];
                        this.h3GridFeatures = this.h3AnalysisGridFeatures;
                        this.h3GridCount = Number.isFinite(grid.count) ? grid.count : this.h3AnalysisGridFeatures.length;
                        this.h3AnalysisSummary = data.summary || null;
                        this.h3AnalysisCharts = data.charts || null;
                        this.h3ArcgisImageVersion = Date.now();
                        setProgress(4, '正在计算衍生指标');
                        this.computeH3DerivedStats();
                        setProgress(5, '正在渲染图层与图表');
                        this.renderH3BySubTab();
                        await this.$nextTick();
                        this.updateH3Charts();
                        this.updateDecisionCards();
                        this.h3GridStatus = this.h3GridCount > 0
                            ? `分析完成：${this.h3GridCount} 个网格，${(this.h3AnalysisSummary && this.h3AnalysisSummary.poi_count) || 0} 个POI`
                            : '分析完成，但当前范围无可用网格';
                    } catch (e) {
                        console.error(e);
                        this.h3GridStatus = '网格分析失败: ' + e.message;
                    } finally {
                        if (progressTimer) {
                            window.clearInterval(progressTimer);
                            progressTimer = null;
                        }
                        this.isComputingH3Analysis = false;
                    }
                },
                selectStep3Panel(panelId) {
                    if (this.isDraggingNav) return;
                    if (panelId === 'h3_settings') {
                        panelId = 'h3';
                    }
                    this.activeStep3Panel = panelId;
                    if (panelId === 'poi') {
                        setTimeout(() => this.resizePoiChart(), 0);
                        return;
                    }
                    if (panelId === 'h3') {
                        this.h3MainStage = 'params';
                        this.ensureH3GridOnEnter();
                    }
                },
                onStep3DragStart(index, event) {
                    this.dragIndex = index;
                    this.dragOverIndex = index;
                    this.dragInsertPosition = 'before';
                    this.isDraggingNav = true;
                    if (event && event.dataTransfer) {
                        event.dataTransfer.effectAllowed = 'move';
                    }
                },
                onStep3DragOver(index, event) {
                    if (event) event.preventDefault();
                    this.dragOverIndex = index;
                    const bounds = event.currentTarget.getBoundingClientRect();
                    const midY = bounds.top + bounds.height / 2;
                    this.dragInsertPosition = event.clientY < midY ? 'before' : 'after';
                },
                onStep3Drop(index) {
                    if (this.dragIndex === null) {
                        this.dragOverIndex = null;
                        this.dragInsertPosition = null;
                        return;
                    }
                    const items = this.step3NavItems.slice();
                    const moved = items.splice(this.dragIndex, 1)[0];
                    let insertIndex = index;
                    if (this.dragInsertPosition === 'after') {
                        insertIndex = index + 1;
                    }
                    if (this.dragIndex < insertIndex) {
                        insertIndex -= 1;
                    }
                    items.splice(insertIndex, 0, moved);
                    this.step3NavItems = items;
                    this.dragIndex = null;
                    this.dragOverIndex = null;
                    this.dragInsertPosition = null;
                    this.isDraggingNav = false;
                },
                onStep3DragEnd() {
                    this.dragIndex = null;
                    this.dragOverIndex = null;
                    this.dragInsertPosition = null;
                    this.isDraggingNav = false;
                },
                goToStep(targetStep) {
                    this.confirmNavigation(() => {
                        if (targetStep < this.step) {
                            // Backwards navigation cleanup
                            if (this.step === 3 && targetStep <= 2) {
                                // Clear POI markers & data
                                if (this.markerManager) {
                                    if (this.markerManager.markers) {
                                        this.markerManager.markers.forEach(m => m.setMap(null));
                                    }
                                    if (this.markerManager.destroyClusterers) {
                                        this.markerManager.destroyClusterers();
                                    }
                                    this.markerManager = null;
                                }
                                if (this.poiMarkers) {
                                    this.poiMarkers.forEach(m => m.setMap(null));
                                    this.poiMarkers = [];
                                }
                                // Clear Legacy Filter Panel
                                const filterContainer = document.getElementById('filtersContainer');
                                if (filterContainer) filterContainer.innerHTML = '';

                                this.poiStatus = '';
                                this.clearH3Grid();
                            }

                            if (this.step >= 2 && targetStep <= 1) {
                                // Clear Isochrone Polygon
                                if (this.mapCore && this.mapCore.clearCustomPolygons) {
                                    this.mapCore.clearCustomPolygons();
                                }
                                this.lastIsochroneGeoJSON = null;
                                this.clearH3Grid();
                            }
                        }
                        this.step = targetStep;
                    });
                },
                confirmNavigation(callback) {
                    if (this.isFetchingPois) {
                        if (confirm('数据抓取正在进行中，离开将取消未完成的任务。确定要离开吗？')) {
                            this.cancelFetch();
                            callback();
                        }
                    } else {
                        callback();
                    }
                },
                cancelFetch() {
                    if (this.abortController) {
                        this.abortController.abort();
                        this.abortController = null;
                    }
                    this.isFetchingPois = false;
                    this.poiStatus = "任务已取消";
                    this.resetFetchSubtypeProgress();
                },
                backToHome() {
                    this.confirmNavigation(() => {
                        this.clearAnalysisLayers();
                        this.sidebarView = 'start';
                        this.step = 1;
                        this.selectedPoint = null;
                        if (this.marker) {
                            this.marker.setMap(null);
                            this.marker = null;
                        }
                        this.errorMessage = '';
                    });
                },
                loadAMapScript(key, securityCode) {
                    return new Promise((resolve, reject) => {
                        if (window.AMap && window.AMap.Map) {
                            resolve();
                            return;
                        }
                        window._AMapSecurityConfig = { securityJsCode: securityCode };
                        const script = document.createElement('script');
                        script.src = `https://webapi.amap.com/maps?v=1.4.15&key=${key}&plugin=AMap.Autocomplete,AMap.PlaceSearch`;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                },
                async probeTiandituTile(timeoutMs = 4500) {
                    const key = (this.config && this.config.tianditu_key ? String(this.config.tianditu_key) : '').trim();
                    if (!key) {
                        return {
                            ok: false,
                            phase: 'wmts-probe',
                            status: null,
                            contentType: '',
                            bodySnippet: '',
                            reason: 'missing-key',
                            url: '',
                        };
                    }
                    const probeUrl = `https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX=7&TILEROW=53&TILECOL=107&tk=${encodeURIComponent(key)}&_ts=${Date.now()}`;
                    const controller = new AbortController();
                    const timer = window.setTimeout(() => controller.abort(), timeoutMs);
                    try {
                        const response = await fetch(probeUrl, {
                            method: 'GET',
                            cache: 'no-store',
                            signal: controller.signal,
                        });
                        const contentType = String(response.headers.get('content-type') || '').toLowerCase();
                        const isImage = this.isImageContentType(contentType);
                        let bodySnippet = '';
                        if (!isImage) {
                            try {
                                bodySnippet = this._trimText(await response.text(), 300);
                            } catch (_) {
                                bodySnippet = '';
                            }
                        }
                        const status = response.status;
                        const ok = response.ok && isImage;
                        let reason = 'ok';
                        if (!ok) {
                            if (status === 418) reason = 'http-418';
                            else if (status >= 500) reason = 'http-5xx';
                            else if (status >= 400) reason = 'http-4xx';
                            else if (response.ok) reason = 'non-image-response';
                            else reason = 'http-error';
                        }
                        return {
                            ok: ok,
                            phase: 'wmts-probe',
                            status: status,
                            contentType: contentType,
                            bodySnippet: bodySnippet,
                            reason: reason,
                            url: probeUrl,
                        };
                    } catch (e) {
                        if (e && e.name === 'AbortError') {
                            return {
                                ok: false,
                                phase: 'wmts-probe',
                                status: null,
                                contentType: '',
                                bodySnippet: '',
                                reason: 'timeout',
                                url: probeUrl,
                            };
                        }
                        return {
                            ok: false,
                            phase: 'wmts-probe',
                            status: null,
                            contentType: '',
                            bodySnippet: this._trimText(e && e.message ? e.message : String(e), 300),
                            reason: 'network-error',
                            url: probeUrl,
                        };
                    } finally {
                        window.clearTimeout(timer);
                    }
                },
                async validateTiandituSource() {
                    const result = await this.probeTiandituTile();
                    this.tdtDiag = result;
                    this.tdtDiagCopyStatus = '';
                    if (result.ok) {
                        if (this.errorMessage && this.errorMessage.indexOf('天地图') >= 0) {
                            this.errorMessage = '';
                        }
                        return true;
                    }
                    if (result.reason === 'missing-key') {
                        this.errorMessage = '未配置天地图 Key（TIANDITU_KEY）。';
                    } else if (result.reason === 'timeout') {
                        this.errorMessage = '天地图 WMTS 探测超时，请稍后重试（配置修改可能需要 5-10 分钟生效）。';
                    } else if (result.reason === 'http-418') {
                        this.errorMessage = '天地图 WMTS 探测被拦截（HTTP 418），请检查 Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                    } else {
                        this.errorMessage = `天地图 WMTS 探测失败（${result.status || 'NO_STATUS'}），请检查 Key 与白名单。`;
                    }
                    return false;
                },
                isImageContentType(contentType) {
                    const ct = String(contentType || '').toLowerCase();
                    return ct.indexOf('image/') >= 0 || ct.indexOf('application/octet-stream') >= 0;
                },
                _trimText(value, maxLen = 300) {
                    const text = String(value || '');
                    if (text.length <= maxLen) return text;
                    return text.slice(0, maxLen) + '...';
                },
                buildTdtDiagText() {
                    if (!this.tdtDiag) return '';
                    const rows = [
                        `ok=${this.tdtDiag.ok}`,
                        `phase=${this.tdtDiag.phase || '-'}`,
                        `reason=${this.tdtDiag.reason || '-'}`,
                        `status=${this.tdtDiag.status === null || this.tdtDiag.status === undefined ? '-' : this.tdtDiag.status}`,
                        `contentType=${this.tdtDiag.contentType || '-'}`,
                    ];
                    if (this.tdtDiag.url) rows.push(`url=${this.tdtDiag.url}`);
                    if (this.tdtDiag.bodySnippet) rows.push(`body=${this.tdtDiag.bodySnippet}`);
                    return rows.join('\n');
                },
                async copyTdtDiag() {
                    const text = this.buildTdtDiagText();
                    if (!text) {
                        this.tdtDiagCopyStatus = '无可复制内容';
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(text);
                        this.tdtDiagCopyStatus = '已复制';
                    } catch (e) {
                        console.error(e);
                        this.tdtDiagCopyStatus = '复制失败，请手动复制';
                    }
                },
                initMap() {
                    const mapCore = new MapCore('container', {
                        center: { lng: 112.9388, lat: 28.2282 },
                        zoom: 13,
                        zooms: [3, 20],
                        mapData: {},
                        basemapSource: this.basemapSource,
                        basemapMuted: !!this.h3BasemapMuted,
                        tiandituKey: this.config ? this.config.tianditu_key : '',
                        tiandituContainerId: 'tianditu-container',
                        onGridFeatureClick: (payload) => this.onH3GridFeatureClick(payload)
                    });
                    mapCore.initMap();
                    this.mapCore = mapCore;
                    this.applySimplifyPointVisibility();
                    if (this.basemapSource === 'tianditu' && mapCore.lastBasemapError) {
                        this.tdtDiag = {
                            ok: false,
                            phase: 'map-init',
                            status: null,
                            contentType: '',
                            bodySnippet: mapCore.lastBasemapError.message || '',
                            reason: mapCore.lastBasemapError.code || 'wmts-layer-init-failed',
                        };
                        this.errorMessage = '天地图 WMTS 图层初始化失败，请检查：Key 类型=Web JS，白名单包含 localhost/127.0.0.1（及端口）。';
                    }

                    mapCore.map.on('click', (e) => {
                        // Limit marker adjustment to Step 1 in Wizard mode
                        if (this.sidebarView !== 'wizard' || this.step !== 1) return;
                        this.setSelectedPoint(e.lnglat);
                    });

                    this.initSearch(mapCore.map);
                },
                initSearch(map) {
                    const autoOptions = {
                        input: "keyword",
                    };
                    const autocomplete = new AMap.Autocomplete(autoOptions);
                    const placeSearch = new AMap.PlaceSearch({
                        map: map,
                        pageSize: 10,
                        autoFitView: true
                    });
                    this.placeSearch = placeSearch; // Save instance

                    // 监听搜索结果标记点击事件
                    AMap.event.addListener(placeSearch, "markerClick", (e) => {
                        if (e.data && e.data.location) {
                            // 选中点击的这个点
                            this.setSelectedPoint(e.data.location);
                            // 清除地图上其他搜索结果
                            placeSearch.clear();
                        }
                    });
                    AMap.event.addListener(placeSearch, "error", (e) => {
                        console.error("PlaceSearch error", e);
                        // Keep this as diagnostic log only; final user-facing message is decided in triggerSearch.
                    });

                    AMap.event.addListener(autocomplete, "select", (e) => {
                        if (e.poi && e.poi.location) {
                            map.setZoomAndCenter(15, e.poi.location);
                            this.setSelectedPoint(e.poi.location);
                        }
                    });
                },
                extractSearchPois(result) {
                    const list = result && result.poiList && Array.isArray(result.poiList.pois)
                        ? result.poiList.pois
                        : [];
                    return list.filter((poi) => poi && poi.location);
                },
                runPlaceSearch(keyword) {
                    return new Promise((resolve) => {
                        if (!this.placeSearch || typeof this.placeSearch.search !== 'function') {
                            resolve({ ok: false, pois: [], status: 'error', raw: null, serviceError: true, errorInfo: '' });
                            return;
                        }

                        try {
                            this.placeSearch.search(keyword, (status, result) => {
                                const pois = this.extractSearchPois(result);
                                const errorInfo = String((result && result.info) || '');
                                resolve({
                                    ok: status === 'complete',
                                    pois: pois,
                                    status: status || '',
                                    raw: result || null,
                                    serviceError: status === 'error',
                                    errorInfo: errorInfo
                                });
                            });
                        } catch (e) {
                            console.error('placeSearch.search error', e);
                            resolve({ ok: false, pois: [], status: 'error', raw: null, serviceError: true, errorInfo: '' });
                        }
                    });
                },
                resolveCurrentSearchCity() {
                    return new Promise((resolve) => {
                        const map = this.mapCore && this.mapCore.map;
                        if (!map || typeof map.getCity !== 'function') {
                            resolve({ city: '', citycode: '' });
                            return;
                        }

                        let settled = false;
                        const done = (value) => {
                            if (settled) return;
                            settled = true;
                            const payload = value && typeof value === 'object' ? value : {};
                            resolve({
                                city: String(payload.city || payload.province || '').trim(),
                                citycode: String(payload.citycode || '').trim()
                            });
                        };

                        const timer = setTimeout(() => done({}), 1200);
                        try {
                            map.getCity((info) => {
                                clearTimeout(timer);
                                if (!info || info.info === 'FAILED') {
                                    done({});
                                    return;
                                }
                                done(info);
                            });
                        } catch (e) {
                            clearTimeout(timer);
                            console.warn('map.getCity failed', e);
                            done({});
                        }
                    });
                },
                setSelectedPoint(lnglat) {
                    if (!lnglat) return;
                    const lng = (typeof lnglat.lng === 'number')
                        ? lnglat.lng
                        : (typeof lnglat.getLng === 'function' ? lnglat.getLng() : NaN);
                    const lat = (typeof lnglat.lat === 'number')
                        ? lnglat.lat
                        : (typeof lnglat.getLat === 'function' ? lnglat.getLat() : NaN);
                    if (!Number.isFinite(lng) || !Number.isFinite(lat)) return;

                    this.selectedPoint = { lng, lat };
                    if (this.mapCore) {
                        this.mapCore.center = { lng, lat };
                    }
                    this.errorMessage = '';
                    const markerPos = (window.AMap && typeof AMap.LngLat === 'function')
                        ? new AMap.LngLat(lng, lat)
                        : [lng, lat];
                    if (this.marker) {
                        this.marker.setPosition(markerPos);
                        return;
                    }
                    if (!this.mapCore || !this.mapCore.map) return;
                    this.marker = new AMap.Marker({ position: markerPos });
                    this.mapCore.map.add(this.marker);
                },
                async startAnalysis() {
                    if (!this.selectedPoint || this.isCalculating) return;
                    this.isCalculating = true;
                    this.errorMessage = '';

                    try {
                        const payload = {
                            lat: this.selectedPoint.lat,
                            lon: this.selectedPoint.lng,
                            time_min: parseInt(this.timeHorizon),
                            mode: this.transportMode,
                            coord_type: 'gcj02'
                        };

                        const res = await fetch('/api/v1/analysis/isochrone', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!res.ok) throw new Error("API 请求失败");
                        const geojson = await res.json();

                        this.clearH3Grid();
                        this.lastIsochroneGeoJSON = geojson;
                        this.renderResult(geojson);
                        this.step = 2; // Advance to Step 2

                    } catch (e) {
                        console.error(e);
                        this.errorMessage = "计算失败: " + e.message;
                    } finally {
                        this.isCalculating = false;
                    }
                },
                async fetchPois() {
                    if (!this.lastIsochroneGeoJSON) return;
                    this.isFetchingPois = true;
                    this.fetchProgress = 0;
                    this.poiStatus = "准备抓取...";
                    this.resetFetchSubtypeProgress();

                    if (this.poiMarkers) this.poiMarkers.forEach(m => m.setMap(null));
                    this.poiMarkers = [];
                    this.allPoisDetails = [];

                    try {
                        const geometry = this.lastIsochroneGeoJSON.geometry;
                        let rawPoly = (geometry.type === 'Polygon') ? geometry.coordinates[0] : geometry.coordinates[0][0];
                        const polygon = rawPoly.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        });

                        // Get selected categories (derived from selected subtypes).
                        const selectedCats = this.buildSelectedCategoryBuckets();
                        if (selectedCats.length === 0) {
                            alert("请至少选择一个分类");
                            this.isFetchingPois = false;
                            return;
                        }

                        let totalFetched = 0;
                        const totalCats = selectedCats.length;
                        if (selectedCats[0]) {
                            this.updateFetchSubtypeProgressDisplay(selectedCats[0]);
                        }

                        // Parallel Fetching: process in batches.
                        this.abortController = new AbortController();
                        const batchSize = 4;
                        this.poiStatus = `正在并行抓取 ${totalCats} 个分类（每批 ${batchSize} 个）...`;

                        const fetchOneCategory = async (cat) => {
                            const payload = {
                                polygon: polygon,
                                keywords: "",
                                types: String(cat.types || ''),
                                save_history: false, // Don't save individual batches
                                center: [this.selectedPoint.lng, this.selectedPoint.lat],
                                time_min: parseInt(this.timeHorizon),
                                mode: this.transportMode,
                                location_name: this.selectedPoint.name || (this.selectedPoint.lng.toFixed(4) + ',' + this.selectedPoint.lat.toFixed(4))
                            };

                            try {
                                const res = await fetch('/api/v1/analysis/pois', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(payload),
                                    signal: this.abortController.signal
                                });

                                if (res.ok) {
                                    const data = await res.json();
                                    return data.pois || [];
                                }
                            } catch (err) {
                                if (err.name !== 'AbortError') {
                                    console.warn(`Failed to fetch category ${cat.name}`, err);
                                }
                            }
                            return [];
                        };

                        for (let i = 0; i < selectedCats.length; i += batchSize) {
                            if (this.abortController.signal.aborted) return;
                            const batch = selectedCats.slice(i, i + batchSize);
                            const resultsArray = await Promise.all(batch.map(fetchOneCategory));
                            resultsArray.forEach((list, index) => {
                                if (list && list.length) this.allPoisDetails.push(...list);
                                const cat = batch[index];
                                if (cat) {
                                    this.accumulateFetchSubtypeHits(cat, list || []);
                                }
                            });

                            totalFetched = this.allPoisDetails.length;
                            const done = Math.min(i + batch.length, totalCats);
                            this.fetchProgress = Math.round((done / totalCats) * 100);
                            this.poiStatus = `已完成 ${done}/${totalCats} 分类，累计 ${totalFetched} 个结果`;
                        }

                        if (this.abortController.signal.aborted) return;

                        this.fetchProgress = 100;
                        this.poiStatus = `完成！共找到 ${totalFetched} 个结果`;

                        // Integration with Legacy Filter Panel (single render path).
                        if (this.updateLegacySystem) {
                            this.updateLegacySystem(this.allPoisDetails);
                        } else {
                            this.renderPois(this.allPoisDetails);
                        }

                        setTimeout(() => {
                            this.step = 3; // Advance to Step 3 after short delay to see 100%
                            this.updatePoiCharts();
                            this.resizePoiChart();
                        }, 120);
                        this.saveAnalysisHistoryAsync(polygon, selectedCats, this.allPoisDetails);

                    } catch (e) {
                        if (e.name !== 'AbortError') {
                            console.error(e);
                            this.poiStatus = "失败: " + e.message;
                        }
                    } finally {
                        this.isFetchingPois = false;
                        this.abortController = null;
                        this.resetFetchSubtypeProgress();
                    }
                },
                // Updated Render Logic
                renderPois(pois) {
                    if (this.poiMarkers) this.poiMarkers.forEach(m => m.setMap(null));
                    this.poiMarkers = [];

                    // Filter client-side based on current checkboxes (in case user toggles after fetch)
                    // Note: For now, we render what we fetched.
                    // Future enhancement: dynamic toggle without re-fetch.

                    const markers = pois.map(p => {
                        // Find category color
                        let color = '#999';
                        const cat = this.resolvePoiCategory(p && p.type);
                        if (cat) color = cat.color;

                        // Create CircleMarker
                        const marker = new AMap.CircleMarker({
                            center: p.location,
                            radius: 4, // px
                            strokeColor: 'white',
                            strokeWeight: 1,
                            fillColor: color,
                            fillOpacity: 0.9,
                            zIndex: 100,
                            bubble: true,
                            cursor: 'pointer',
                        });

                        // Info Window
                        marker.on('click', () => {
                            const typeText = (p.type || '').toString();
                            const nameText = p.name || '';
                            const isTraffic = typeText.startsWith('15') || typeText.startsWith('type-15');
                            const isParking = typeText.includes('1509') || /停车/.test(nameText);
                            const addressText = p.address || '';
                            let lines = Array.isArray(p.lines) ? p.lines.slice() : [];
                            if (isTraffic && !isParking && addressText) {
                                if (lines.length === 0) {
                                    lines = [addressText];
                                } else if (!lines.includes(addressText)) {
                                    lines.push(addressText);
                                }
                            }
                            const showAddress = !isTraffic || isParking;
                            const showLines = isTraffic && !isParking;
                            const info = [];
                            info.push(`<div style="padding:5px;"><b>${p.name}</b>`);
                            info.push(`<div style="font-size:12px;color:#666;">${p.type || '未知类型'}</div>`);
                            if (showAddress && addressText) {
                                info.push(`<div style="font-size:12px;color:#666;"><span style="color:#666;">地址：</span>${addressText}</div>`);
                            }
                            if (showLines && lines.length) {
                                info.push(`<div style="font-size:12px;color:#666;"><span style="color:#666;">途经线路：</span>${lines.join('，')}</div>`);
                            }
                            info.push(`</div>`);

                            new AMap.InfoWindow({
                                content: info.join(""),
                                offset: new AMap.Pixel(0, -5)
                            }).open(this.mapCore.map, p.location);
                        });

                        marker.setMap(this.mapCore.map);
                        return marker;
                    });
                    this.poiMarkers = markers;
                },
                // Toggle visibility client-side
                toggleCategory() {
                    if (this.allPoisDetails.length > 0) {
                        // Filter logic
                        const activeIds = new Set(this.poiCategories.filter(c => c.checked).map(c => c.id));
                        const filtered = this.allPoisDetails.filter(p => {
                            const cid = this.resolvePoiCategoryId(p && p.type);
                            return !!cid && activeIds.has(cid);
                        });
                        this.renderPois(filtered);
                    }
                },
                renderResult(geojson) {
                    if (!geojson || !geojson.geometry) {
                        this.errorMessage = "未获取到有效数据";
                        return;
                    }
                    const coords = geojson.geometry.coordinates;
                    const type = geojson.geometry.type;
                    let paths = [];
                    if (type === 'Polygon') {
                        paths.push(coords[0]);
                    } else if (type === 'MultiPolygon') {
                        coords.forEach(poly => paths.push(poly[0]));
                    }
                    this.mapCore.setCustomPolygons(paths);
                },
                async loadHistoryList(options = {}) {
                    const force = !!(options && options.force);
                    const keepExisting = options && Object.prototype.hasOwnProperty.call(options, 'keepExisting')
                        ? !!options.keepExisting
                        : (this.historyHasLoadedOnce && this.historyList.length > 0);
                    if (!force && this.historyHasLoadedOnce) {
                        return;
                    }
                    this.cancelHistoryLoading();
                    const sessionId = this.historyRenderSessionId;
                    this.historyLoading = true;
                    if (!keepExisting) {
                        this.historyListRaw = [];
                        this.historyList = [];
                        this.historyLoadedCount = 0;
                    }
                    this.historyFetchAbortController = new AbortController();

                    try {
                        console.log("Loading history list...");
                        const res = await fetch('/api/v1/analysis/history', {
                            signal: this.historyFetchAbortController.signal
                        });
                        if (!res.ok) {
                            throw new Error(`历史记录请求失败(${res.status})`);
                        }
                        const data = await res.json();
                        console.log("History list loaded:", data);
                        if (sessionId !== this.historyRenderSessionId) return;
                        const normalized = Array.isArray(data)
                            ? data.map((item) => this.normalizeHistoryRecord(item))
                            : [];
                        if (keepExisting) {
                            this.historyListRaw = normalized;
                            this.historyList = normalized.slice();
                            this.historyLoadedCount = normalized.length;
                            this.historyLoading = false;
                            this.historyRenderRafId = null;
                        } else {
                            this.historyListRaw = normalized;
                            this.historyList = [];
                            this.historyLoadedCount = 0;
                            this.progressiveRenderHistory(sessionId);
                        }
                        this.historyHasLoadedOnce = true;
                    } catch (e) {
                        if (e && e.name === 'AbortError') return;
                        console.error("History Load Error:", e);
                        if (sessionId !== this.historyRenderSessionId) return;
                        this.historyLoading = false;
                        if (!keepExisting) {
                            this.historyListRaw = [];
                            this.historyList = [];
                            this.historyLoadedCount = 0;
                        }
                    } finally {
                        if (sessionId === this.historyRenderSessionId) {
                            this.historyFetchAbortController = null;
                        }
                    }
                },
                toggleSelectionMode(active) {
                    this.isSelectionMode = active;
                    this.selectedHistoryIds = [];
                },
                handleHistoryItemClick(item) {
                    if (this.isSelectionMode) {
                        const idx = this.selectedHistoryIds.indexOf(item.id);
                        if (idx > -1) {
                            this.selectedHistoryIds.splice(idx, 1);
                        } else {
                            this.selectedHistoryIds.push(item.id);
                        }
                    } else {
                        this.loadHistoryDetail(item.id);
                    }
                },
                async deleteSelectedHistory() {
                    const count = this.selectedHistoryIds.length;
                    if (count === 0) return;

                    if (!confirm(`确定要删除选中的 ${count} 条记录吗？`)) return;

                    try {
                        // Parallel delete (simple implementation)
                        // Ideally backend should support bulk delete
                        const deletePromises = this.selectedHistoryIds.map(id =>
                            fetch(`/api/v1/analysis/history/${id}`, { method: 'DELETE' })
                        );

                        await Promise.all(deletePromises);

                        const removedIds = new Set(this.selectedHistoryIds);
                        this.historyList = this.historyList.filter(item => !removedIds.has(item.id));
                        this.historyListRaw = this.historyListRaw.filter(item => !removedIds.has(item.id));
                        this.historyLoadedCount = this.historyList.length;
                        this.selectedHistoryIds = [];
                        this.isSelectionMode = false;

                    } catch (e) {
                        console.error("Batch delete failed", e);
                        alert("批量删除失败");
                    }
                },
                async deleteHistory(id) {
                    if (!confirm('确定要删除这条记录吗？')) return;
                    try {
                        await fetch(`/api/v1/analysis/history/${id}`, { method: 'DELETE' });
                        this.historyList = this.historyList.filter(item => item.id !== id);
                        this.historyListRaw = this.historyListRaw.filter(item => item.id !== id);
                        this.historyLoadedCount = this.historyList.length;
                    } catch (e) { console.error(e); }
                },
                async loadHistoryDetail(id) {
                    try {
                        this.cancelHistoryLoading();
                        if (!this.mapCore || !this.mapCore.map) {
                            this.errorMessage = '地图尚未初始化，请稍后重试';
                            return;
                        }

                        const res = await fetch(`/api/v1/analysis/history/${id}`);
                        const data = await res.json();
                        if (!data) return;

                        // Cleanup previous state
                        this.clearH3Grid();
                        if (this.marker) this.marker.setMap(null);
                        this.marker = null;
                        this.mapCore.clearCustomPolygons();
                        if (this.markerManager) {
                            // Ensure old markers are removed from map
                            if (this.markerManager.markers) {
                                this.markerManager.markers.forEach(m => m.setMap(null));
                            }
                            // Destroy clusterers if method exists
                            if (this.markerManager.destroyClusterers) {
                                this.markerManager.destroyClusterers();
                            }
                            // Clear internal references
                            this.markerManager.markers = [];
                            this.markerManager.points = [];
                            this.markerManager = null;
                        }
                        // Clear simplified poiMarkers array if used
                        if (this.poiMarkers) {
                            this.poiMarkers.forEach(m => m.setMap(null));
                            this.poiMarkers = [];
                        }

                        // Clear FilterPanel content to ensure clean rebuild
                        const filterContainer = document.getElementById('filtersContainer');
                        if (filterContainer) filterContainer.innerHTML = '';

                        if (data.params && data.params.center) {
                            this.selectedPoint = { lng: data.params.center[0], lat: data.params.center[1] };
                            this.mapCore.map.setCenter(data.params.center);
                            this.mapCore.center = { lng: data.params.center[0], lat: data.params.center[1] }; // Sync MapCore center
                            this.mapCore.setRadius(0); // Reset radius to avoid ghost circle at old location
                            // Restore time horizon if available
                            if (data.params.time_min) this.timeHorizon = data.params.time_min;
                        }

                        if (data.polygon) {
                            this.mapCore.setCustomPolygons([data.polygon]);
                            this.lastIsochroneGeoJSON = { geometry: { type: 'Polygon', coordinates: [data.polygon] } };
                        }

                        // Switch to Results Step before building panels
                        this.step = 3;
                        this.sidebarView = 'wizard'; // Return to wizard
                        this.activeStep3Panel = 'poi';
                        this.poiStatus = '正在加载历史点位...';
                        await this.$nextTick();
                        await new Promise((resolve) => window.requestAnimationFrame(resolve));

                        if (data.pois) {
                            this.allPoisDetails = data.pois;
                            // Integration with Legacy Filter Panel
                            if (this.updateLegacySystem) {
                                this.updateLegacySystem(data.pois);
                            } else {
                                this.renderPois(data.pois);
                            }
                            this.poiStatus = `已加载历史: ${data.pois.length} 条`;
                        }
                        setTimeout(() => this.resizePoiChart(), 0);

                    } catch (e) {
                        console.error(e);
                        alert("加载失败");
                    }
                },
                formatHistoryTitle(desc) {
                    if (!desc) return '无标题分析';
                    // Remove "15min Analysis - " prefix if present to avoid redundancy with tags
                    return desc.replace(/^\d+min Analysis - /, '');
                },
                resetAnalysis() {
                    this.step = 1;
                    this.sidebarView = 'wizard';
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    if (this.marker) {
                        this.marker.setMap(null);
                        this.marker = null;
                    }
                    this.clearAnalysisLayers();
                    if (this.mapCore && this.mapCore.map) {
                        this.mapCore.map.setFitView();
                    }
                },
                async triggerSearch() {
                    const input = document.getElementById('keyword');
                    const keyword = input && input.value ? String(input.value).trim() : '';
                    if (!keyword) return;
                    this.errorMessage = '';

                    if (!this.placeSearch && this.mapCore && this.mapCore.map) {
                        this.initSearch(this.mapCore.map);
                    }
                    if (!this.placeSearch || typeof this.placeSearch.search !== 'function') {
                        this.errorMessage = '搜索服务未就绪，请稍后重试';
                        return;
                    }

                    const focusPoi = (poi) => {
                        if (!poi || !poi.location) return false;
                        if (this.mapCore && this.mapCore.map) {
                            this.mapCore.map.setZoomAndCenter(15, poi.location);
                        }
                        this.setSelectedPoint(poi.location);
                        return true;
                    };

                    const result = await this.runPlaceSearch(keyword);
                    if (result.pois.length > 0 && focusPoi(result.pois[0])) {
                        return;
                    }

                    if (result.serviceError) {
                        if (result.errorInfo && result.errorInfo.indexOf('OVER_LIMIT') >= 0) {
                            this.errorMessage = '高德搜索当日额度已用完（OVER_LIMIT），请更换 JS Key 或次日重试';
                        } else {
                            this.errorMessage = "搜索服务异常，请稍后重试";
                        }
                        return;
                    }
                    this.errorMessage = `未找到“${keyword}”相关地点，请尝试更具体关键词`;
                },
                saveAndRestart() {
                    this.step = 1;
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    this.poiStatus = '';
                    if (this.marker) this.marker.setMap(null);
                    this.marker = null;
                    this.clearH3Grid();
                    if (this.mapCore && this.mapCore.clearCustomPolygons) {
                        this.mapCore.clearCustomPolygons();
                    }
                    if (this.markerManager) {
                        this.markerManager.markers.forEach(m => m.setMap(null));
                        this.markerManager.destroyClusterers();
                    }
                    this.disposePoiChart();
                },
                initPoiChart() {
                    const el = document.getElementById('poiChart');
                    if (!el || !window.echarts || el.clientWidth === 0) return null;

                    let chart = echarts.getInstanceByDom(el);
                    if (!chart) {
                        chart = echarts.init(el);
                        if (!this.poiChartResizeHandler) {
                            this.poiChartResizeHandler = () => this.resizePoiChart();
                            window.addEventListener('resize', this.poiChartResizeHandler);
                        }
                    }
                    this.poiChart = chart;
                    return chart;
                },
                resizePoiChart() {
                    if (this.poiChart) this.poiChart.resize();
                },
                disposePoiChart() {
                    if (this.poiChart) {
                        this.poiChart.dispose();
                        this.poiChart = null;
                    }
                    if (this.poiChartResizeHandler) {
                        window.removeEventListener('resize', this.poiChartResizeHandler);
                        this.poiChartResizeHandler = null;
                    }
                },
                disposeH3Charts() {
                    if (this.h3CategoryChart) {
                        this.h3CategoryChart.dispose();
                        this.h3CategoryChart = null;
                    }
                    if (this.h3DensityChart) {
                        this.h3DensityChart.dispose();
                        this.h3DensityChart = null;
                    }
                    if (this.h3LqChart) {
                        this.h3LqChart.dispose();
                        this.h3LqChart = null;
                    }
                    if (this.h3GapChart) {
                        this.h3GapChart.dispose();
                        this.h3GapChart = null;
                    }
                    if (this.h3StructureChart) {
                        this.h3StructureChart.dispose();
                        this.h3StructureChart = null;
                    }
                    if (this.h3ChartsResizeHandler) {
                        window.removeEventListener('resize', this.h3ChartsResizeHandler);
                        this.h3ChartsResizeHandler = null;
                    }
                },
                _resolveCategoryColors(labels) {
                    const colorByName = {};
                    (this.poiCategories || []).forEach((item) => {
                        colorByName[item.name] = item.color || '#888';
                    });
                    return (labels || []).map(label => colorByName[label] || '#5b8ff9');
                },
                _buildHistogram(values, metricKey, binCount = 8) {
                    const valid = (values || [])
                        .map(v => this._toNumber(v, NaN))
                        .filter(v => Number.isFinite(v));
                    if (!valid.length) {
                        return { bins: [], counts: [] };
                    }
                    const minV = Math.min(...valid);
                    const maxV = Math.max(...valid);
                    if (Math.abs(maxV - minV) < 1e-12) {
                        const label = `${this._formatLegendValue(minV, metricKey)} ~ ${this._formatLegendValue(maxV, metricKey)}`;
                        return { bins: [label], counts: [valid.length] };
                    }

                    const bins = [];
                    const counts = new Array(binCount).fill(0);
                    const span = maxV - minV;
                    const step = span / binCount;
                    for (let i = 0; i < binCount; i += 1) {
                        const start = minV + step * i;
                        const end = i === binCount - 1 ? maxV : (minV + step * (i + 1));
                        bins.push(`${this._formatLegendValue(start, metricKey)} ~ ${this._formatLegendValue(end, metricKey)}`);
                    }
                    for (const v of valid) {
                        let idx = Math.floor((v - minV) / step);
                        if (!Number.isFinite(idx)) idx = 0;
                        if (idx < 0) idx = 0;
                        if (idx >= binCount) idx = binCount - 1;
                        counts[idx] += 1;
                    }
                    return { bins, counts };
                },
                _resolveMetricHistogram(metricKey) {
                    const source = this.h3AnalysisGridFeatures || [];
                    const values = source.map((feature) => {
                        const props = (feature && feature.properties) || {};
                        const datum = this._getH3MetricValue(props, metricKey);
                        return datum.noData ? null : datum.value;
                    }).filter(v => Number.isFinite(v));

                    if (metricKey === 'entropy') {
                        const hist = this._buildHistogram(values, 'entropy', 10);
                        return {
                            title: '局部熵分布（0~1）',
                            xAxisName: '熵区间',
                            bins: hist.bins,
                            counts: hist.counts,
                            color: '#4cae63',
                            subtext: '仅统计样本数足够的网格',
                        };
                    }
                    if (metricKey === 'neighbor_delta') {
                        const hist = this._buildHistogram(values, 'neighbor_delta', 8);
                        return {
                            title: '邻域差值分布（POI/km²）',
                            xAxisName: '差值区间（本格-邻域）',
                            bins: hist.bins,
                            counts: hist.counts,
                            color: '#3f7fd8',
                            subtext: '正值表示高于邻域，负值表示低于邻域',
                        };
                    }

                    const densityData = this.h3AnalysisCharts && this.h3AnalysisCharts.density_histogram
                        ? this.h3AnalysisCharts.density_histogram
                        : null;
                    if (densityData && Array.isArray(densityData.bins) && Array.isArray(densityData.counts)) {
                        return {
                            title: '密度分布（POI/km²）',
                            xAxisName: '密度区间 (POI/km²)',
                            bins: densityData.bins,
                            counts: densityData.counts.map(v => this._toNumber(v, 0)),
                            color: '#4c8bf5',
                            subtext: '',
                        };
                    }

                    const hist = this._buildHistogram(values, 'density', 8);
                    return {
                        title: '密度分布（POI/km²）',
                        xAxisName: '密度区间 (POI/km²)',
                        bins: hist.bins,
                        counts: hist.counts,
                        color: '#4c8bf5',
                        subtext: '',
                    };
                },
                updateH3Charts() {
                    if (!window.echarts || !this.h3AnalysisCharts) return;
                    const categoryEl = document.getElementById('h3CategoryChart');
                    const densityEl = document.getElementById('h3DensityChart');
                    if (!categoryEl || !densityEl) return;
                    if (categoryEl.clientWidth === 0 || densityEl.clientWidth === 0) return;

                    if (!this.h3ChartsResizeHandler) {
                        this.h3ChartsResizeHandler = () => {
                            if (this.h3CategoryChart) this.h3CategoryChart.resize();
                            if (this.h3DensityChart) this.h3DensityChart.resize();
                            if (this.h3LqChart) this.h3LqChart.resize();
                            if (this.h3GapChart) this.h3GapChart.resize();
                            if (this.h3StructureChart) this.h3StructureChart.resize();
                        };
                        window.addEventListener('resize', this.h3ChartsResizeHandler);
                    }

                    let categoryChart = echarts.getInstanceByDom(categoryEl);
                    if (!categoryChart) categoryChart = echarts.init(categoryEl);
                    this.h3CategoryChart = categoryChart;

                    let densityChart = echarts.getInstanceByDom(densityEl);
                    if (!densityChart) densityChart = echarts.init(densityEl);
                    this.h3DensityChart = densityChart;

                    const categoryData = this.h3AnalysisCharts.category_distribution || {};
                    const categoryLabels = categoryData.labels || [];
                    const categoryValues = (categoryData.values || []).map(v => this._toNumber(v, 0));
                    const categoryColors = this._resolveCategoryColors(categoryLabels);
                    categoryChart.setOption(
                        {
                            animationDuration: 240,
                            grid: { left: 48, right: 12, top: 22, bottom: 20, containLabel: true },
                            xAxis: {
                                type: 'value',
                                axisLine: { show: false },
                                axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eceff3' } },
                                minInterval: 1,
                            },
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: categoryLabels,
                                axisLine: { show: false },
                                axisTick: { show: false },
                            },
                            series: [{
                                type: 'bar',
                                data: categoryValues,
                                barWidth: 12,
                                itemStyle: { color: (params) => categoryColors[params.dataIndex] || '#5b8ff9' },
                                label: {
                                    show: true,
                                    position: 'right',
                                    formatter: '{c}',
                                    color: '#555',
                                    fontSize: 11
                                }
                            }]
                        },
                        true
                    );

                    const metricHist = this._resolveMetricHistogram(this.h3MetricView || 'density');
                    const bins = metricHist.bins || [];
                    const counts = (metricHist.counts || []).map(v => this._toNumber(v, 0));
                    const densitySubtext = metricHist.subtext || '';
                    densityChart.setOption(
                        {
                            title: {
                                text: metricHist.title || '指标分布',
                                subtext: densitySubtext,
                                left: 'center',
                                top: 0,
                                textStyle: { fontSize: 12, fontWeight: 600, color: '#374151' },
                                subtextStyle: { fontSize: 10, color: '#6b7280' }
                            },
                            animationDuration: 240,
                            grid: { left: 44, right: 16, top: densitySubtext ? 52 : 36, bottom: 40, containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: bins,
                                name: metricHist.xAxisName || '区间',
                                nameLocation: 'middle',
                                nameGap: 28,
                                nameTextStyle: { color: '#6b7280', fontSize: 10 },
                                axisLabel: {
                                    color: '#6b7280',
                                    fontSize: 10,
                                    interval: 0,
                                    rotate: bins.length > 6 ? 35 : 0,
                                },
                                axisLine: { lineStyle: { color: '#d7dce3' } }
                            },
                            yAxis: {
                                type: 'value',
                                minInterval: 1,
                                name: '网格数',
                                nameLocation: 'middle',
                                nameGap: 34,
                                nameTextStyle: { color: '#6b7280', fontSize: 10 },
                                axisLine: { show: false },
                                axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eceff3' } }
                            },
                            series: [{
                                type: 'bar',
                                data: counts,
                                barMaxWidth: 20,
                                itemStyle: { color: metricHist.color || '#4c8bf5' }
                            }]
                        },
                        true
                    );
                },
                computePoiStats(points) {
                    const labels = this.poiCategories.map(c => c.name);
                    const colors = this.poiCategories.map(c => c.color || '#888');
                    const values = this.poiCategories.map(() => 0);
                    const indexMap = {};
                    this.poiCategories.forEach((c, idx) => {
                        indexMap[c.id] = idx;
                    });
                    (points || []).forEach(p => {
                        const cid = this.resolvePoiCategoryId(p && p.type);
                        if (!cid) return;
                        const idx = indexMap[cid];
                        if (Number.isInteger(idx) && idx >= 0) values[idx] += 1;
                    });
                    return { labels, colors, values };
                },
                updatePoiCharts() {
                    if (!this.markerManager || !this.markerManager.getVisiblePoints) return;

                    const el = document.getElementById('poiChart');
                    if (!el || !window.echarts) return;

                    // If chart already exists and is visible, update immediately for smooth animation (restores transition)
                    const existingChart = echarts.getInstanceByDom(el);
                    if (existingChart && el.clientWidth > 0) {
                        this.poiChart = existingChart;
                        const points = this.markerManager.getVisiblePoints();
                        const stats = this.computePoiStats(points);
                        const safeValues = stats.values.map(v => (Number.isFinite(v) ? v : 0));

                        const option = {
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: stats.labels
                            },
                            series: [{
                                data: safeValues,
                                itemStyle: {
                                    color: (params) => stats.colors[params.dataIndex] || '#888'
                                }
                            }]
                        };
                        existingChart.setOption(option, false); // Merge for animation
                        return;
                    }

                    // Otherwise, delay slightly for initial rendering (Step 3 panels use v-show)
                    setTimeout(() => {
                        const chart = this.initPoiChart();
                        if (!chart) return;

                        const points = this.markerManager.getVisiblePoints();
                        const stats = this.computePoiStats(points);
                        const safeValues = stats.values.map(v => (Number.isFinite(v) ? v : 0));

                        const option = {
                            grid: { left: 50, right: 20, top: 10, bottom: 10, containLabel: true },
                            xAxis: {
                                type: 'value',
                                axisLine: { show: false }, axisTick: { show: false },
                                splitLine: { lineStyle: { color: '#eee' } }
                            },
                            yAxis: {
                                type: 'category',
                                inverse: true,
                                data: stats.labels,
                                axisLine: { show: false }, axisTick: { show: false }
                            },
                            series: [{
                                type: 'bar',
                                data: safeValues,
                                barWidth: 12,
                                itemStyle: {
                                    color: (params) => stats.colors[params.dataIndex] || '#888'
                                }
                            }]
                        };
                        try {
                            chart.setOption(option, true);
                            chart.resize();
                        } catch (err) {
                            console.error("ECharts setOption error:", err);
                        }
                    }, 100);
                },
                updateLegacySystem(pois) {
                    if (this.markerManager) {
                        if (this.markerManager.markers) {
                            this.markerManager.markers.forEach(m => m.setMap(null));
                        }
                        if (this.markerManager.destroyClusterers) {
                            this.markerManager.destroyClusterers();
                        }
                    }
                    this.markerManager = null;
                    this.filterPanel = null;
                    const filtersContainer = document.getElementById('filtersContainer');
                    if (filtersContainer) filtersContainer.innerHTML = '';

                    if (this.poiMarkers) {
                        this.poiMarkers.forEach(m => m.setMap(null));
                        this.poiMarkers = [];
                    }

                    const defaultTypeId = (() => {
                        for (const group of (this.typeMapGroups || [])) {
                            const firstItem = (group.items || [])[0];
                            if (firstItem && firstItem.id) return firstItem.id;
                        }
                        return (this.poiCategories[0] && this.poiCategories[0].id) ? this.poiCategories[0].id : 'default';
                    })();
                    const points = pois.map((p, idx) => {
                        const matchedType = this.resolvePoiTypeId(p && p.type) || defaultTypeId;
                        return {
                            lng: p.location[0],
                            lat: p.location[1],
                            name: p.name,
                            type: matchedType,
                            address: p.address,
                            lines: p.lines,
                            _pid: p.id || ('p-' + idx)
                        };
                    });

                    const mapTypeConfig = {
                        groups: (this.typeMapGroups || []).map((group, index) => ({
                            id: String(group.id || `group-${index + 1}`),
                            title: String(group.title || group.id || `分类${index + 1}`),
                            toggleId: String(group.toggleId || `toggle-group-${index + 1}`),
                            filtersId: String(group.filtersId || `filters-group-${index + 1}`),
                            items: (group.items || []).map((item) => ({
                                id: String(item.id || ''),
                                label: String(item.label || item.id || ''),
                                color: item.color || '#888',
                                defaultChecked: this.poiSubSelectionState[item.id] !== false
                            })).filter(item => item.id)
                        })).filter(group => group.id && group.items.length > 0)
                    };
                    if (!mapTypeConfig.groups.length) {
                        mapTypeConfig.groups = [{
                            id: 'poi_group',
                            title: 'POI 分类',
                            toggleId: 'toggle_poi_group',
                            filtersId: 'filters-poi-group',
                            items: this.poiCategories.map((cat) => ({
                                id: String(cat.id || ''),
                                label: String(cat.name || cat.id || ''),
                                color: cat.color || '#888',
                                defaultChecked: cat.checked !== false
                            })).filter(item => item.id)
                        }];
                    }

                    const centerObj = this.selectedPoint ? {
                        lng: this.selectedPoint.lng,
                        lat: this.selectedPoint.lat,
                        name: '中心点',
                        type: 'center'
                    } : null;

                    this.markerManager = new MarkerManager(this.mapCore, {
                        mapData: { points: points, center: centerObj },
                        mapTypeConfig: mapTypeConfig
                    });
                    this.markerManager.init();
                    this.markerManager.renderMarkers();

                    // Filter Panel
                    this.filterPanel = new FilterPanel(this.markerManager, {
                        mapData: { points: points },
                        mapTypeConfig: mapTypeConfig,
                        flatMode: false
                    });
                    this.filterPanel.init();
                    this.markerManager.applyFilters();
                    this.applySimplifyPointVisibility();
                    this.filterPanel.onFiltersChange = () => this.updatePoiCharts();
                    this.updatePoiCharts();
                }
            }
        }).mount('#app');
    </script>
</body>

</html>
