<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>é«˜å¾·åœ°å›¾ç©ºé—´åˆ†æ (Vueç‰ˆ)</title>
    <link rel="stylesheet" href="/static/css/map-common.css">
    <link rel="stylesheet" href="/static/css/filter-panel.css">
    <!-- å¼•å…¥ Vue 3 (CDN) -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --sidebar-width: 320px;
            --bg-color: #f7f7f8;
            --card-bg: #ffffff;
            --text-primary: #111111;
            --text-secondary: #666666;
            --accent-color: #000000;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            background: var(--bg-color);
            color: var(--text-primary);
        }

        /* Sidebar Styling */
        .sidebar {
            width: var(--sidebar-width);
            background: #fff;
            border-right: 1px solid #f0f0f0;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .sidebar-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.5px;
        }

        .sidebar-content {
            flex: 1;
            padding: 0 20px 20px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Common Elements */
        .wizard-step {
            animation: fadeIn 0.4s ease;
        }

        .step-title h3 {
            font-size: 18px;
            margin: 0 0 5px 0;
        }

        .step-title p,
        .step-desc {
            font-size: 13px;
            color: var(--text-secondary);
            margin: 0 0 20px 0;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        /* Minimal Inputs */
        .minimal-input {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            border: 1px solid #eee;
            border-radius: 8px;
            background: #f9f9f9;
            font-size: 14px;
            transition: all 0.2s;
        }

        .minimal-input:focus {
            background: #fff;
            border-color: #000;
            outline: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .search-group {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            background: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
            width: 46px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: #eee;
            color: #000;
        }

        /* Minimal Buttons */
        .btn-black {
            width: 100%;
            padding: 14px;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }

        .btn-black:hover {
            background: #333;
        }

        .btn-black:active {
            transform: scale(0.98);
        }

        .btn-black:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
        }

        .btn-outline {
            width: 100%;
            padding: 12px;
            background: #fff;
            color: #000;
            border: 1px solid #ddd;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }

        .btn-outline:hover {
            background: #f9f9f9;
        }

        .btn-text-back {
            background: none;
            border: none;
            color: #666;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            padding: 0;
            margin-right: 15px;
        }

        .btn-text-back:hover {
            color: #000;
            text-decoration: underline;
        }

        .step-header-nav {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .step-header-nav h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        /* Mode Selection Pills */
        .mode-select {
            display: flex;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 12px;
        }

        .mode-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            font-size: 13px;
            cursor: pointer;
            border-radius: 8px;
            color: #666;
            transition: all 0.2s;
        }

        .mode-option.active {
            background: #fff;
            color: #000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            font-weight: 600;
        }

        /* Category Grid */
        .category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .cat-card {
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #fff;
        }

        .cat-card:hover {
            border-color: #ccc;
        }

        .cat-card.checked {
            border-color: #000;
            background: #fdfdfd;
            box-shadow: 0 0 0 1px #000 inset;
        }

        .cat-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .cat-card span {
            font-size: 13px;
            font-weight: 500;
        }

        /* History Mini List */
        .history-list-mini {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .history-list {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .history-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;
        }

        .history-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border-color: #bdbdbd;
            transform: translateY(-2px);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .card-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            line-height: 1.4;
            margin-right: 20px;
            flex: 1;
        }

        .card-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #888;
            flex-wrap: wrap;
        }

        .meta-tag {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .del-btn {
            color: #bbb;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 16px;
            line-height: 1;
        }

        .del-btn:hover {
            background: #ffebee;
            color: #d32f2f;
        }

        /* Legacy Filter Panel Overrides */
        #filtersContainer {
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .filter-section {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }

        .filter-section h4 {
            font-size: 13px;
            text-transform: uppercase;
            color: #999;
            letter-spacing: 0.5px;
        }

        /* Map and Main */
        .main-content {
            flex: 1;
            position: relative;
        }

        #container {
            width: 100%;
            height: 100%;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status-badge {
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            display: inline-block;
            width: 100%;
            box-sizing: border-box;
        }

        .status-badge.success {
            background: #e6f4ea;
            color: #1e8e3e;
        }

        .status-badge.warning {
            background: #fef7e0;
            color: #f9ab00;
        }

        .error-msg {
            color: #d93025;
            font-size: 12px;
            margin-top: 10px;
            text-align: center;
        }

        .status-text {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .home-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        .home-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .home-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            border-color: #2196f3;
        }

        .home-icon {
            width: 48px;
            height: 48px;
            background: #e3f2fd;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #2196f3;
        }

        .home-text h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
            color: #333;
        }

        .home-text p {
            margin: 0;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>

<body>
    <!-- Vue App æŒ‚è½½ç‚¹ -->
    <div id="app" style="display: flex; width: 100%; height: 100%;">

        <div v-if="loadingConfig" class="page-loading">æ­£åœ¨åŠ è½½é…ç½®...</div>

        <!-- Left Sidebar: Wizard Dashboard -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2 v-if="sidebarView === 'start'">æ¬¢è¿ä½¿ç”¨</h2>

                <div v-if="sidebarView === 'wizard'" class="step-header-nav" style="margin:0; width:100%;">
                    <button v-if="step === 1" class="btn-text-back" @click="backToHome">â† è¿”å›ä¸»é¡µ</button>
                    <h2 v-else style="margin:0;">åˆ†ææ§åˆ¶å°</h2>
                </div>

                <div v-if="sidebarView === 'wizard' && step > 1" class="step-indicator">
                    Step {% raw %}{{ step }}{% endraw %}/3
                </div>

                <div v-if="sidebarView === 'history'" class="step-header-nav" style="margin:0; width:100%;">
                    <button class="btn-text-back" @click="sidebarView='start'">â† è¿”å›ä¸»é¡µ</button>
                    <h3 style="margin:0;">å†å²è®°å½•</h3>
                </div>
            </div>

            <div class="sidebar-content">

                <!-- Start Screen -->
                <div v-show="sidebarView === 'start'" class="home-menu">
                    <div class="home-card" @click="resetAnalysis()">
                        <div class="home-icon">ğŸ”</div>
                        <div class="home-text">
                            <h3>å®æ—¶æ¢ç´¢</h3>
                            <p>Real-time Explore</p>
                            <p style="margin-top:4px; color:#999;">åŸºäºé«˜å¾·å®æ—¶æ•°æ®åˆ†æ</p>
                        </div>
                    </div>

                    <div class="home-card" @click="sidebarView='history'; loadHistoryList();">
                        <div class="home-icon">ğŸ“‚</div>
                        <div class="home-text">
                            <h3>æœ¬åœ°æ¡£æ¡ˆ</h3>
                            <p>Local Archives</p>
                            <p style="margin-top:4px; color:#999;">æŸ¥çœ‹å¾€æœŸåˆ†æè®°å½•</p>
                        </div>
                    </div>
                </div>

                <!-- History View -->
                <div v-show="sidebarView === 'history'" class="history-list">
                    <div v-for="item in historyList" :key="item.id" class="history-card"
                        @click="loadHistoryDetail(item.id)">
                        <div class="card-header">
                            <span class="card-title">{% raw %}{{ formatHistoryTitle(item.description) }}{% endraw
                                %}</span>
                            <span @click.stop="deleteHistory(item.id)" class="del-btn" title="åˆ é™¤">Ã—</span>
                        </div>
                        <div class="card-meta">
                            <span class="meta-tag">
                                <span v-if="item.params && item.params.mode === 'driving'">ğŸš— é©¾è½¦</span>
                                <span v-else-if="item.params && item.params.mode === 'bicycling'">ğŸš² éª‘è¡Œ</span>
                                <span v-else>ğŸš¶ æ­¥è¡Œ</span>
                            </span>
                            <span v-if="item.params && item.params.time_min" class="meta-tag">â±ï¸ {% raw %}{{
                                item.params.time_min }}{% endraw %}åˆ†</span>
                            <span class="meta-tag" style="background:#fff; border:1px solid #eee;">ğŸ“… {% raw %}{{ new
                                Date(item.created_at).toLocaleDateString() }}{% endraw %}</span>
                        </div>
                    </div>

                    <div v-if="historyList.length === 0"
                        style="text-align:center; padding:40px 20px; color:#999; display:flex; flex-direction:column; align-items:center;">
                        <span style="font-size:24px; margin-bottom:10px;">ğŸ“­</span>
                        <span>æš‚æ— å†å²è®°å½•</span>
                    </div>
                </div>

                <!-- Wizard View Wrapper -->
                <div v-show="sidebarView === 'wizard'" style="display:contents;">

                    <!-- Step 1: Location & Analysis -->
                    <div v-show="step === 1" class="wizard-step">
                        <div class="step-title">
                            <h3>1. åœ°ç‚¹ä¸èŒƒå›´</h3>
                        </div>

                        <div class="form-group search-group">
                            <input type="text" id="keyword" class="minimal-input" placeholder="æœç´¢åœ°ç‚¹..."
                                @keyup.enter="triggerSearch">
                            <button class="btn-icon" @click="triggerSearch">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                </svg>
                            </button>
                        </div>

                        <div class="form-group">
                            <div v-if="selectedPoint" class="status-badge success">
                                å·²é€‰: {% raw %}{{ selectedPoint.lng.toFixed(4) }}, {{ selectedPoint.lat.toFixed(4) }}{%
                                endraw
                                %}
                            </div>
                            <div v-else class="status-badge warning">è¯·åœ¨åœ°å›¾ä¸Šç‚¹å‡»æˆ–æœç´¢é€‰æ‹©èµ·ç‚¹</div>
                        </div>

                        <div class="form-group">
                            <label>å‡ºè¡Œæ–¹å¼</label>
                            <div class="mode-select">
                                <div class="mode-option" :class="{active: transportMode==='walking'}"
                                    @click="transportMode='walking'">æ­¥è¡Œ ğŸš¶</div>
                                <div class="mode-option" :class="{active: transportMode==='bicycling'}"
                                    @click="transportMode='bicycling'">éª‘è¡Œ ğŸš²</div>
                                <div class="mode-option" :class="{active: transportMode==='driving'}"
                                    @click="transportMode='driving'">é©¾è½¦ ğŸš—</div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>æ—¶é—´èŒƒå›´: {% raw %}{{ timeHorizon }}{% endraw %} åˆ†é’Ÿ</label>
                            <input type="range" v-model.number="timeHorizon" class="minimal-range" min="5" max="60"
                                step="5">
                        </div>

                        <button class="btn-black" :disabled="!selectedPoint || isCalculating" @click="startAnalysis">
                            {% raw %}{{ isCalculating ? 'è®¡ç®—ä¸­...' : 'ä¸‹ä¸€æ­¥: ç”Ÿæˆç­‰æ—¶åœˆ' }}{% endraw %}
                        </button>
                        <div v-if="errorMessage" class="error-msg">{% raw %}{{ errorMessage }}{% endraw %}</div>
                    </div>

                    <!-- Step 2: POI Categories -->
                    <div v-show="step === 2" class="wizard-step">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(1)">â† è¿”å›</button>
                            <h3>2. é€‰æ‹©ä¸šæ€</h3>
                        </div>
                        <p class="step-desc">é€‰æ‹©éœ€è¦åœ¨ç­‰æ—¶åœˆå†…æŠ“å–çš„è®¾æ–½ç±»å‹</p>

                        <div class="category-grid">
                            <div v-for="cat in poiCategories" :key="cat.code" class="cat-card"
                                :class="{checked: cat.checked}" @click="cat.checked = !cat.checked">
                                <div class="cat-color" :style="{background: cat.color}"></div>
                                <span>{% raw %}{{ cat.name }}{% endraw %}</span>
                                <input type="checkbox" v-model="cat.checked" style="display:none;">
                            </div>
                        </div>

                        <button class="btn-black" :disabled="isFetchingPois" @click="fetchPois">
                            {% raw %}{{ isFetchingPois ? 'æ•°æ®æŠ“å–ä¸­...' : 'ä¸‹ä¸€æ­¥: æŠ“å–æ•°æ®' }}{% endraw %}
                        </button>
                        <div v-if="poiStatus" class="status-text">{% raw %}{{ poiStatus }}{% endraw %}</div>
                    </div>

                    <!-- Step 3: Results & Filter -->
                    <div v-show="step === 3" class="wizard-step">
                        <div class="step-header-nav">
                            <button class="btn-text-back" @click="goToStep(2)">â† è¿”å›</button>
                            <h3>3. ç»“æœåˆ†æ</h3>
                        </div>

                        <!-- Copied from map_with_filters.html -->
                        <div class="filter-section">
                            <h4><span>åŠå¾„è°ƒèŠ‚</span></h4>
                            <div class="filter-group">
                                <div class="filter-option range-control">
                                    <input type="range" id="radiusSlider" min="0" max="10000" step="100"
                                        class="minimal-range">
                                    <span id="radiusValue" class="range-value">â€”</span>
                                </div>
                            </div>
                        </div>

                        <div class="filter-section">
                            <button id="toggleExpandAll" class="btn-outline"
                                style="padding:5px; font-size:12px;">å…¨éƒ¨å±•å¼€</button>
                        </div>

                        <div class="filter-section" style="display:flex; gap:10px;">
                            <button id="toggleAll" class="btn-outline"
                                style="padding:5px; font-size:12px;">å…¨éƒ¨æ˜¾ç¤º/éšè—</button>
                            <button id="toggleNames" class="btn-outline"
                                style="padding:5px; font-size:12px;">éšè—åç§°</button>
                        </div>

                        <div class="filter-section">
                            <button id="toggleHeatmap" class="btn-outline"
                                style="padding:5px; font-size:12px;">å¼€å¯çƒ­åŠ›å›¾</button>
                            <div class="filter-group" style="margin-top:10px;">
                                <div class="filter-option range-control">
                                    <input type="range" id="heatmapCountSlider" min="1" max="100" step="1" value="10"
                                        class="minimal-range">
                                    <span id="heatmapCountValue" class="range-value">10</span>
                                </div>
                            </div>
                        </div>

                        <!-- Legacy Filter Container -->
                        <div id="filtersContainer" class="legacy-filters-wrapper"></div>

                        <button class="btn-outline" @click="saveAndRestart">
                            ä¿å­˜å¹¶å¼€å§‹æ–°åˆ†æ
                        </button>
                    </div>
                </div> <!-- End Wizard View Wrapper -->

            </div> <!-- End of sidebar-content -->

            <!-- Fixed History Footer -->
            <!-- Sidebar Footer (Only in Wizard Mode) -->
            <div v-if="sidebarView === 'wizard'" class="sidebar-footer"
                style="padding: 20px; border-top: 1px solid #f0f0f0; background: #fff;">
                <button class="btn-outline"
                    style="margin-top:0; border:1px solid #eee; display:flex; justify-content:center; align-items:center;"
                    @click="sidebarView = 'history'">
                    <span style="margin-right:8px;">ğŸ“œ</span> æŸ¥çœ‹å†å²è®°å½• ({% raw %}{{ historyList.length }}{% endraw %})
                </button>
            </div>
        </aside>

        <!-- Middle: Map -->
        <main class="main-content">
            <div id="container"></div>
        </main>
    </div>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="/static/js/map-utils.js"></script>
    <script src="/static/js/map-core.js"></script>
    <script src="/static/js/map-heatmap.js"></script>
    <script src="/static/js/map-markers.js"></script>
    <script src="/static/js/map-filters.js"></script>
    <!-- å¼•å…¥ analysis.js ä¹Ÿå¯ä»¥ï¼Œä½†æˆ‘ä»¬å¤§éƒ¨åˆ†é€»è¾‘ç§»å…¥ Vue methods æ›´å¥½ï¼Œè¿™é‡Œä¾ç„¶å¼•å…¥ä»¥å…¼å®¹ MapCore ä¾èµ– -->

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    loadingConfig: true,
                    config: null,

                    // State
                    step: 1, // Wizard Step
                    sidebarView: 'start', // 'start', 'wizard', 'history'
                    selectedPoint: null, // {lng, lat}
                    transportMode: 'walking',
                    timeHorizon: 15,
                    isCalculating: false,
                    errorMessage: '',

                    // POI Data
                    poiKeywords: '', // Not used if using categories, but kept for custom
                    poiCategories: [
                        { name: 'é¤é¥®', code: '050000', checked: true, color: '#f44336' }, // Red
                        { name: 'è´­ç‰©', code: '060000', checked: true, color: '#2196f3' }, // Blue
                        { name: 'ç”Ÿæ´»', code: '070000', checked: true, color: '#ff9800' }, // Orange
                        { name: 'äº¤é€š', code: '150000', checked: true, color: '#4caf50' }, // Green
                        { name: 'é£æ™¯', code: '110000', checked: true, color: '#9c27b0' }, // Purple
                        { name: 'ç§‘æ•™', code: '140000', checked: true, color: '#00bcd4' }, // Cyan
                        { name: 'åŒ»ç–—', code: '090000', checked: true, color: '#e91e63' }  // Pink
                    ],
                    isFetchingPois: false,
                    poiStatus: '',
                    lastIsochroneGeoJSON: null,
                    poiMarkers: [],
                    allPoisDetails: [], // Store full fetched data for client-side filtering

                    // Instances

                    // History
                    historyList: [],
                }
            },
            async mounted() {
                try {
                    const res = await fetch('/api/v1/config');
                    if (!res.ok) throw new Error(`é…ç½®æ¥å£è¿”å› ${res.status}`);
                    const data = await res.json();
                    this.config = data;

                    await this.loadAMapScript(data.amap_js_api_key, data.amap_js_security_code);
                    this.initMap();
                    if (this.loadHistoryList) this.loadHistoryList();
                } catch (e) {
                    console.error("Initialization Failed:", e);
                    this.errorMessage = "ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: " + e.message;
                } finally {
                    this.loadingConfig = false;
                }
            },
            methods: {
                goToStep(targetStep) {
                    if (targetStep < this.step) {
                        // Backwards navigation cleanup
                        if (this.step === 3 && targetStep <= 2) {
                            // Clear POI markers & data
                            if (this.markerManager) {
                                if (this.markerManager.markers) {
                                    this.markerManager.markers.forEach(m => m.setMap(null));
                                }
                                if (this.markerManager.destroyClusterers) {
                                    this.markerManager.destroyClusterers();
                                }
                                this.markerManager = null;
                            }
                            if (this.poiMarkers) {
                                this.poiMarkers.forEach(m => m.setMap(null));
                                this.poiMarkers = [];
                            }
                            // Clear Legacy Filter Panel
                            const filterContainer = document.getElementById('filtersContainer');
                            if (filterContainer) filterContainer.innerHTML = '';

                            this.poiStatus = '';
                        }

                        if (this.step >= 2 && targetStep <= 1) {
                            // Clear Isochrone Polygon
                            this.mapCore.clearCustomPolygons();
                            this.lastIsochroneGeoJSON = null;
                        }
                    }
                    this.step = targetStep;
                },
                backToHome() {
                    this.sidebarView = 'start';
                    this.step = 1;
                    this.selectedPoint = null;
                    if (this.marker) {
                        this.marker.setMap(null);
                        this.marker = null;
                    }
                    this.errorMessage = '';
                },
                loadAMapScript(key, securityCode) {
                    return new Promise((resolve, reject) => {
                        window._AMapSecurityConfig = { securityJsCode: securityCode };
                        const script = document.createElement('script');
                        script.src = `https://webapi.amap.com/maps?v=1.4.15&key=${key}&plugin=AMap.Autocomplete,AMap.PlaceSearch`;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                },
                initMap() {
                    const mapCore = new MapCore('container', {
                        center: { lng: 121.4737, lat: 31.2304 },
                        zoom: 13,
                        zooms: [3, 20],
                        mapData: {}
                    });
                    mapCore.initMap();
                    this.mapCore = mapCore;

                    mapCore.map.on('click', (e) => {
                        // Limit marker adjustment to Step 1 in Wizard mode
                        if (this.sidebarView !== 'wizard' || this.step !== 1) return;
                        this.setSelectedPoint(e.lnglat);
                    });

                    this.initSearch(mapCore.map);
                },
                initSearch(map) {
                    const autoOptions = { input: "keyword" };
                    const autocomplete = new AMap.Autocomplete(autoOptions);
                    const placeSearch = new AMap.PlaceSearch({ map: map });
                    this.placeSearch = placeSearch; // Save instance

                    AMap.event.addListener(autocomplete, "select", (e) => {
                        if (e.poi && e.poi.location) {
                            map.setZoomAndCenter(15, e.poi.location);
                            this.setSelectedPoint(e.poi.location);
                        }
                    });
                },
                setSelectedPoint(lnglat) {
                    this.selectedPoint = { lng: lnglat.lng, lat: lnglat.lat };
                    if (this.mapCore) {
                        this.mapCore.center = { lng: lnglat.lng, lat: lnglat.lat };
                    }
                    this.errorMessage = '';
                    if (this.marker) {
                        this.marker.setPosition(lnglat);
                        return;
                    }
                    this.marker = new AMap.Marker({ position: lnglat });
                    this.mapCore.map.add(this.marker);
                },
                async startAnalysis() {
                    if (!this.selectedPoint || this.isCalculating) return;
                    this.isCalculating = true;
                    this.errorMessage = '';

                    try {
                        const payload = {
                            lat: this.selectedPoint.lat,
                            lon: this.selectedPoint.lng,
                            time_min: parseInt(this.timeHorizon),
                            mode: this.transportMode,
                            coord_type: 'gcj02'
                        };

                        const res = await fetch('/api/v1/analysis/isochrone', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!res.ok) throw new Error("API è¯·æ±‚å¤±è´¥");
                        const geojson = await res.json();

                        this.lastIsochroneGeoJSON = geojson;
                        this.renderResult(geojson);
                        this.step = 2; // Advance to Step 2

                    } catch (e) {
                        console.error(e);
                        this.errorMessage = "è®¡ç®—å¤±è´¥: " + e.message;
                    } finally {
                        this.isCalculating = false;
                    }
                },
                async fetchPois() {
                    if (!this.lastIsochroneGeoJSON) return;
                    this.isFetchingPois = true;
                    this.poiStatus = "è¯·æ±‚ä¸­...";

                    if (this.poiMarkers) this.poiMarkers.forEach(m => m.setMap(null));
                    this.poiMarkers = [];
                    this.allPoisDetails = [];

                    try {
                        const geometry = this.lastIsochroneGeoJSON.geometry;
                        let rawPoly = (geometry.type === 'Polygon') ? geometry.coordinates[0] : geometry.coordinates[0][0];
                        const polygon = rawPoly.map(pt => {
                            if (Array.isArray(pt)) return [pt[0], pt[1]];
                            if (pt && typeof pt.lng === 'number') return [pt.lng, pt.lat];
                            return pt;
                        });

                        const types = this.poiCategories.filter(c => c.checked).map(c => c.code).join('|');
                        if (!types) {
                            alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåˆ†ç±»");
                            this.isFetchingPois = false;
                            return;
                        }

                        const payload = {
                            polygon: polygon,
                            keywords: "",
                            types: types,
                            max_count: 1000,
                            save_history: true,
                            center: [this.selectedPoint.lng, this.selectedPoint.lat],
                            time_min: parseInt(this.timeHorizon),
                            location_name: this.selectedPoint.name || (this.selectedPoint.lng.toFixed(4) + ',' + this.selectedPoint.lat.toFixed(4))
                        };

                        const res = await fetch('/api/v1/analysis/pois', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!res.ok) throw new Error("POIè¯·æ±‚å¤±è´¥");
                        const data = await res.json();

                        this.poiStatus = `æ‰¾åˆ° ${data.count} ä¸ªç»“æœ`;

                        // Integration with Legacy Filter Panel
                        if (this.updateLegacySystem) {
                            this.updateLegacySystem(data.pois);
                        } else {
                            // Fallback if updateLegacySystem undefined for some reason
                            this.renderPois(data.pois);
                        }

                        this.step = 3; // Advance to Step 3
                        this.loadHistoryList();

                    } catch (e) {
                        console.error(e);
                        this.poiStatus = "å¤±è´¥: " + e.message;
                    } finally {
                        this.isFetchingPois = false;
                    }
                },
                // Updated Render Logic
                renderPois(pois) {
                    if (this.poiMarkers) this.poiMarkers.forEach(m => m.setMap(null));
                    this.poiMarkers = [];

                    // Filter client-side based on current checkboxes (in case user toggles after fetch)
                    // Note: For now, we render what we fetched.
                    // Future enhancement: dynamic toggle without re-fetch.

                    const markers = pois.map(p => {
                        // Find category color
                        let color = '#999';
                        const typeCode = p.type ? p.type.substring(0, 6) : '';
                        const cat = this.poiCategories.find(c => typeCode.startsWith(c.code.substring(0, 2)));
                        if (cat) color = cat.color;

                        // Create CircleMarker
                        const marker = new AMap.CircleMarker({
                            center: p.location,
                            radius: 4, // px
                            strokeColor: 'white',
                            strokeWeight: 1,
                            fillColor: color,
                            fillOpacity: 0.9,
                            zIndex: 100,
                            bubble: true,
                            cursor: 'pointer',
                        });

                        // Info Window
                        marker.on('click', () => {
                            const info = [];
                            info.push(`<div style="padding:5px;"><b>${p.name}</b>`);
                            info.push(`<div style="font-size:12px;color:#666;">${p.type || 'æœªçŸ¥ç±»å‹'}</div>`);
                            info.push(`<div style="font-size:12px;color:#666;">${p.address || ''}</div>`);
                            info.push(`</div>`);

                            new AMap.InfoWindow({
                                content: info.join(""),
                                offset: new AMap.Pixel(0, -5)
                            }).open(this.mapCore.map, p.location);
                        });

                        marker.setMap(this.mapCore.map);
                        return marker;
                    });
                    this.poiMarkers = markers;
                },
                // Toggle visibility client-side
                toggleCategory() {
                    if (this.allPoisDetails.length > 0) {
                        // Filter logic
                        const activeCodes = this.poiCategories.filter(c => c.checked).map(c => c.code.substring(0, 2));
                        const filtered = this.allPoisDetails.filter(p => {
                            const pCode = p.type ? p.type.substring(0, 2) : '99';
                            return activeCodes.includes(pCode);
                        });
                        this.renderPois(filtered);
                    }
                },
                renderResult(geojson) {
                    if (!geojson || !geojson.geometry) {
                        this.errorMessage = "æœªè·å–åˆ°æœ‰æ•ˆæ•°æ®";
                        return;
                    }
                    const coords = geojson.geometry.coordinates;
                    const type = geojson.geometry.type;
                    let paths = [];
                    if (type === 'Polygon') {
                        paths.push(coords[0]);
                    } else if (type === 'MultiPolygon') {
                        coords.forEach(poly => paths.push(poly[0]));
                    }
                    this.mapCore.setCustomPolygons(paths);
                },
                async loadHistoryList() {
                    try {
                        console.log("Loading history list...");
                        const res = await fetch('/api/v1/analysis/history');
                        const data = await res.json();
                        console.log("History list loaded:", data);
                        this.historyList = data;
                    } catch (e) { console.error("History Load Error:", e); }
                },
                async deleteHistory(id) {
                    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ')) return;
                    try {
                        await fetch(`/api/v1/analysis/history/${id}`, { method: 'DELETE' });
                        this.loadHistoryList();
                    } catch (e) { console.error(e); }
                },
                async loadHistoryDetail(id) {
                    try {
                        const res = await fetch(`/api/v1/analysis/history/${id}`);
                        const data = await res.json();
                        if (!data) return;

                        // Cleanup previous state
                        if (this.marker) this.marker.setMap(null);
                        this.marker = null;
                        this.mapCore.clearCustomPolygons();
                        if (this.markerManager) {
                            // Ensure old markers are removed from map
                            if (this.markerManager.markers) {
                                this.markerManager.markers.forEach(m => m.setMap(null));
                            }
                            // Destroy clusterers if method exists
                            if (this.markerManager.destroyClusterers) {
                                this.markerManager.destroyClusterers();
                            }
                            // Clear internal references
                            this.markerManager.markers = [];
                            this.markerManager.points = [];
                            this.markerManager = null;
                        }
                        // Clear simplified poiMarkers array if used
                        if (this.poiMarkers) {
                            this.poiMarkers.forEach(m => m.setMap(null));
                            this.poiMarkers = [];
                        }

                        // Clear FilterPanel content to ensure clean rebuild
                        const filterContainer = document.getElementById('filtersContainer');
                        if (filterContainer) filterContainer.innerHTML = '';

                        if (data.params && data.params.center) {
                            this.selectedPoint = { lng: data.params.center[0], lat: data.params.center[1] };
                            this.mapCore.map.setCenter(data.params.center);
                            this.mapCore.center = { lng: data.params.center[0], lat: data.params.center[1] }; // Sync MapCore center
                            this.mapCore.setRadius(0); // Reset radius to avoid ghost circle at old location
                            // Restore time horizon if available
                            if (data.params.time_min) this.timeHorizon = data.params.time_min;
                        }

                        if (data.polygon) {
                            this.mapCore.setCustomPolygons([data.polygon]);
                            this.lastIsochroneGeoJSON = { geometry: { type: 'Polygon', coordinates: [data.polygon] } };
                        }
                        if (data.pois) {
                            this.allPoisDetails = data.pois;
                            // Integration with Legacy Filter Panel
                            if (this.updateLegacySystem) {
                                this.updateLegacySystem(data.pois);
                            } else {
                                this.renderPois(data.pois);
                            }
                            this.poiStatus = `å·²åŠ è½½å†å²: ${data.pois.length} æ¡`;
                        }


                        // Switch to Results Step
                        this.step = 3;
                        this.sidebarView = 'wizard'; // Return to wizard 
                        // this.showHistory = false; // Deprecated

                    } catch (e) {
                        console.error(e);
                        alert("åŠ è½½å¤±è´¥");
                    }
                },
                formatHistoryTitle(desc) {
                    if (!desc) return 'æ— æ ‡é¢˜åˆ†æ';
                    // Remove "15min Analysis - " prefix if present to avoid redundancy with tags
                    return desc.replace(/^\d+min Analysis - /, '');
                },
                resetAnalysis() {
                    this.step = 1;
                    this.sidebarView = 'wizard';
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    if (this.marker) {
                        this.marker.setMap(null);
                        this.marker = null;
                    }
                    this.mapCore.clearCustomPolygons();
                    this.mapCore.setRadius(0);
                    if (this.markerManager) {
                        if (this.markerManager.markers) this.markerManager.markers.forEach(m => m.setMap(null));
                        this.markerManager = null;
                    }
                    if (this.poiMarkers) {
                        this.poiMarkers.forEach(m => m.setMap(null));
                        this.poiMarkers = [];
                    }
                    this.mapCore.map.setFitView();
                },
                triggerSearch() {
                    const input = document.getElementById('keyword');
                    if (input && input.value && this.placeSearch) {
                        this.placeSearch.search(input.value, (status, result) => {
                            if (status === 'complete' && result.poiList.pois.length > 0) {
                                const poi = result.poiList.pois[0];
                                this.mapCore.map.setZoomAndCenter(15, poi.location);
                                this.setSelectedPoint(poi.location);
                            } else {
                                this.errorMessage = "æœªæ‰¾åˆ°è¯¥åœ°ç‚¹";
                            }
                        });
                    }
                },
                saveAndRestart() {
                    this.step = 1;
                    this.selectedPoint = null;
                    this.errorMessage = '';
                    this.poiStatus = '';
                    if (this.marker) this.marker.setMap(null);
                    this.marker = null;
                    this.mapCore.clearCustomPolygons();
                    if (this.markerManager) {
                        this.markerManager.markers.forEach(m => m.setMap(null));
                        this.markerManager.destroyClusterers();
                    }
                },
                updateLegacySystem(pois) {
                    const points = pois.map((p, idx) => {
                        let matchedType = '990000';
                        for (let cat of this.poiCategories) {
                            if (p.type && p.type.startsWith(cat.code.substring(0, 2))) {
                                matchedType = cat.code;
                                break;
                            }
                        }
                        return {
                            lng: p.location[0],
                            lat: p.location[1],
                            name: p.name,
                            type: matchedType,
                            address: p.address,
                            lines: p.lines,
                            _pid: p.id || ('p-' + idx)
                        };
                    });

                    const mapTypeConfig = {
                        groups: [{
                            id: 'poi_group',
                            title: 'POI åˆ†ç±»',
                            toggleId: 'toggle_poi',
                            filtersId: 'filters_poi',
                            items: this.poiCategories.map(c => ({
                                id: c.code,
                                label: c.name,
                                color: c.color,
                                defaultChecked: c.checked
                            }))
                        }]
                    };

                    const centerObj = this.selectedPoint ? {
                        lng: this.selectedPoint.lng,
                        lat: this.selectedPoint.lat,
                        name: 'ä¸­å¿ƒç‚¹',
                        type: 'center'
                    } : null;

                    this.markerManager = new MarkerManager(this.mapCore, {
                        mapData: { points: points, center: centerObj },
                        mapTypeConfig: mapTypeConfig
                    });
                    this.markerManager.init();
                    this.markerManager.renderMarkers();

                    // Filter Panel
                    const heatmapManager = new HeatmapManager(this.mapCore, { radius: 35, maxCount: 100 });
                    this.filterPanel = new FilterPanel(this.markerManager, {
                        mapData: { points: points },
                        mapTypeConfig: mapTypeConfig,
                        heatmapManager: heatmapManager
                    });
                    this.filterPanel.init();
                    this.markerManager.applyFilters();
                }
            }
        }).mount('#app');
    </script>
</body>

</html>